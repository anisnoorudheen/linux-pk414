From 66bc4df74a80410ed799e851329948d2257957c6 Mon Sep 17 00:00:00 2001
From: Miguel Bernal Marin <miguel.bernal.marin@linux.intel.com>
Date: Wed, 29 Aug 2018 06:22:24 -0500
Subject: [PATCH 8012/8021] misc: intel: soc_perf: add include files

---
 .../intel/soc_perf/include/lwpmudrv_defines.h |  435 +++++
 .../intel/soc_perf/include/lwpmudrv_ecb.h     | 1004 ++++++++++
 .../intel/soc_perf/include/lwpmudrv_ioctl.h   |  302 +++
 .../intel/soc_perf/include/lwpmudrv_struct.h  | 1723 +++++++++++++++++
 .../intel/soc_perf/include/lwpmudrv_types.h   |  139 ++
 .../intel/soc_perf/include/lwpmudrv_version.h |  148 ++
 .../misc/intel/soc_perf/include/rise_errors.h |  328 ++++
 7 files changed, 4079 insertions(+)
 create mode 100644 drivers/misc/intel/soc_perf/include/lwpmudrv_defines.h
 create mode 100644 drivers/misc/intel/soc_perf/include/lwpmudrv_ecb.h
 create mode 100644 drivers/misc/intel/soc_perf/include/lwpmudrv_ioctl.h
 create mode 100644 drivers/misc/intel/soc_perf/include/lwpmudrv_struct.h
 create mode 100644 drivers/misc/intel/soc_perf/include/lwpmudrv_types.h
 create mode 100644 drivers/misc/intel/soc_perf/include/lwpmudrv_version.h
 create mode 100644 drivers/misc/intel/soc_perf/include/rise_errors.h

diff --git a/drivers/misc/intel/soc_perf/include/lwpmudrv_defines.h b/drivers/misc/intel/soc_perf/include/lwpmudrv_defines.h
new file mode 100644
index 000000000000..5c0d1718544f
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/include/lwpmudrv_defines.h
@@ -0,0 +1,435 @@
+/***
+ * -------------------------------------------------------------------------
+ *               INTEL CORPORATION PROPRIETARY INFORMATION
+ *  This software is supplied under the terms of the accompanying license
+ *  agreement or nondisclosure agreement with Intel Corporation and may not
+ *  be copied or disclosed except in accordance with the terms of that
+ *  agreement.
+ *        Copyright(C) 2007-2018 Intel Corporation.  All Rights Reserved.
+ * -------------------------------------------------------------------------
+***/
+
+#ifndef  _LWPMUDRV_DEFINES_H_
+#define  _LWPMUDRV_DEFINES_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+//
+// Start off with none of the OS'es are defined
+//
+#undef DRV_OS_WINDOWS
+#undef DRV_OS_LINUX
+#undef DRV_OS_SOLARIS
+#undef DRV_OS_MAC
+#undef DRV_OS_ANDROID
+#undef DRV_OS_UNIX
+
+//
+// Make sure none of the architectures is defined here
+//
+#undef DRV_IA32
+#undef DRV_EM64T
+
+//
+// Make sure one (and only one) of the OS'es gets defined here
+//
+// Unfortunately entirex defines _WIN32 so we need to check for linux
+// first.  The definition of these flags is one and only one
+// _OS_xxx is allowed to be defined.
+//
+#if defined(__ANDROID__)
+#define DRV_OS_ANDROID
+#define DRV_OS_UNIX
+#elif defined(__linux__)
+#define DRV_OS_LINUX
+#define DRV_OS_UNIX
+#elif defined(sun)
+#define DRV_OS_SOLARIS
+#define DRV_OS_UNIX
+#elif defined(_WIN32)
+#define DRV_OS_WINDOWS
+#elif defined(__APPLE__)
+#define DRV_OS_MAC
+#define DRV_OS_UNIX
+#elif defined(__FreeBSD__)
+#define DRV_OS_FREEBSD
+#define DRV_OS_UNIX
+#else
+#error "Compiling for an unknown OS"
+#endif
+
+//
+// Make sure one (and only one) architecture is defined here
+// as well as one (and only one) pointer__ size
+//
+#if defined(_M_IX86) || defined(__i386__)
+#define DRV_IA32
+#elif defined(_M_AMD64) || defined(__x86_64__)
+#define DRV_EM64T
+#else
+#error "Unknown architecture for compilation"
+#endif
+
+//
+// Add a well defined definition of compiling for release (free) vs.
+// debug (checked). Once again, don't assume these are the only two values,
+// always have an else clause in case we want to expand this.
+//
+#if defined(DRV_OS_UNIX)
+#define WINAPI
+#endif
+
+/*
+ *  Add OS neutral defines for file processing.  This is needed in both
+ *  the user code and the kernel code for cleanliness
+ */
+#undef DRV_FILE_DESC
+#undef DRV_INVALID_FILE_DESC_VALUE
+#define DRV_ASSERT  assert
+
+#if defined(DRV_OS_WINDOWS)
+
+#define DRV_FILE_DESC                HANDLE
+#define DRV_INVALID_FILE_DESC_VALUE  INVALID_HANDLE_VALUE
+
+#elif defined(DRV_OS_LINUX) || defined(DRV_OS_SOLARIS) || defined(DRV_OS_ANDROID)
+
+#define DRV_IOCTL_FILE_DESC                 SIOP
+#define DRV_FILE_DESC                       SIOP
+#define DRV_INVALID_FILE_DESC_VALUE         -1
+
+#elif defined(DRV_OS_FREEBSD)
+
+#define DRV_IOCTL_FILE_DESC                 S64
+#define DRV_FILE_DESC                       S64
+#define DRV_INVALID_FILE_DESC_VALUE         -1
+
+#elif defined(DRV_OS_MAC)
+#if defined __LP64__
+#define DRV_IOCTL_FILE_DESC                 S64
+#define DRV_FILE_DESC                       S64
+#define DRV_INVALID_FILE_DESC_VALUE         (S64)(-1)
+#else
+#define DRV_IOCTL_FILE_DESC                 S32
+#define DRV_FILE_DESC                       S32
+#define DRV_INVALID_FILE_DESC_VALUE         (S32)(-1)
+#endif
+
+#else
+
+#error "Compiling for an unknown OS"
+
+#endif
+
+#define OUT
+#define IN
+#define INOUT
+
+//
+// VERIFY_SIZEOF let's you insert a compile-time check that the size of a data
+// type (e.g. a struct) is what you think it should be.  Usually it is
+// important to know what the actual size of your struct is, and to make sure
+// it is the same across all platforms.  So this will prevent the code from
+// compiling if something happens that you didn't expect, whether it's because
+// you counted wring, or more often because the compiler inserted padding that
+// you don't want.
+//
+// NOTE: 'elem' and 'size' must both be identifier safe, e.g. matching the
+// regular expression /^[0-9a-zA-Z_]$/.
+//
+// Example:
+//   typedef struct { void *ptr; int data; } mytype;
+//   VERIFY_SIZEOF(mytype, 8);
+//                         ^-- this is correct on 32-bit platforms, but fails
+//                             on 64-bit platforms, indicating a possible
+//                             portability issue.
+//
+#define VERIFY_SIZEOF(type, size) \
+    enum { sizeof_ ## type ## _eq_ ## size = 1 / (int)(sizeof(type) == size) }
+
+#if defined(DRV_OS_WINDOWS)
+#define DRV_DLLIMPORT      __declspec(dllimport)
+#define DRV_DLLEXPORT      __declspec(dllexport)
+#endif
+#if defined(DRV_OS_UNIX)
+#define DRV_DLLIMPORT
+#define DRV_DLLEXPORT
+#endif
+
+#if defined(DRV_OS_WINDOWS)
+#define FSI64RAW              "I64"
+#define FSS64                 "%"FSI64RAW"d"
+#define FSU64                 "%"FSI64RAW"u"
+#define FSX64                 "%"FSI64RAW"x"
+#define DRV_PATH_SEPARATOR    "\\"
+#define L_DRV_PATH_SEPARATOR L"\\"
+#endif
+
+#if defined(DRV_OS_UNIX)
+#define FSI64RAW              "ll"
+#define FSS64                 "%"FSI64RAW"d"
+#define FSU64                 "%"FSI64RAW"u"
+#define FSX64                 "%"FSI64RAW"x"
+#define DRV_PATH_SEPARATOR    "/"
+#define L_DRV_PATH_SEPARATOR L"/"
+#endif
+
+#if defined(DRV_OS_WINDOWS)
+#define DRV_RTLD_NOW    0
+#endif
+#if defined(DRV_OS_UNIX)
+#if defined(DRV_OS_FREEBSD)
+#define DRV_RTLD_NOW 0
+#else
+#define DRV_RTLD_NOW    RTLD_NOW
+#endif
+#endif
+
+#define DRV_STRLEN                       (U32)strlen
+#define DRV_WCSLEN                       (U32)wcslen
+#define DRV_STRCSPN                      strcspn
+#define DRV_STRCHR                       strchr
+#define DRV_STRRCHR                      strrchr
+#define DRV_WCSRCHR                      wcsrchr
+
+#if defined(DRV_OS_WINDOWS)
+#define DRV_STCHARLEN                    DRV_WCSLEN
+#else
+#define DRV_STCHARLEN                    DRV_STRLEN
+#endif
+
+#if defined(DRV_OS_WINDOWS)
+#define DRV_STRCPY                       strcpy_s
+#define DRV_STRNCPY                      strncpy_s
+#define DRV_STRICMP                     _stricmp
+#define DRV_STRNCMP                      strncmp
+#define DRV_STRNICMP                    _strnicmp
+#define DRV_STRDUP                      _strdup
+#define DRV_WCSDUP                      _wcsdup
+#define DRV_STRCMP                       strcmp
+#define DRV_WCSCMP                       wcscmp
+#define DRV_SNPRINTF                    _snprintf_s
+#define DRV_SNWPRINTF                   _snwprintf_s
+#define DRV_VSNPRINTF                   _vsnprintf_s
+#define DRV_SSCANF                       sscanf_s
+#define DRV_STRCAT                       strcat_s
+#define DRV_STRNCAT                      strncat_s
+#define DRV_MEMCPY                       memcpy_s
+#define DRV_STRTOK                       strtok_s
+#define DRV_STRTOUL                      strtoul
+#define DRV_STRTOULL                     _strtoui64
+#define DRV_STRTOQ                      _strtoui64
+#define DRV_FOPEN(fp,name,mode)          fopen_s(&(fp),(name),(mode))
+#define DRV_WFOPEN(fp,name,mode)        _wfopen_s(&(fp),(name),(mode))
+#define DRV_FCLOSE(fp)                   if ((fp) != NULL) { fclose((fp)); }
+#define DRV_WCSCPY                       wcscpy_s
+#define DRV_WCSNCPY                      wcsncpy_s
+#define DRV_WCSCAT                       wcscat_s
+#define DRV_WCSNCAT                      wcsncat_s
+#define DRV_WCSTOK                       wcstok_s
+#define DRV_WCSSTR                       wcsstr
+#define DRV_STRERROR                     strerror_s
+#define DRV_SPRINTF                      sprintf_s
+#define DRV_VSPRINTF                     vsprintf_s
+#define DRV_VSWPRINTF                    vswprintf_s
+#define DRV_GETENV_S                     getenv_s
+#define DRV_WGETENV_S                    wgetenv_s
+#define DRV_PUTENV(name)                _putenv(name)
+#define DRV_USTRCMP(X, Y)                DRV_WCSCMP(X, Y)
+#define DRV_USTRDUP(X)                   DRV_WCSDUP(X)
+#define DRV_ACCESS(X)                    _access_s(X, 4)
+#define DRV_STRSTR                       strstr
+
+#define DRV_GETENV(buf,buf_size,name)   _dupenv_s(&(buf),&(buf_size),(name))
+#define DRV_WGETENV(buf,buf_size,name)  _wdupenv_s(&(buf),&(buf_size),(name))
+#endif
+
+#if defined(DRV_OS_UNIX)
+/*
+   Note: Many of the following macros have a "size" as the second argument.  Generally
+         speaking, this is for compatibility with the _s versions available on Windows.
+         On Linux/Solaris/Mac, it is ignored.  On Windows, it is the size of the destination
+         buffer and is used wrt memory checking features available in the C runtime in debug
+         mode.  Do not confuse it with the number of bytes to be copied, or such.
+
+         On Windows, this size should correspond to the number of allocated characters
+         (char or wchar_t) pointed to by the first argument.  See MSDN for more details.
+*/
+#define DRV_STRICMP                              strcasecmp
+#define DRV_STRDUP                               strdup
+#define DRV_STRNDUP                              strndup
+#define DRV_STRCMP                               strcmp
+#define DRV_STRNCMP                              strncmp
+#define DRV_STRSTR                               strstr
+#define DRV_SNPRINTF(buf,buf_size,length,args...)   snprintf((buf),(length),##args)
+#define DRV_SNWPRINTF(buf,buf_size,length,args...)  snwprintf((buf),(length),##args)
+#define DRV_VSNPRINTF(buf,buf_size,length,args...)  vsnprintf((buf),(length),##args)
+#define DRV_SSCANF                               sscanf
+#define DRV_STRCPY(dst,dst_size,src)             strcpy((dst),(src))
+#define DRV_STRNCPY(dst,dst_size,src,n)          strncpy((dst),(src),(n))
+#define DRV_STRCAT(dst,dst_size,src)             strcat((dst),(src))
+#define DRV_STRNCAT(dst,dst_size,src,n)          strncat((dst),(src),(n))
+#define DRV_MEMCPY(dst,dst_size,src,n)           memcpy((dst),(src), (n))
+#define DRV_STRTOK(tok,delim,context)            strtok((tok),(delim))
+#define DRV_STRTOUL                              strtoul
+#define DRV_STRTOULL                             strtoull
+#define DRV_STRTOL                               strtol
+#define DRV_FOPEN(fp,name,mode)                  (fp) = fopen((name),(mode))
+#define DRV_FCLOSE(fp)                           if ((fp) != NULL) { fclose((fp)); }
+#define DRV_WCSCPY(dst,dst_size,src)             wcscpy((dst),(const wchar_t *)(src))
+#define DRV_WCSNCPY(dst,dst_size,src,count)      wcsncpy((dst),(const wchar_t *)(src),(count))
+#define DRV_WCSCAT(dst,dst_size,src)             wcscat((dst),(const wchar_t *)(src))
+#define DRV_WCSTOK(tok,delim,context)            wcstok((tok),(const wchar_t *)(delim),(context))
+#define DRV_STRERROR                             strerror
+#define DRV_SPRINTF(dst,dst_size,args...)        sprintf((dst),##args)
+#define DRV_VSPRINTF(dst,dst_size,length,args...)    vsprintf((dst),(length),##args)
+#define DRV_VSWPRINTF(dst,dst_size,length,args...)   vswprintf((dst),(length),##args)
+#define DRV_GETENV_S(dst,dst_size)               getenv(dst)
+#define DRV_WGETENV_S(dst,dst_size)              wgetenv(dst)
+#define DRV_PUTENV(name)                         putenv(name)
+#define DRV_GETENV(buf,buf_size,name)            ((buf)=getenv((name)))
+#define DRV_USTRCMP(X, Y)                        DRV_STRCMP(X, Y)
+#define DRV_USTRDUP(X)                           DRV_STRDUP(X)
+#define DRV_ACCESS(X)                            access(X, X_OK)
+#endif
+
+#if defined(DRV_OS_LINUX) || defined(DRV_OS_MAC) || defined(DRV_OS_FREEBSD)
+#define DRV_STRTOQ                               strtoq
+#endif
+
+#if defined(DRV_OS_ANDROID)
+#define DRV_STRTOQ                               strtol
+#endif
+
+#if defined(DRV_OS_SOLARIS)
+#define DRV_STRTOQ                               strtoll
+#endif
+
+#if defined(DRV_OS_LINUX) || defined(DRV_OS_FREEBSD) || defined(DRV_OS_MAC)
+#define DRV_WCSDUP                               wcsdup
+#endif
+
+#if defined(DRV_OS_SOLARIS)
+#define DRV_WCSDUP                               solaris_wcsdup
+#endif
+
+#if defined(DRV_OS_ANDROID)
+#define DRV_WCSDUP                               android_wcsdup
+#endif
+
+/*
+ * Windows uses wchar_t and linux uses char for strings.
+ * Need an extra level of abstraction to standardize it.
+ */
+#if defined(DRV_OS_WINDOWS)
+#define DRV_STDUP                               DRV_WCSDUP
+#define DRV_FORMAT_STRING(x)                    L ## x
+#define DRV_PRINT_STRING(stream, format, ...)   fwprintf((stream), (format), __VA_ARGS__)
+#else
+#define DRV_STDUP                               DRV_STRDUP
+#define DRV_FORMAT_STRING(x)                    x
+#define DRV_PRINT_STRING(stream, format, ...)   fprintf((stream), (format), __VA_ARGS__)
+#endif
+
+
+/*
+ * OS return types
+ */
+#if defined(DRV_OS_UNIX)
+#define OS_STATUS           int
+#define OS_SUCCESS          0
+#define OS_ILLEGAL_IOCTL    -ENOTTY
+#define OS_NO_MEM           -ENOMEM
+#define OS_FAULT            -EFAULT
+#define OS_INVALID          -EINVAL
+#define OS_NO_SYSCALL       -ENOSYS
+#define OS_RESTART_SYSCALL  -ERESTARTSYS
+#define OS_IN_PROGRESS      -EALREADY
+#endif
+
+/****************************************************************************
+ **  Driver State defintions
+ ***************************************************************************/
+#define  DRV_STATE_UNINITIALIZED       0
+#define  DRV_STATE_RESERVED            1
+#define  DRV_STATE_IDLE                2
+#define  DRV_STATE_PAUSED              3
+#define  DRV_STATE_STOPPED             4
+#define  DRV_STATE_RUNNING             5
+#define  DRV_STATE_PAUSING             6
+#define  DRV_STATE_PREPARE_STOP        7
+#define  DRV_STATE_TERMINATING         8
+
+#define  MATCHING_STATE_BIT(state)     ((U32)1 << state)
+#define  STATE_BIT_UNINITIALIZED       MATCHING_STATE_BIT(DRV_STATE_UNINITIALIZED)
+#define  STATE_BIT_RESERVED            MATCHING_STATE_BIT(DRV_STATE_RESERVED)
+#define  STATE_BIT_IDLE                MATCHING_STATE_BIT(DRV_STATE_IDLE)
+#define  STATE_BIT_PAUSED              MATCHING_STATE_BIT(DRV_STATE_PAUSED)
+#define  STATE_BIT_STOPPED             MATCHING_STATE_BIT(DRV_STATE_STOPPED)
+#define  STATE_BIT_RUNNING             MATCHING_STATE_BIT(DRV_STATE_RUNNING)
+#define  STATE_BIT_PAUSING             MATCHING_STATE_BIT(DRV_STATE_PAUSING)
+#define  STATE_BIT_PREPARE_STOP        MATCHING_STATE_BIT(DRV_STATE_PREPARE_STOP)
+#define  STATE_BIT_TERMINATING         MATCHING_STATE_BIT(DRV_STATE_TERMINATING)
+#define  STATE_BIT_ANY                 ((U32)-1)
+
+#define  IS_COLLECTING_STATE(state)    (!!(MATCHING_STATE_BIT(state) & (STATE_BIT_RUNNING | STATE_BIT_PAUSING | STATE_BIT_PAUSED)))
+
+/*
+ *  Stop codes
+ */
+#define DRV_STOP_BASE      0
+#define DRV_STOP_NORMAL    1
+#define DRV_STOP_ASYNC     2
+#define DRV_STOP_CANCEL    3
+
+#define SEP_FREE(loc)   if ((loc)) { free(loc); loc = NULL; }
+
+#define MAX_EVENTS 256       // Limiting maximum multiplexing events to 256.
+#if defined(DRV_OS_UNIX)
+#define UNREFERENCED_PARAMETER(p)       ((p) = (p))
+#endif
+
+/*
+ * Global marker names
+ */
+#define START_MARKER_NAME       "SEP_START_MARKER"
+#define PAUSE_MARKER_NAME       "SEP_PAUSE_MARKER"
+#define RESUME_MARKER_NAME      "SEP_RESUME_MARKER"
+
+#define DRV_SOC_STRING_LEN      100 + MAX_MARKER_LENGTH
+
+/*
+ * Temp path
+ */
+#define SEP_TMPDIR                               "SEP_TMP_DIR"
+#if defined(DRV_OS_WINDOWS)
+#define OS_TMPDIR                                "TEMP"
+#define GET_DEFAULT_TMPDIR(dir, size)            {GetTempPath((U32)size, dir);}
+#else
+#define OS_TMPDIR              "TMPDIR"
+/*
+ * Unix has default tmp dir
+ */
+#if defined(DRV_OS_ANDROID)
+#define TEMP_PATH              "/data"
+#else
+#define TEMP_PATH              "/tmp"
+#endif
+#define GET_DEFAULT_TMPDIR(dir, size)            {DRV_STRCPY((STCHAR *)dir, (U32)size, (STCHAR *)TEMP_PATH);}
+#endif
+
+#define  OS_ID_UNKNOWN          -1
+#define  OS_ID_NATIVE           0
+#define  OS_ID_VMM              0
+#define  OS_ID_MODEM            1
+#define  OS_ID_ANDROID          2
+#define  OS_ID_SECVM            3
+
+#define PERF_HW_VER4           (5)
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
+
diff --git a/drivers/misc/intel/soc_perf/include/lwpmudrv_ecb.h b/drivers/misc/intel/soc_perf/include/lwpmudrv_ecb.h
new file mode 100644
index 000000000000..da938868f07d
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/include/lwpmudrv_ecb.h
@@ -0,0 +1,1004 @@
+/***
+ * -------------------------------------------------------------------------
+ *               INTEL CORPORATION PROPRIETARY INFORMATION
+ *  This software is supplied under the terms of the accompanying license
+ *  agreement or nondisclosure agreement with Intel Corporation and may not
+ *  be copied or disclosed except in accordance with the terms of that
+ *  agreement.
+ *        Copyright(C) 2007-2018 Intel Corporation.  All Rights Reserved.
+ * -------------------------------------------------------------------------
+***/
+
+#ifndef _LWPMUDRV_ECB_UTILS_H_
+#define _LWPMUDRV_ECB_UTILS_H_
+
+#if defined(DRV_OS_WINDOWS)
+#pragma warning (disable:4200)
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+// control register types
+#define CCCR                1   // counter configuration control register
+#define ESCR                2   // event selection control register
+#define DATA                4   // collected as snapshot of current value
+#define DATA_RO_DELTA       8   // read-only counter collected as current-previous
+#define DATA_RO_SS          16  // read-only counter collected as snapshot of current value
+#define METRICS             32  // hardware metrics
+
+// event multiplexing modes
+#define EM_DISABLED                -1
+#define EM_TIMER_BASED              0
+#define EM_EVENT_BASED_PROFILING    1
+#define EM_TRIGGER_BASED            2
+
+// ***************************************************************************
+
+/*!\struct EVENT_DESC_NODE
+ * \var    sample_size                   - size of buffer in bytes to hold the sample + extras
+ * \var    max_gp_events                 - max number of General Purpose events per EM group
+ * \var    pebs_offset                   - offset in the sample to locate the pebs capture information
+ * \var    lbr_offset                    - offset in the sample to locate the lbr information
+ * \var    lbr_num_regs                  - offset in the sample to locate the number of lbr register information
+ * \var    latency_offset_in_sample      - offset in the sample to locate the latency information
+ * \var    latency_size_in_sample        - size of latency records in the sample
+ * \var    latency_size_from_pebs_record - size of the latency data from pebs record in the sample
+ * \var    latency_offset_in_pebs_record - offset in the sample to locate the latency information
+ *                                         in pebs record
+ * \var    power_offset_in_sample        - offset in the sample to locate the power information
+ * \var    ebc_offset                    - offset in the sample to locate the ebc count information
+ * \var    uncore_ebc_offset             - offset in the sample to locate the uncore ebc count information
+ *
+ * \var    ro_offset                     - offset of RO data in the sample
+ * \var    ro_count                      - total number of RO entries (including all of IEAR/DEAR/BTB/IPEAR)
+ * \var    iear_offset                   - offset into RO data at which IEAR entries begin
+ * \var    dear_offset                   - offset into RO data at which DEAR entries begin
+ * \var    btb_offset                    - offset into RO data at which BTB entries begin (these use the same PMDs)
+ * \var    ipear_offset                  - offset into RO data at which IPEAR entries begin (these use the same PMDs)
+ * \var    iear_count                    - number of IEAR entries
+ * \var    dear_count                    - number of DEAR entries
+ * \var    btb_count                     - number of BTB entries
+ * \var    ipear_count                   - number of IPEAR entries
+ *
+ * \var    pwr_offset                    - offset in the sample to locate the pwr count information
+ * \var    p_state_offset                - offset in the sample to locate the p_state information (APERF/MPERF)
+ *
+ * \brief  Data structure to describe the events and the mode
+ *
+ */
+
+typedef struct EVENT_DESC_NODE_S  EVENT_DESC_NODE;
+typedef        EVENT_DESC_NODE   *EVENT_DESC;
+
+struct EVENT_DESC_NODE_S {
+    U32     sample_size;
+    U32     pebs_offset;
+    U32     pebs_size;
+    U32     lbr_offset;
+    U32     lbr_num_regs;
+    U32     latency_offset_in_sample;
+    U32     latency_size_in_sample;
+    U32     latency_size_from_pebs_record;
+    U32     latency_offset_in_pebs_record;
+    U32     power_offset_in_sample;
+    U32     ebc_offset;
+    U32     uncore_ebc_offset;
+    U32     eventing_ip_offset;
+    U32     hle_offset;
+    U32     pwr_offset;
+    U32     callstack_offset;
+    U32     callstack_size;
+    U32     p_state_offset;
+    U32     pebs_tsc_offset;
+    U32     perfmetrics_offset;
+    U32     perfmetrics_size;
+    /* ----------ADAPTIVE PEBS FIELDS --------- */
+    U16     applicable_counters_offset;
+    U16     gpr_info_offset;
+    U16     gpr_info_size;
+    U16     xmm_info_offset;
+    U16     xmm_info_size;
+    U16     lbr_info_size;
+    /*------------------------------------------*/
+    U32     reserved2;
+    U64     reserved3;
+};
+
+//
+// Accessor macros for EVENT_DESC node
+//
+#define EVENT_DESC_sample_size(ec)                        (ec)->sample_size
+#define EVENT_DESC_pebs_offset(ec)                        (ec)->pebs_offset
+#define EVENT_DESC_pebs_size(ec)                          (ec)->pebs_size
+#define EVENT_DESC_lbr_offset(ec)                         (ec)->lbr_offset
+#define EVENT_DESC_lbr_num_regs(ec)                       (ec)->lbr_num_regs
+#define EVENT_DESC_latency_offset_in_sample(ec)           (ec)->latency_offset_in_sample
+#define EVENT_DESC_latency_size_from_pebs_record(ec)      (ec)->latency_size_from_pebs_record
+#define EVENT_DESC_latency_offset_in_pebs_record(ec)      (ec)->latency_offset_in_pebs_record
+#define EVENT_DESC_latency_size_in_sample(ec)             (ec)->latency_size_in_sample
+#define EVENT_DESC_power_offset_in_sample(ec)             (ec)->power_offset_in_sample
+#define EVENT_DESC_ebc_offset(ec)                         (ec)->ebc_offset
+#define EVENT_DESC_uncore_ebc_offset(ec)                  (ec)->uncore_ebc_offset
+#define EVENT_DESC_eventing_ip_offset(ec)                 (ec)->eventing_ip_offset
+#define EVENT_DESC_hle_offset(ec)                         (ec)->hle_offset
+#define EVENT_DESC_pwr_offset(ec)                         (ec)->pwr_offset
+#define EVENT_DESC_callstack_offset(ec)                   (ec)->callstack_offset
+#define EVENT_DESC_callstack_size(ec)                     (ec)->callstack_size
+#define EVENT_DESC_perfmetrics_offset(ec)                 (ec)->perfmetrics_offset
+#define EVENT_DESC_perfmetrics_size(ec)                   (ec)->perfmetrics_size
+#define EVENT_DESC_p_state_offset(ec)                     (ec)->p_state_offset
+#define EVENT_DESC_pebs_tsc_offset(ec)                    (ec)->pebs_tsc_offset
+#define EVENT_DESC_applicable_counters_offset(ec)         (ec)->applicable_counters_offset
+#define EVENT_DESC_gpr_info_offset(ec)                    (ec)->gpr_info_offset
+#define EVENT_DESC_gpr_info_size(ec)                      (ec)->gpr_info_size
+#define EVENT_DESC_xmm_info_offset(ec)                    (ec)->xmm_info_offset
+#define EVENT_DESC_xmm_info_size(ec)                      (ec)->xmm_info_size
+#define EVENT_DESC_lbr_info_size(ec)                      (ec)->lbr_info_size
+
+// ***************************************************************************
+
+/*!\struct EVENT_CONFIG_NODE
+ * \var    num_groups      -  The number of groups being programmed
+ * \var    em_mode         -  Is EM valid?  If so how?
+ * \var    em_time_slice   -  EM valid?  time slice in milliseconds
+ * \var    sample_size     -  size of buffer in bytes to hold the sample + extras
+ * \var    max_gp_events   -  Max number of General Purpose events per EM group
+ * \var    pebs_offset     -  offset in the sample to locate the pebs capture information
+ * \var    lbr_offset      -  offset in the sample to locate the lbr information
+ * \var    lbr_num_regs    -  offset in the sample to locate the lbr information
+ * \var    latency_offset_in_sample      -  offset in the sample to locate the latency information
+ * \var    latency_size_in_sample        -  size of latency records in the sample
+ * \var    latency_size_from_pebs_record -  offset in the sample to locate the latency
+ *                                          size from pebs record
+ * \var    latency_offset_in_pebs_record -  offset in the sample to locate the latency information
+ *                                          in pebs record
+ * \var    power_offset_in_sample        -  offset in the sample to locate the power information
+ * \var    ebc_offset                    -  offset in the sample to locate the ebc count information
+ *
+ * \var    pwr_offset                    -  offset in the sample to locate the pwr count information
+ * \var    p_state_offset                -  offset in the sample to locate the p_state information (APERF/MPERF)
+ *
+ * \brief  Data structure to describe the events and the mode
+ *
+ */
+
+typedef struct EVENT_CONFIG_NODE_S  EVENT_CONFIG_NODE;
+typedef        EVENT_CONFIG_NODE   *EVENT_CONFIG;
+
+struct EVENT_CONFIG_NODE_S {
+    U32     num_groups;
+    S32     em_mode;
+    S32     em_factor;
+    S32     em_event_num;
+    U32     sample_size;
+    U32     max_gp_events;
+    U32     max_fixed_counters;
+    U32     max_ro_counters;    // maximum read-only counters
+    U32     pebs_offset;
+    U32     pebs_size;
+    U32     lbr_offset;
+    U32     lbr_num_regs;
+    U32     latency_offset_in_sample;
+    U32     latency_size_in_sample;
+    U32     latency_size_from_pebs_record;
+    U32     latency_offset_in_pebs_record;
+    U32     power_offset_in_sample;
+    U32     ebc_offset;
+    U32     num_groups_unc;
+    U32     ebc_offset_unc;
+    U32     sample_size_unc;
+    U32     eventing_ip_offset;
+    U32     hle_offset;
+    U32     pwr_offset;
+    U32     callstack_offset;
+    U32     callstack_size;
+    U32     p_state_offset;
+    U32     pebs_tsc_offset;
+    U16     unc_timer_interval;
+    U16     unc_em_factor;
+    U32     reserved1;
+    U64     reserved2;
+    U64     reserved3;
+    U64     reserved4;
+};
+
+//
+// Accessor macros for EVENT_CONFIG node
+//
+#define EVENT_CONFIG_num_groups(ec)                         (ec)->num_groups
+#define EVENT_CONFIG_mode(ec)                               (ec)->em_mode
+#define EVENT_CONFIG_em_factor(ec)                          (ec)->em_factor
+#define EVENT_CONFIG_em_event_num(ec)                       (ec)->em_event_num
+#define EVENT_CONFIG_sample_size(ec)                        (ec)->sample_size
+#define EVENT_CONFIG_max_gp_events(ec)                      (ec)->max_gp_events
+#define EVENT_CONFIG_max_fixed_counters(ec)                 (ec)->max_fixed_counters
+#define EVENT_CONFIG_max_ro_counters(ec)                    (ec)->max_ro_counters
+#define EVENT_CONFIG_pebs_offset(ec)                        (ec)->pebs_offset
+#define EVENT_CONFIG_pebs_size(ec)                          (ec)->pebs_size
+#define EVENT_CONFIG_lbr_offset(ec)                         (ec)->lbr_offset
+#define EVENT_CONFIG_lbr_num_regs(ec)                       (ec)->lbr_num_regs
+#define EVENT_CONFIG_latency_offset_in_sample(ec)           (ec)->latency_offset_in_sample
+#define EVENT_CONFIG_latency_size_from_pebs_record(ec)      (ec)->latency_size_from_pebs_record
+#define EVENT_CONFIG_latency_offset_in_pebs_record(ec)      (ec)->latency_offset_in_pebs_record
+#define EVENT_CONFIG_latency_size_in_sample(ec)             (ec)->latency_size_in_sample
+#define EVENT_CONFIG_power_offset_in_sample(ec)             (ec)->power_offset_in_sample
+#define EVENT_CONFIG_ebc_offset(ec)                         (ec)->ebc_offset
+#define EVENT_CONFIG_num_groups_unc(ec)                     (ec)->num_groups_unc
+#define EVENT_CONFIG_ebc_offset_unc(ec)                     (ec)->ebc_offset_unc
+#define EVENT_CONFIG_sample_size_unc(ec)                    (ec)->sample_size_unc
+#define EVENT_CONFIG_eventing_ip_offset(ec)                 (ec)->eventing_ip_offset
+#define EVENT_CONFIG_hle_offset(ec)                         (ec)->hle_offset
+#define EVENT_CONFIG_pwr_offset(ec)                         (ec)->pwr_offset
+#define EVENT_CONFIG_callstack_offset(ec)                   (ec)->callstack_offset
+#define EVENT_CONFIG_callstack_size(ec)                     (ec)->callstack_size
+#define EVENT_CONFIG_p_state_offset(ec)                     (ec)->p_state_offset
+#define EVENT_CONFIG_pebs_tsc_offset(ec)                    (ec)->pebs_tsc_offset
+#define EVENT_CONFIG_unc_timer_interval(ec)                 (ec)->unc_timer_interval
+#define EVENT_CONFIG_unc_em_factor(ec)                      (ec)->unc_em_factor
+
+typedef enum {
+    UNC_MUX = 1,
+    UNC_COUNTER
+} UNC_SA_PROG_TYPE;
+
+typedef enum {
+    UNC_PCICFG = 1,
+    UNC_MMIO,
+    UNC_STOP,
+    UNC_MEMORY,
+    UNC_STATUS
+} UNC_SA_CONFIG_TYPE;
+
+typedef enum {
+    UNC_MCHBAR = 1,
+    UNC_DMIBAR,
+    UNC_PCIEXBAR,
+    UNC_GTTMMADR,
+    UNC_GDXCBAR,
+    UNC_CHAPADR,
+    UNC_SOCPCI,
+    UNC_NPKBAR
+} UNC_SA_BAR_TYPE;
+
+typedef enum {
+    UNC_OP_READ =  1,
+    UNC_OP_WRITE,
+    UNC_OP_RMW
+} UNC_SA_OPERATION;
+
+
+typedef enum {
+    STATIC_COUNTER = 1,
+    FREERUN_COUNTER,
+    PROG_FREERUN_COUNTER
+} COUNTER_TYPES;
+
+typedef enum {
+    PACKAGE_EVENT = 1,
+    MODULE_EVENT,
+    THREAD_EVENT,
+    SYSTEM_EVENT
+} EVENT_SCOPE_TYPES;
+
+typedef enum {
+    DEVICE_CORE          = 1,         // CORE DEVICE
+    DEVICE_UNC_CBO       = 10,        // UNCORE DEVICES START
+    DEVICE_UNC_HA,
+    DEVICE_UNC_IMC,
+    DEVICE_UNC_IRP,
+    DEVICE_UNC_NCU,
+    DEVICE_UNC_PCU,
+    DEVICE_UNC_POWER,
+    DEVICE_UNC_QPI,
+    DEVICE_UNC_R2PCIE,
+    DEVICE_UNC_R3QPI,
+    DEVICE_UNC_SBOX,
+    DEVICE_UNC_GT,
+    DEVICE_UNC_UBOX,
+    DEVICE_UNC_WBOX,
+    DEVICE_UNC_COREI7,
+    DEVICE_UNC_CHA,
+    DEVICE_UNC_EDC,
+    DEVICE_UNC_IIO,
+    DEVICE_UNC_M2M,
+    DEVICE_UNC_EDRAM,
+    DEVICE_UNC_FPGA_CACHE,
+    DEVICE_UNC_FPGA_FAB,
+    DEVICE_UNC_FPGA_THERMAL,
+    DEVICE_UNC_FPGA_POWER,
+    DEVICE_UNC_FPGA_GB,
+    DEVICE_UNC_KNC_SBOX  = 100,       // KNC UNCORE DEVICES START
+    DEVICE_UNC_KNC_GBOX_FBOX,
+    DEVICE_UNC_KNC_GBOX_MBOX,
+    DEVICE_UNC_KNC_SMC,
+    DEVICE_UNC_TELEMETRY  = 150,      // TELEMETRY DEVICE
+    DEVICE_UNC_CHAP       = 200,      // CHIPSET DEVICES START
+    DEVICE_UNC_GMCH,
+    DEVICE_UNC_GFX,
+    DEVICE_UNC_SOCPERF    = 300,      // UNCORE VISA DEVICES START
+    DEVICE_UNC_HFI_RXE    = 400,      // STL HFI
+    DEVICE_UNC_HFI_TXE,
+} DEVICE_TYPES;
+
+typedef enum {
+    LBR_ENTRY_TOS = 0,
+    LBR_ENTRY_FROM_IP,
+    LBR_ENTRY_TO_IP,
+    LBR_ENTRY_INFO
+} LBR_ENTRY_TYPE;
+
+// ***************************************************************************
+
+/*!\struct PCI_ID_NODE
+ * \var    offset      -  PCI offset to start the read/write
+ * \var    data size      Number of bytes to operate on
+ */
+
+typedef struct PCI_ID_NODE_S    PCI_ID_NODE;
+typedef        PCI_ID_NODE      *PCI_ID;
+
+struct PCI_ID_NODE_S {
+    U32        offset;
+    U32        data_size;
+};
+#define PCI_ID_offset(x)      (x)->offset
+#define PCI_ID_data_size(x)   (x)->data_size
+
+// ***************************************************************************
+
+/*!\struct EVENT_REG_ID_NODE
+ * \var    reg_id      -  MSR index to r/w
+ * \var    pci_id     PCI based register and its details to operate on
+ */
+typedef union EVENT_REG_ID_NODE_S EVENT_REG_ID_NODE;
+typedef       EVENT_REG_ID_NODE  *EVENT_REG_ID;
+
+ union EVENT_REG_ID_NODE_S {
+   U32            reg_id;
+   U32            reserved2;
+   PCI_ID_NODE    pci_id;
+} ;
+
+
+// ***************************************************************************
+
+typedef enum {
+    PMU_REG_RW_READ = 1,
+    PMU_REG_RW_WRITE,
+    PMU_REG_RW_READ_WRITE,
+} PMU_REG_RW_TYPES;
+
+typedef enum {
+    PMU_REG_PROG_MSR = 1,
+    PMU_REG_PROG_PCI,
+    PMU_REG_PROG_MMIO,
+} PMU_REG_PROG_TYPES;
+
+typedef enum {
+    PMU_REG_GLOBAL_CTRL = 1,
+    PMU_REG_UNIT_CTRL,
+    PMU_REG_UNIT_STATUS,
+    PMU_REG_DATA,
+    PMU_REG_EVENT_SELECT,
+    PMU_REG_FILTER,
+    PMU_REG_FIXED_CTRL,
+} PMU_REG_TYPES;
+
+/*!\struct EVENT_REG_NODE
+ * \var    reg_type             - register type
+ * \var    event_id_index       - event ID index
+ * \var    event_id_index_local - event ID index within the device
+ * \var    event_reg_id         - register ID/pci register details
+ * \var    desc_id              - desc ID
+ * \var    flags                - flags
+ * \var    reg_value            - register value
+ * \var    max_bits             - max bits
+ * \var    scheduled            - boolean to specify if this event node has been scheduled already
+ * \var    bus_no               - PCI bus number
+ * \var    dev_no               - PCI device number
+ * \var    func_no              - PCI function number
+ * \var    counter_type         - Event counter type - static/freerun
+ * \var    event_scope          - Event scope - package/module/thread
+ * \var    reg_prog_type        - Register Programming type
+ * \var    reg_rw_type          - Register Read/Write type
+ * \var    reg_order            - Register order in the programming sequence
+ * \var
+ * \brief  Data structure to describe the event registers
+ *
+ */
+
+typedef struct EVENT_REG_NODE_S  EVENT_REG_NODE;
+typedef        EVENT_REG_NODE   *EVENT_REG;
+
+struct EVENT_REG_NODE_S {
+    U8                   reg_type;
+    U8                   event_id_index;       // U8 must be changed if MAX_EVENTS > 256
+    U8                   event_id_index_local; // U8 must be changed if MAX_EVENTS > 256
+    U8                   emon_event_id_index_local;
+    U8                   group_index;
+    U8                   reserved0;
+    U16                  counter_event_offset;
+    EVENT_REG_ID_NODE    event_reg_id;
+    U16                  desc_id;
+    U16                  flags;
+    U32                  reserved1;
+    U64                  reg_value;
+    U64                  max_bits;
+    U8                   scheduled;
+    // PCI config-specific fields
+    S8                   secondary_pci_offset_shift;
+    U16                  secondary_pci_offset_offset; // offset of the offset...
+    U32                  bus_no;
+    U32                  dev_no;
+    U32                  func_no;
+    U32                  counter_type;
+    U32                  event_scope;
+    U8                   reg_prog_type;
+    U8                   reg_rw_type;
+    U8                   reg_order;
+    U8                   bit_position;
+    U32                  reserved5;
+    U64                  secondary_pci_offset_mask;
+    U64                  reserved7;
+    U64                  reserved8;
+    U64                  reserved9;
+};
+
+//
+// Accessor macros for EVENT_REG node
+// Note: the flags field is not directly addressible to prevent hackery
+//
+#define EVENT_REG_reg_type(x,i)                    (x)[(i)].reg_type
+#define EVENT_REG_event_id_index(x,i)              (x)[(i)].event_id_index
+#define EVENT_REG_event_id_index_local(x,i)        (x)[(i)].event_id_index_local
+#define EVENT_REG_emon_event_id_index_local(x,i)   (x)[(i)].emon_event_id_index_local
+#define EVENT_REG_counter_event_offset(x,i)        (x)[(i)].counter_event_offset
+#define EVENT_REG_group_index(x,i)                 (x)[(i)].group_index
+#define EVENT_REG_counter_event_offset(x,i)        (x)[(i)].counter_event_offset
+#define EVENT_REG_reg_id(x,i)                      (x)[(i)].event_reg_id.reg_id
+#define EVENT_REG_pci_id(x,i)                      (x)[(i)].event_reg_id.pci_id
+#define EVENT_REG_pci_id_offset(x,i)               (x)[(i)].event_reg_id.pci_id.offset
+#define EVENT_REG_pci_id_size(x,i)                 (x)[(i)].event_reg_id.pci_id.data_size
+#define EVENT_REG_desc_id(x,i)                     (x)[(i)].desc_id
+#define EVENT_REG_flags(x,i)                       (x)[(i)].flags
+#define EVENT_REG_reg_value(x,i)                   (x)[(i)].reg_value
+#define EVENT_REG_max_bits(x,i)                    (x)[(i)].max_bits
+#define EVENT_REG_scheduled(x,i)                   (x)[(i)].scheduled
+// PCI config-specific fields
+#define EVENT_REG_bus_no(x,i)                      (x)[(i)].bus_no
+#define EVENT_REG_dev_no(x,i)                      (x)[(i)].dev_no
+#define EVENT_REG_func_no(x,i)                     (x)[(i)].func_no
+#define EVENT_REG_secondary_pci_offset_shift(x,i)  (x)[(i)].secondary_pci_offset_shift
+#define EVENT_REG_secondary_pci_offset_offset(x,i) (x)[(i)].secondary_pci_offset_offset
+#define EVENT_REG_secondary_pci_offset_mask(x,i)   (x)[(i)].secondary_pci_offset_mask
+
+#define EVENT_REG_counter_type(x,i)                (x)[(i)].counter_type
+#define EVENT_REG_event_scope(x,i)                 (x)[(i)].event_scope
+#define EVENT_REG_reg_prog_type(x,i)               (x)[(i)].reg_prog_type
+#define EVENT_REG_reg_rw_type(x,i)                 (x)[(i)].reg_rw_type
+#define EVENT_REG_reg_order(x,i)                   (x)[(i)].reg_order
+#define EVENT_REG_bit_position(x,i)                (x)[(i)].bit_position
+
+//
+// Config bits
+//
+#define EVENT_REG_precise_bit               0x00000001
+#define EVENT_REG_global_bit                0x00000002
+#define EVENT_REG_uncore_bit                0x00000004
+#define EVENT_REG_uncore_q_rst_bit          0x00000008
+#define EVENT_REG_latency_bit               0x00000010
+#define EVENT_REG_is_gp_reg_bit             0x00000020
+#define EVENT_REG_clean_up_bit              0x00000040
+#define EVENT_REG_em_trigger_bit            0x00000080
+#define EVENT_REG_lbr_value_bit             0x00000100
+#define EVENT_REG_fixed_reg_bit             0x00000200
+#define EVENT_REG_multi_pkg_evt_bit         0x00001000
+#define EVENT_REG_branch_evt_bit            0x00002000
+
+//
+// Accessor macros for config bits
+//
+#define EVENT_REG_precise_get(x,i)          ((x)[(i)].flags &   EVENT_REG_precise_bit)
+#define EVENT_REG_precise_set(x,i)          ((x)[(i)].flags |=  EVENT_REG_precise_bit)
+#define EVENT_REG_precise_clear(x,i)        ((x)[(i)].flags &= ~EVENT_REG_precise_bit)
+
+#define EVENT_REG_global_get(x,i)           ((x)[(i)].flags &   EVENT_REG_global_bit)
+#define EVENT_REG_global_set(x,i)           ((x)[(i)].flags |=  EVENT_REG_global_bit)
+#define EVENT_REG_global_clear(x,i)         ((x)[(i)].flags &= ~EVENT_REG_global_bit)
+
+#define EVENT_REG_uncore_get(x,i)           ((x)[(i)].flags &   EVENT_REG_uncore_bit)
+#define EVENT_REG_uncore_set(x,i)           ((x)[(i)].flags |=  EVENT_REG_uncore_bit)
+#define EVENT_REG_uncore_clear(x,i)         ((x)[(i)].flags &= ~EVENT_REG_uncore_bit)
+
+#define EVENT_REG_uncore_q_rst_get(x,i)     ((x)[(i)].flags &   EVENT_REG_uncore_q_rst_bit)
+#define EVENT_REG_uncore_q_rst_set(x,i)     ((x)[(i)].flags |=  EVENT_REG_uncore_q_rst_bit)
+#define EVENT_REG_uncore_q_rst_clear(x,i)   ((x)[(i)].flags &= ~EVENT_REG_uncore_q_rst_bit)
+
+#define EVENT_REG_latency_get(x,i)          ((x)[(i)].flags &   EVENT_REG_latency_bit)
+#define EVENT_REG_latency_set(x,i)          ((x)[(i)].flags |=  EVENT_REG_latency_bit)
+#define EVENT_REG_latency_clear(x,i)        ((x)[(i)].flags &= ~EVENT_REG_latency_bit)
+
+#define EVENT_REG_is_gp_reg_get(x,i)        ((x)[(i)].flags &   EVENT_REG_is_gp_reg_bit)
+#define EVENT_REG_is_gp_reg_set(x,i)        ((x)[(i)].flags |=  EVENT_REG_is_gp_reg_bit)
+#define EVENT_REG_is_gp_reg_clear(x,i)      ((x)[(i)].flags &= ~EVENT_REG_is_gp_reg_bit)
+
+#define EVENT_REG_lbr_value_get(x,i)        ((x)[(i)].flags &   EVENT_REG_lbr_value_bit)
+#define EVENT_REG_lbr_value_set(x,i)        ((x)[(i)].flags |=  EVENT_REG_lbr_value_bit)
+#define EVENT_REG_lbr_value_clear(x,i)      ((x)[(i)].flags &= ~EVENT_REG_lbr_value_bit)
+
+#define EVENT_REG_fixed_reg_get(x,i)        ((x)[(i)].flags &   EVENT_REG_fixed_reg_bit)
+#define EVENT_REG_fixed_reg_set(x,i)        ((x)[(i)].flags |=  EVENT_REG_fixed_reg_bit)
+#define EVENT_REG_fixed_reg_clear(x,i)      ((x)[(i)].flags &= ~EVENT_REG_fixed_reg_bit)
+
+#define EVENT_REG_multi_pkg_evt_bit_get(x,i)   ((x)[(i)].flags &   EVENT_REG_multi_pkg_evt_bit)
+#define EVENT_REG_multi_pkg_evt_bit_set(x,i)   ((x)[(i)].flags |=  EVENT_REG_multi_pkg_evt_bit)
+#define EVENT_REG_multi_pkg_evt_bit_clear(x,i) ((x)[(i)].flags &= ~EVENT_REG_multi_pkg_evt_bit)
+
+#define EVENT_REG_clean_up_get(x,i)         ((x)[(i)].flags &   EVENT_REG_clean_up_bit)
+#define EVENT_REG_clean_up_set(x,i)         ((x)[(i)].flags |=  EVENT_REG_clean_up_bit)
+#define EVENT_REG_clean_up_clear(x,i)       ((x)[(i)].flags &= ~EVENT_REG_clean_up_bit)
+
+#define EVENT_REG_em_trigger_get(x,i)       ((x)[(i)].flags &   EVENT_REG_em_trigger_bit)
+#define EVENT_REG_em_trigger_set(x,i)       ((x)[(i)].flags |=  EVENT_REG_em_trigger_bit)
+#define EVENT_REG_em_trigger_clear(x,i)     ((x)[(i)].flags &= ~EVENT_REG_em_trigger_bit)
+
+#define EVENT_REG_branch_evt_get(x,i)       ((x)[(i)].flags &   EVENT_REG_branch_evt_bit)
+#define EVENT_REG_branch_evt_set(x,i)       ((x)[(i)].flags |=  EVENT_REG_branch_evt_bit)
+#define EVENT_REG_branch_evt_clear(x,i)     ((x)[(i)].flags &= ~EVENT_REG_branch_evt_bit)
+
+// ***************************************************************************
+
+/*!\struct DRV_PCI_DEVICE_ENTRY_NODE_S
+ * \var    bus_no          -  PCI bus no to read
+ * \var    dev_no          -  PCI device no to read
+ * \var    func_no            PCI device no to read
+ * \var    bar_offset         BASE Address Register offset of the PCI based PMU
+ * \var    bit_offset         Bit offset of the same
+ * \var    size               size of read/write
+ * \var    bar_address        the actual BAR present
+ * \var    enable_offset      Offset info to enable/disable
+ * \var    enabled            Status of enable/disable
+ * \brief  Data structure to describe the PCI Device
+ *
+ */
+
+typedef struct DRV_PCI_DEVICE_ENTRY_NODE_S  DRV_PCI_DEVICE_ENTRY_NODE;
+typedef        DRV_PCI_DEVICE_ENTRY_NODE   *DRV_PCI_DEVICE_ENTRY;
+
+struct DRV_PCI_DEVICE_ENTRY_NODE_S {
+    U32        bus_no;
+    U32        dev_no;
+    U32        func_no;
+    U32        bar_offset;
+    U64        bar_mask;
+    U32        bit_offset;
+    U32        size;
+    U64        bar_address;
+    U32        enable_offset;
+    U32        enabled;
+    U32        base_offset_for_mmio;
+    U32        operation;
+    U32        bar_name;
+    U32        prog_type;
+    U32        config_type;
+    S8         bar_shift;     // positive shifts right, negative shifts left
+    U8         reserved0;
+    U16        reserved1;
+    U64        value;
+    U64        mask;
+    U64        virtual_address;
+    U32        port_id;
+    U32        op_code;
+    U32        device_id;
+    U16        bar_num;
+    U16        feature_id;
+    U64        reserved2;
+    U64        reserved3;
+    U64        reserved4;
+};
+
+//
+// Accessor macros for DRV_PCI_DEVICE_NODE node
+//
+#define DRV_PCI_DEVICE_ENTRY_bus_no(x)                (x)->bus_no
+#define DRV_PCI_DEVICE_ENTRY_dev_no(x)                (x)->dev_no
+#define DRV_PCI_DEVICE_ENTRY_func_no(x)               (x)->func_no
+#define DRV_PCI_DEVICE_ENTRY_bar_offset(x)            (x)->bar_offset
+#define DRV_PCI_DEVICE_ENTRY_bar_mask(x)              (x)->bar_mask
+#define DRV_PCI_DEVICE_ENTRY_bit_offset(x)            (x)->bit_offset
+#define DRV_PCI_DEVICE_ENTRY_size(x)                  (x)->size
+#define DRV_PCI_DEVICE_ENTRY_bar_address(x)           (x)->bar_address
+#define DRV_PCI_DEVICE_ENTRY_enable_offset(x)         (x)->enable_offset
+#define DRV_PCI_DEVICE_ENTRY_enable(x)                (x)->enabled
+#define DRV_PCI_DEVICE_ENTRY_base_offset_for_mmio(x)  (x)->base_offset_for_mmio
+#define DRV_PCI_DEVICE_ENTRY_operation(x)             (x)->operation
+#define DRV_PCI_DEVICE_ENTRY_bar_name(x)              (x)->bar_name
+#define DRV_PCI_DEVICE_ENTRY_prog_type(x)             (x)->prog_type
+#define DRV_PCI_DEVICE_ENTRY_config_type(x)           (x)->config_type
+#define DRV_PCI_DEVICE_ENTRY_bar_shift(x)             (x)->bar_shift
+#define DRV_PCI_DEVICE_ENTRY_value(x)                 (x)->value
+#define DRV_PCI_DEVICE_ENTRY_mask(x)                  (x)->mask
+#define DRV_PCI_DEVICE_ENTRY_virtual_address(x)       (x)->virtual_address
+#define DRV_PCI_DEVICE_ENTRY_port_id(x)               (x)->port_id
+#define DRV_PCI_DEVICE_ENTRY_op_code(x)               (x)->op_code
+#define DRV_PCI_DEVICE_ENTRY_device_id(x)             (x)->device_id
+#define DRV_PCI_DEVICE_ENTRY_bar_num(x)               (x)->bar_num
+#define DRV_PCI_DEVICE_ENTRY_feature_id(x)            (x)->feature_id
+
+// ***************************************************************************
+typedef enum {
+    PMU_OPERATION_INITIALIZE = 0,
+    PMU_OPERATION_WRITE,
+    PMU_OPERATION_ENABLE,
+    PMU_OPERATION_DISABLE,
+    PMU_OPERATION_READ,
+    PMU_OPERATION_CLEANUP,
+    PMU_OPERATION_READ_LBRS,
+} PMU_OPERATION_TYPES;
+#define MAX_OPERATION_TYPES   16
+
+/*!\struct PMU_OPERATIONS_NODE
+ * \var    operation_type -    Type of operation from enumeration PMU_OPERATION_TYPES
+ * \var    register_start -    Start index of the registers for a specific operation
+ * \var    register_len   -    Number of registers for a specific operation
+ *
+ * \brief
+ * Structure for defining start and end indices in the ECB entries array for
+ * each type of operation performed in the driver
+ * initialize, write, read, enable, disable, etc.
+ */
+typedef struct PMU_OPERATIONS_NODE_S  PMU_OPERATIONS_NODE;
+typedef        PMU_OPERATIONS_NODE   *PMU_OPERATIONS;
+struct PMU_OPERATIONS_NODE_S {
+    U32 operation_type;
+    U32 register_start;
+    U32 register_len;
+    U32 reserved1;
+    U32 reserved2;
+    U32 reserved3;
+};
+#define PMU_OPERATIONS_operation_type(x)             (x)->operation_type
+#define PMU_OPERATIONS_register_start(x)             (x)->register_start
+#define PMU_OPERATIONS_register_len(x)               (x)->register_len
+#define PMU_OPER_operation_type(x,i)                 (x)[(i)].operation_type
+#define PMU_OPER_register_start(x,i)                 (x)[(i)].register_start
+#define PMU_OPER_register_len(x,i)                   (x)[(i)].register_len
+
+/*!\struct ECB_NODE_S
+ * \var    num_entries -       Total number of entries in "entries".
+ * \var    group_id    -       Group ID.
+ * \var    num_events  -       Number of events in this group.
+ * \var    cccr_start  -       Starting index of counter configuration control registers in "entries".
+ * \var    cccr_pop    -       Number of counter configuration control registers in "entries".
+ * \var    escr_start  -       Starting index of event selection control registers in "entries".
+ * \var    escr_pop    -       Number of event selection control registers in "entries".
+ * \var    data_start  -       Starting index of data registers in "entries".
+ * \var    data_pop    -       Number of data registers in "entries".
+ * \var    pcidev_entry_node   PCI device details for one device
+ * \var    entries     - .     All the register nodes required for programming
+ *
+ * \brief
+ */
+
+typedef struct ECB_NODE_S  ECB_NODE;
+typedef        ECB_NODE   *ECB;
+
+struct ECB_NODE_S {
+    U16                          version;
+    U16                          reserved1;
+    U32                          reserved2;
+    U32                          num_entries;
+    U32                          group_id;
+    U32                          num_events;
+    U32                          cccr_start;
+    U32                          cccr_pop;
+    U32                          escr_start;
+    U32                          escr_pop;
+    U32                          data_start;
+    U32                          data_pop;
+    U16                          flags;
+    U8                           pmu_timer_interval;
+    U8                           reserved0;
+    U32                          size_of_allocation;
+    U32                          group_offset;
+    DRV_PCI_DEVICE_ENTRY_NODE    pcidev_entry_node;
+    U32                          num_pci_devices;
+    U32                          pcidev_list_offset;
+    DRV_PCI_DEVICE_ENTRY         pcidev_entry_list;
+#if defined(DRV_IA32)
+    U32                          reserved3;
+#endif
+    U32                          device_type;
+    U32                          dev_node;
+    PMU_OPERATIONS_NODE          operations[MAX_OPERATION_TYPES];
+    U32                          descriptor_id;
+    U32                          reserved4;
+    U32                          metric_start;
+    U32                          metric_pop;
+    U64                          reserved6;
+    EVENT_REG_NODE               entries[];
+};
+
+//
+// Accessor macros for ECB node
+//
+#define ECB_version(x)                    (x)->version
+#define ECB_num_entries(x)                (x)->num_entries
+#define ECB_group_id(x)                   (x)->group_id
+#define ECB_num_events(x)                 (x)->num_events
+#define ECB_cccr_start(x)                 (x)->cccr_start
+#define ECB_cccr_pop(x)                   (x)->cccr_pop
+#define ECB_escr_start(x)                 (x)->escr_start
+#define ECB_escr_pop(x)                   (x)->escr_pop
+#define ECB_data_start(x)                 (x)->data_start
+#define ECB_data_pop(x)                   (x)->data_pop
+#define ECB_metric_start(x)               (x)->metric_start
+#define ECB_metric_pop(x)                 (x)->metric_pop
+#define ECB_pcidev_entry_node(x)          (x)->pcidev_entry_node
+#define ECB_num_pci_devices(x)            (x)->num_pci_devices
+#define ECB_pcidev_list_offset(x)         (x)->pcidev_list_offset
+#define ECB_pcidev_entry_list(x)          (x)->pcidev_entry_list
+#define ECB_flags(x)                      (x)->flags
+#define ECB_pmu_timer_interval(x)         (x)->pmu_timer_interval
+#define ECB_size_of_allocation(x)         (x)->size_of_allocation
+#define ECB_group_offset(x)               (x)->group_offset
+#define ECB_device_type(x)                (x)->device_type
+#define ECB_dev_node(x)                   (x)->dev_node
+#define ECB_operations(x)                 (x)->operations
+#define ECB_descriptor_id(x)              (x)->descriptor_id
+#define ECB_entries(x)                    (x)->entries
+
+// for flag bit field
+#define ECB_direct2core_bit                0x0001
+#define ECB_bl_bypass_bit                  0x0002
+#define ECB_pci_id_offset_bit              0x0003
+#define ECB_pcu_ccst_debug                 0x0004
+
+#define ECB_VERSION                        1
+
+#define ECB_CONSTRUCT(x,num_entries,group_id,cccr_start,escr_start,data_start, size_of_allocation)    \
+                                           ECB_num_entries((x)) = (num_entries);  \
+                                           ECB_group_id((x)) = (group_id);        \
+                                           ECB_cccr_start((x)) = (cccr_start);    \
+                                           ECB_cccr_pop((x)) = 0;                 \
+                                           ECB_escr_start((x)) = (escr_start);    \
+                                           ECB_escr_pop((x)) = 0;                 \
+                                           ECB_data_start((x)) = (data_start);    \
+                                           ECB_data_pop((x)) = 0;                 \
+                                           ECB_metric_start((x)) = 0;             \
+                                           ECB_metric_pop((x)) = 0;               \
+                                           ECB_num_pci_devices((x)) = 0;          \
+                                           ECB_version((x)) = ECB_VERSION;        \
+                                           ECB_size_of_allocation((x)) = (size_of_allocation);
+
+#define ECB_CONSTRUCT2(x, num_entries, group_id, size_of_allocation)    \
+                                           ECB_num_entries((x)) = (num_entries);  \
+                                           ECB_group_id((x)) = (group_id);        \
+                                           ECB_num_pci_devices((x)) = 0;          \
+                                           ECB_version((x)) = ECB_VERSION;        \
+                                           ECB_size_of_allocation((x)) = (size_of_allocation);
+
+#define ECB_CONSTRUCT1(x,num_entries,group_id,cccr_start,escr_start,data_start,num_pci_devices, size_of_allocation)    \
+                                           ECB_num_entries((x)) = (num_entries);  \
+                                           ECB_group_id((x)) = (group_id);        \
+                                           ECB_cccr_start((x)) = (cccr_start);    \
+                                           ECB_cccr_pop((x)) = 0;                 \
+                                           ECB_escr_start((x)) = (escr_start);    \
+                                           ECB_escr_pop((x)) = 0;                 \
+                                           ECB_data_start((x)) = (data_start);    \
+                                           ECB_data_pop((x)) = 0;                 \
+                                           ECB_metric_start((x)) = 0;             \
+                                           ECB_metric_pop((x)) = 0;               \
+                                           ECB_num_pci_devices((x)) = (num_pci_devices);  \
+                                           ECB_version((x)) = ECB_VERSION;        \
+                                           ECB_size_of_allocation((x)) = (size_of_allocation);
+
+//
+// Accessor macros for ECB node entries
+//
+#define ECB_entries_reg_type(x,i)                    EVENT_REG_reg_type((ECB_entries(x)),(i))
+#define ECB_entries_event_id_index(x,i)              EVENT_REG_event_id_index((ECB_entries(x)),(i))
+#define ECB_entries_event_id_index_local(x,i)        EVENT_REG_event_id_index_local((ECB_entries(x)),(i))
+#define ECB_entries_emon_event_id_index_local(x,i)   EVENT_REG_emon_event_id_index_local((ECB_entries(x)),(i))
+#define ECB_entries_counter_event_offset(x,i)        EVENT_REG_counter_event_offset((ECB_entries(x)),(i))
+#define ECB_entries_reg_id(x,i)                      EVENT_REG_reg_id((ECB_entries(x)),(i))
+#define ECB_entries_reg_prog_type(x,i)               EVENT_REG_reg_prog_type((ECB_entries(x)),(i))
+#define ECB_entries_pci_id(x,i)                      EVENT_REG_pci_id((ECB_entries(x)),(i))
+#define ECB_entries_pci_id_offset(x,i)               EVENT_REG_pci_id_offset((ECB_entries(x)),(i))
+#define ECB_entries_pci_id_data_size(x,i)            EVENT_REG_pci_id_size((ECB_entries(x)),(i))
+#define ECB_entries_desc_id(x,i)                     EVENT_REG_desc_id((ECB_entries(x)),i)
+#define ECB_entries_flags(x,i)                       EVENT_REG_flags((ECB_entries(x)),i)
+#define ECB_entries_reg_order(x,i)                   EVENT_REG_reg_order((ECB_entries(x)),i)
+#define ECB_entries_reg_value(x,i)                   EVENT_REG_reg_value((ECB_entries(x)),(i))
+#define ECB_entries_max_bits(x,i)                    EVENT_REG_max_bits((ECB_entries(x)),(i))
+#define ECB_entries_scheduled(x,i)                   EVENT_REG_scheduled((ECB_entries(x)),(i))
+#define ECB_entries_group_index(x,i)                 EVENT_REG_group_index((ECB_entries(x)),(i))
+#define ECB_entries_counter_event_offset(x,i)        EVENT_REG_counter_event_offset((ECB_entries(x)),(i))
+#define ECB_entries_bit_position(x,i)                EVENT_REG_bit_position((ECB_entries(x)),(i))
+// PCI config-specific fields
+#define ECB_entries_bus_no(x,i)                      EVENT_REG_bus_no((ECB_entries(x)),(i))
+#define ECB_entries_dev_no(x,i)                      EVENT_REG_dev_no((ECB_entries(x)),(i))
+#define ECB_entries_func_no(x,i)                     EVENT_REG_func_no((ECB_entries(x)),(i))
+#define ECB_entries_counter_type(x,i)                EVENT_REG_counter_type((ECB_entries(x)),(i))
+#define ECB_entries_event_scope(x,i)                 EVENT_REG_event_scope((ECB_entries(x)),(i))
+#define ECB_entries_precise_get(x,i)                 EVENT_REG_precise_get((ECB_entries(x)),(i))
+#define ECB_entries_global_get(x,i)                  EVENT_REG_global_get((ECB_entries(x)),(i))
+#define ECB_entries_uncore_get(x,i)                  EVENT_REG_uncore_get((ECB_entries(x)),(i))
+#define ECB_entries_uncore_q_rst_get(x,i)            EVENT_REG_uncore_q_rst_get((ECB_entries(x)),(i))
+#define ECB_entries_is_gp_reg_get(x,i)               EVENT_REG_is_gp_reg_get((ECB_entries(x)),(i))
+#define ECB_entries_lbr_value_get(x,i)               EVENT_REG_lbr_value_get((ECB_entries(x)),(i))
+#define ECB_entries_fixed_reg_get(x,i)               EVENT_REG_fixed_reg_get((ECB_entries(x)),(i))
+#define ECB_entries_is_multi_pkg_bit_set(x,i)        EVENT_REG_multi_pkg_evt_bit_get((ECB_entries(x)),(i))
+#define ECB_entries_clean_up_get(x,i)                EVENT_REG_clean_up_get((ECB_entries(x)),(i))
+#define ECB_entries_em_trigger_get(x,i)              EVENT_REG_em_trigger_get((ECB_entries(x)),(i))
+#define ECB_entries_branch_evt_get(x,i)              EVENT_REG_branch_evt_get((ECB_entries(x)),(i))
+#define ECB_entries_reg_rw_type(x,i)                 EVENT_REG_reg_rw_type((ECB_entries(x)),(i))
+#define ECB_entries_secondary_pci_offset_offset(x,i) EVENT_REG_secondary_pci_offset_offset((ECB_entries(x)),(i))
+#define ECB_entries_secondary_pci_offset_shift(x,i)  EVENT_REG_secondary_pci_offset_shift((ECB_entries(x)),(i))
+#define ECB_entries_secondary_pci_offset_mask(x,i)   EVENT_REG_secondary_pci_offset_mask((ECB_entries(x)),(i))
+#define ECB_operations_operation_type(x,i)           PMU_OPER_operation_type((ECB_operations(x)),(i))
+#define ECB_operations_register_start(x,i)           PMU_OPER_register_start((ECB_operations(x)),(i))
+#define ECB_operations_register_len(x,i)             PMU_OPER_register_len((ECB_operations(x)),(i))
+
+#define ECB_SET_OPERATIONS(x, operation_type, start, len)                                \
+                     ECB_operations_operation_type(x, operation_type) = operation_type;  \
+                     ECB_operations_register_start(x, operation_type) = start;           \
+                     ECB_operations_register_len(x, operation_type)   = len;             \
+
+// ***************************************************************************
+
+/*!\struct  LBR_ENTRY_NODE_S
+ * \var     etype       TOS = 0; FROM = 1; TO = 2
+ * \var     type_index
+ * \var     reg_id
+ */
+
+typedef struct LBR_ENTRY_NODE_S  LBR_ENTRY_NODE;
+typedef        LBR_ENTRY_NODE   *LBR_ENTRY;
+
+struct LBR_ENTRY_NODE_S {
+    U16    etype;
+    U16    type_index;
+    U32    reg_id;
+};
+
+//
+// Accessor macros for LBR entries
+//
+#define LBR_ENTRY_NODE_etype(lentry)          (lentry).etype
+#define LBR_ENTRY_NODE_type_index(lentry)     (lentry).type_index
+#define LBR_ENTRY_NODE_reg_id(lentry)         (lentry).reg_id
+
+// ***************************************************************************
+
+/*!\struct LBR_NODE_S
+ * \var    num_entries     -  The number of entries
+ * \var    entries         -  The entries in the list
+ *
+ * \brief  Data structure to describe the LBR registers that need to be read
+ *
+ */
+
+typedef struct LBR_NODE_S  LBR_NODE;
+typedef        LBR_NODE   *LBR;
+
+struct LBR_NODE_S {
+    U32               size;
+    U32               num_entries;
+    LBR_ENTRY_NODE    entries[];
+};
+
+//
+// Accessor macros for LBR node
+//
+#define LBR_size(lbr)                      (lbr)->size
+#define LBR_num_entries(lbr)               (lbr)->num_entries
+#define LBR_entries_etype(lbr,idx)         (lbr)->entries[idx].etype
+#define LBR_entries_type_index(lbr,idx)    (lbr)->entries[idx].type_index
+#define LBR_entries_reg_id(lbr,idx)        (lbr)->entries[idx].reg_id
+
+// ***************************************************************************
+
+/*!\struct  PWR_ENTRY_NODE_S
+ * \var     etype       none as yet
+ * \var     type_index
+ * \var     reg_id
+ */
+
+typedef struct PWR_ENTRY_NODE_S  PWR_ENTRY_NODE;
+typedef        PWR_ENTRY_NODE   *PWR_ENTRY;
+
+struct PWR_ENTRY_NODE_S {
+    U16    etype;
+    U16    type_index;
+    U32    reg_id;
+};
+
+//
+// Accessor macros for PWR entries
+//
+#define PWR_ENTRY_NODE_etype(lentry)          (lentry).etype
+#define PWR_ENTRY_NODE_type_index(lentry)     (lentry).type_index
+#define PWR_ENTRY_NODE_reg_id(lentry)         (lentry).reg_id
+
+// ***************************************************************************
+
+/*!\struct PWR_NODE_S
+ * \var    num_entries     -  The number of entries
+ * \var    entries         -  The entries in the list
+ *
+ * \brief  Data structure to describe the PWR registers that need to be read
+ *
+ */
+
+typedef struct PWR_NODE_S  PWR_NODE;
+typedef        PWR_NODE   *PWR;
+
+struct PWR_NODE_S {
+    U32               size;
+    U32               num_entries;
+    PWR_ENTRY_NODE    entries[];
+};
+
+//
+// Accessor macros for PWR node
+//
+#define PWR_size(lbr)                      (lbr)->size
+#define PWR_num_entries(lbr)               (lbr)->num_entries
+#define PWR_entries_etype(lbr,idx)         (lbr)->entries[idx].etype
+#define PWR_entries_type_index(lbr,idx)    (lbr)->entries[idx].type_index
+#define PWR_entries_reg_id(lbr,idx)        (lbr)->entries[idx].reg_id
+
+// ***************************************************************************
+
+/*!\struct  RO_ENTRY_NODE_S
+ * \var     type       - DEAR, IEAR, BTB.
+ */
+
+typedef struct RO_ENTRY_NODE_S  RO_ENTRY_NODE;
+typedef        RO_ENTRY_NODE   *RO_ENTRY;
+
+struct RO_ENTRY_NODE_S {
+    U32    reg_id;
+};
+
+//
+// Accessor macros for RO entries
+//
+#define RO_ENTRY_NODE_reg_id(lentry)       (lentry).reg_id
+
+// ***************************************************************************
+
+/*!\struct RO_NODE_S
+ * \var    size            - The total size including header and entries.
+ * \var    num_entries     - The number of entries.
+ * \var    entries         - The entries in the list.
+ *
+ * \brief  Data structure to describe the RO registers that need to be read.
+ *
+ */
+
+typedef struct RO_NODE_S  RO_NODE;
+typedef        RO_NODE   *RO;
+
+struct RO_NODE_S {
+    U32              size;
+    U32              num_entries;
+    RO_ENTRY_NODE    entries[];
+};
+
+//
+// Accessor macros for RO node
+//
+#define RO_size(ro)                      (ro)->size
+#define RO_num_entries(ro)               (ro)->num_entries
+#define RO_entries_reg_id(ro,idx)        (ro)->entries[idx].reg_id
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
+
diff --git a/drivers/misc/intel/soc_perf/include/lwpmudrv_ioctl.h b/drivers/misc/intel/soc_perf/include/lwpmudrv_ioctl.h
new file mode 100644
index 000000000000..e03a527f2cbc
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/include/lwpmudrv_ioctl.h
@@ -0,0 +1,302 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2007-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2007-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+#ifndef _LWPMUDRV_IOCTL_H_
+#define _LWPMUDRV_IOCTL_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+//SEP Driver Operation defines
+//
+#define DRV_OPERATION_START                          1
+#define DRV_OPERATION_STOP                           2
+#define DRV_OPERATION_INIT_PMU                       3
+#define DRV_OPERATION_GET_NORMALIZED_TSC             4
+#define DRV_OPERATION_TSC_SKEW_INFO                  5
+#define DRV_OPERATION_PAUSE                          6
+#define DRV_OPERATION_RESUME                         7
+#define DRV_OPERATION_TERMINATE                      8
+#define DRV_OPERATION_RESERVE                        9
+#define DRV_OPERATION_VERSION                        10
+#define DRV_OPERATION_SWITCH_GROUP                   11
+#define DRV_OPERATION_GET_DRIVER_STATE               12
+#define DRV_OPERATION_INIT_UNCORE                    13
+#define DRV_OPERATION_EM_GROUPS_UNCORE               14
+#define DRV_OPERATION_EM_CONFIG_NEXT_UNCORE          15
+#define DRV_OPERATION_READ_UNCORE_DATA               16
+#define DRV_OPERATION_STOP_MEM                       17
+#define DRV_OPERATION_CREATE_MEM                     18
+#define DRV_OPERATION_READ_MEM                       19
+#define DRV_OPERATION_CHECK_STATUS                   20
+#define DRV_OPERATION_TIMER_TRIGGER_READ             21
+
+// IOCTL_SETUP
+//
+
+#if defined(DRV_OS_WINDOWS)
+
+//
+// NtDeviceIoControlFile IoControlCode values for this device.
+//
+// Warning:  Remember that the low two bits of the code specify how the
+//           buffers are passed to the driver!
+//
+// 16 bit device type. 12 bit function codes
+#define LWPMUDRV_IOCTL_DEVICE_TYPE  0xA000   // values 0-32768 reserved for Microsoft
+#define LWPMUDRV_IOCTL_FUNCTION     0x0A00   // values 0-2047  reserved for Microsoft
+
+//
+// Basic CTL CODE macro to reduce typographical errors
+// Use for FILE_READ_ACCESS
+//
+#define LWPMUDRV_CTL_READ_CODE(x)    CTL_CODE(LWPMUDRV_IOCTL_DEVICE_TYPE,  \
+                                              LWPMUDRV_IOCTL_FUNCTION+(x), \
+                                              METHOD_BUFFERED,             \
+                                              FILE_READ_ACCESS)
+
+#define LWPMUDRV_IOCTL_START                        LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_START)
+#define LWPMUDRV_IOCTL_STOP                         LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_STOP)
+#define LWPMUDRV_IOCTL_INIT_PMU                     LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_INIT_PMU)
+#define LWPMUDRV_IOCTL_GET_NORMALIZED_TSC           LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_GET_NORMALIZED_TSC)
+#define LWPMUDRV_IOCTL_TSC_SKEW_INFO                LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_TSC_SKEW_INFO)
+#define LWPMUDRV_IOCTL_PAUSE                        LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_PAUSE)
+#define LWPMUDRV_IOCTL_RESUME                       LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_RESUME)
+#define LWPMUDRV_IOCTL_TERMINATE                    LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_TERMINATE)
+#define LWPMUDRV_IOCTL_RESERVE                      LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_RESERVE)
+#define LWPMUDRV_IOCTL_VERSION                      LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_VERSION)
+#define LWPMUDRV_IOCTL_SWITCH_GROUP                 LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_SWITCH_GROUP)
+#define LWPMUDRV_IOCTL_GET_DRIVER_STATE             LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_GET_DRIVER_STATE)
+#define LWPMUDRV_IOCTL_INIT_UNCORE                  LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_INIT_UNCORE)
+#define LWPMUDRV_IOCTL_EM_GROUPS_UNCORE             LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_EM_GROUPS_UNCORE)
+#define LWPMUDRV_IOCTL_EM_CONFIG_NEXT_UNCORE        LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_EM_CONFIG_NEXT_UNCORE)
+#define LWPMUDRV_IOCTL_READ_UNCORE_DATA             LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_READ_UNCORE_DATA)
+#define LWPMUDRV_IOCTL_STOP_MEM                     LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_STOP_MEM)
+#define LWPMUDRV_IOCTL_CREATE_MEM                   LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_CREATE_MEM)
+#define LWPMUDRV_IOCTL_READ_MEM                     LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_READ_MEM)
+#define LWPMUDRV_IOCTL_CHECK_STATUS                 LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_CHECK_STATUS)
+#define LWPMUDRV_IOCTL_TIMER_TRIGGER_READ           LWPMUDRV_CTL_READ_CODE(DRV_OPERATION_TIMER_TRIGGER_READ)
+
+#elif defined(DRV_OS_LINUX) || defined(DRV_OS_SOLARIS) || defined (DRV_OS_ANDROID)
+// IOCTL_ARGS
+typedef struct IOCTL_ARGS_NODE_S  IOCTL_ARGS_NODE;
+typedef        IOCTL_ARGS_NODE   *IOCTL_ARGS;
+struct IOCTL_ARGS_NODE_S {
+    U64    r_len;
+    U64    w_len;
+    char  *r_buf;
+    char  *w_buf;
+};
+
+// COMPAT IOCTL_ARGS
+#if defined (CONFIG_COMPAT) && defined(DRV_EM64T)
+typedef struct IOCTL_COMPAT_ARGS_NODE_S  IOCTL_COMPAT_ARGS_NODE;
+typedef        IOCTL_COMPAT_ARGS_NODE   *IOCTL_COMPAT_ARGS;
+struct IOCTL_COMPAT_ARGS_NODE_S {
+    U64            r_len;
+    U64            w_len;
+    compat_uptr_t  r_buf;
+    compat_uptr_t  w_buf;
+};
+#endif
+
+#define LWPMU_IOC_MAGIC   99
+
+// IOCTL_SETUP
+//
+#define LWPMUDRV_IOCTL_START                  _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_START)
+#define LWPMUDRV_IOCTL_STOP                   _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_STOP)
+#define LWPMUDRV_IOCTL_INIT_PMU               _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_INIT_PMU, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_GET_NORMALIZED_TSC     _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_GET_NORMALIZED_TSC, int)
+#define LWPMUDRV_IOCTL_TSC_SKEW_INFO          _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_TSC_SKEW_INFO, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_PAUSE                  _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_PAUSE)
+#define LWPMUDRV_IOCTL_RESUME                 _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_RESUME)
+#define LWPMUDRV_IOCTL_TERMINATE              _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_TERMINATE)
+#define LWPMUDRV_IOCTL_RESERVE                _IOR(LWPMU_IOC_MAGIC, DRV_OPERATION_RESERVE, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_VERSION                _IOR(LWPMU_IOC_MAGIC, DRV_OPERATION_VERSION, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_SWITCH_GROUP           _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_SWITCH_GROUP)
+#define LWPMUDRV_IOCTL_GET_DRIVER_STATE       _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_GET_DRIVER_STATE, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_INIT_UNCORE            _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_INIT_UNCORE, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_EM_GROUPS_UNCORE       _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_EM_GROUPS_UNCORE, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_EM_CONFIG_NEXT_UNCORE  _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_EM_CONFIG_NEXT_UNCORE, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_READ_UNCORE_DATA       _IOR(LWPMU_IOC_MAGIC, DRV_OPERATION_READ_UNCORE_DATA, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_STOP_MEM               _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_STOP_MEM)
+#define LWPMUDRV_IOCTL_CREATE_MEM             _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_CREATE_MEM, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_READ_MEM               _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_READ_MEM, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_CHECK_STATUS           _IOR(LWPMU_IOC_MAGIC, DRV_OPERATION_CHECK_STATUS, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_TIMER_TRIGGER_READ     _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_TIMER_TRIGGER_READ)
+
+#elif defined(DRV_OS_FREEBSD)
+
+// IOCTL_ARGS
+typedef struct IOCTL_ARGS_NODE_S  IOCTL_ARGS_NODE;
+typedef        IOCTL_ARGS_NODE   *IOCTL_ARGS;
+struct IOCTL_ARGS_NODE_S {
+    U64    r_len;
+    char  *r_buf;
+    U64    w_len;
+    char  *w_buf;
+};
+
+// IOCTL_SETUP
+//
+#define LWPMU_IOC_MAGIC   99
+
+/* FreeBSD is very strict about IOR/IOW/IOWR specifications on IOCTLs.
+ * Since these IOCTLs all pass down the real read/write buffer lengths
+ *  and addresses inside of an IOCTL_ARGS_NODE data structure, we
+ *  need to specify all of these as _IOW so that the kernel will
+ *  view it as userspace passing the data to the driver, rather than
+ *  the reverse.  There are also some cases where Linux is passing
+ *  a smaller type than IOCTL_ARGS_NODE, even though its really
+ *  passing an IOCTL_ARGS_NODE.  These needed to be fixed for FreeBSD.
+ */
+#define LWPMUDRV_IOCTL_START                  _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_START)
+#define LWPMUDRV_IOCTL_STOP                   _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_STOP)
+#define LWPMUDRV_IOCTL_INIT_PMU               _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_INIT_PMU)
+#define LWPMUDRV_IOCTL_GET_NORMALIZED_TSC     _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_GET_NORMALIZED_TSC, IOCTL_ARGS_NODE)
+#define LWPMUDRV_IOCTL_TSC_SKEW_INFO          _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_TSC_SKEW_INFO, IOCTL_ARGS_NODE)
+#define LWPMUDRV_IOCTL_PAUSE                  _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_PAUSE)
+#define LWPMUDRV_IOCTL_RESUME                 _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_RESUME)
+#define LWPMUDRV_IOCTL_TERMINATE              _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_TERMINATE)
+#define LWPMUDRV_IOCTL_RESERVE                _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_RESERVE, IOCTL_ARGS_NODE)
+#define LWPMUDRV_IOCTL_VERSION                _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_VERSION, IOCTL_ARGS_NODE)
+#define LWPMUDRV_IOCTL_SWITCH_GROUP           _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_SWITCH_GROUP)
+#define LWPMUDRV_IOCTL_GET_DRIVER_STATE       _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_GET_DRIVER_STATE, IOCTL_ARGS_NODE)
+#define LWPMUDRV_IOCTL_INIT_UNCORE            _IOW (LWPMU_IOC_MAGIC, DRV_OPERATION_INIT_UNCORE, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_EM_GROUPS_UNCORE       _IOW (LWPMU_IOC_MAGIC, DRV_OPERATION_EM_GROUPS_UNCORE, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_EM_CONFIG_NEXT_UNCORE  _IOW (LWPMU_IOC_MAGIC, DRV_OPERATION_EM_CONFIG_NEXT_UNCORE, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_READ_UNCORE_DATA       _IOR(LWPMU_IOC_MAGIC, DRV_OPERATION_READ_UNCORE_DATA, IOCTL_ARGS)
+#define LWPMUDRV_IOCTL_STOP_MEM               _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_STOP_MEM)
+#define LWPMUDRV_IOCTL_CREATE_MEM             _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_CREATE_MEM, IOCTL_ARGS_NODE)
+#define LWPMUDRV_IOCTL_READ_MEM               _IOW(LWPMU_IOC_MAGIC, DRV_OPERATION_READ_MEM, IOCTL_ARGS_NODE)
+#define LWPMUDRV_IOCTL_CHECK_STATUS           _IOR(LWPMU_IOC_MAGIC, DRV_OPERATION_CHECK_STATUS, IOCTL_ARGS_NODE)
+#define LWPMUDRV_IOCTL_TIMER_TRIGGER_READ     _IO (LWPMU_IOC_MAGIC, DRV_OPERATION_TIMER_TRIGGER_READ)
+
+#elif defined(DRV_OS_MAC)
+
+// IOCTL_ARGS
+typedef struct IOCTL_ARGS_NODE_S  IOCTL_ARGS_NODE;
+typedef        IOCTL_ARGS_NODE   *IOCTL_ARGS;
+struct IOCTL_ARGS_NODE_S {
+	U64    r_len;
+	char  *r_buf;
+	U64    w_len;
+	char  *w_buf;
+	U32	  command;
+};
+
+typedef struct CPU_ARGS_NODE_S  CPU_ARGS_NODE;
+typedef        CPU_ARGS_NODE   *CPU_ARGS;
+struct CPU_ARGS_NODE_S {
+	U64    r_len;
+	char  *r_buf;
+	U32	  command;
+	U32	  CPU_ID;
+	U32	  BUCKET_ID;
+};
+
+// IOCTL_SETUP
+//
+#define LWPMU_IOC_MAGIC    99
+#define OS_SUCCESS         0
+#define OS_STATUS          int
+#define OS_ILLEGAL_IOCTL  -ENOTTY
+#define OS_NO_MEM         -ENOMEM
+#define OS_FAULT          -EFAULT
+
+// Task file Opcodes.
+// keeping the definitions as IOCTL but in MAC OSX
+// these are really OpCodes consumed by Execute command.
+#define LWPMUDRV_IOCTL_START                  DRV_OPERATION_START
+#define LWPMUDRV_IOCTL_STOP                   DRV_OPERATION_STOP
+#define LWPMUDRV_IOCTL_INIT_PMU               DRV_OPERATION_INIT_PMU
+#define LWPMUDRV_IOCTL_GET_NORMALIZED_TSC     DRV_OPERATION_GET_NORMALIZED_TSC
+#define LWPMUDRV_IOCTL_TSC_SKEW_INFO          DRV_OPERATION_TSC_SKEW_INFO
+#define LWPMUDRV_IOCTL_PAUSE                  DRV_OPERATION_PAUSE
+#define LWPMUDRV_IOCTL_RESUME                 DRV_OPERATION_RESUME
+#define LWPMUDRV_IOCTL_TERMINATE              DRV_OPERATION_TERMINATE
+#define LWPMUDRV_IOCTL_RESERVE                DRV_OPERATION_RESERVE
+#define LWPMUDRV_IOCTL_VERSION                DRV_OPERATION_VERSION
+#define LWPMUDRV_IOCTL_SWITCH_GROUP           DRV_OPERATION_SWITCH_GROUP
+#define LWPMUDRV_IOCTL_GET_DRIVER_STATE       DRV_OPERATION_GET_DRIVER_STATE
+#define LWPMUDRV_IOCTL_INIT_UNCORE            DRV_OPERATION_INIT_UNCORE
+#define LWPMUDRV_IOCTL_EM_GROUPS_UNCORE       DRV_OPERATION_EM_GROUPS_UNCORE
+#define LWPMUDRV_IOCTL_EM_CONFIG_NEXT_UNCORE  DRV_OPERATION_EM_CONFIG_NEXT_UNCORE
+#define LWPMUDRV_IOCTL_READ_UNCORE_DATA       DRV_OPERATION_READ_UNCORE_DATA
+#define LWPMUDRV_IOCTL_STOP_MEM               DRV_OPERATION_STOP_MEM
+#define LWPMUDRV_IOCTL_CREATE_MEM             DRV_OPERATION_CREATE_MEM
+#define LWPMUDRV_IOCTL_READ_MEM               DRV_OPERATION_READ_MEM
+#define LWPMUDRV_IOCTL_CHECK_STATUS           DRV_OPERATION_CHECK_STATUS
+#define LWPMUDRV_IOCTL_TIMER_TRIGGER_READ     DRV_OPERATION_TIMER_TRIGGER_READ
+
+// This is only for MAC OSX
+#define LWPMUDRV_IOCTL_SET_OSX_VERSION        998
+#define LWPMUDRV_IOCTL_PROVIDE_FUNCTION_PTRS  999
+
+#else
+#error "unknown OS in lwpmudrv_ioctl.h"
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
+
diff --git a/drivers/misc/intel/soc_perf/include/lwpmudrv_struct.h b/drivers/misc/intel/soc_perf/include/lwpmudrv_struct.h
new file mode 100644
index 000000000000..087bca1e2b75
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/include/lwpmudrv_struct.h
@@ -0,0 +1,1723 @@
+/***
+ * -------------------------------------------------------------------------
+ *               INTEL CORPORATION PROPRIETARY INFORMATION
+ *  This software is supplied under the terms of the accompanying license
+ *  agreement or nondisclosure agreement with Intel Corporation and may not
+ *  be copied or disclosed except in accordance with the terms of that
+ *  agreement.
+ *        Copyright(C) 2007-2018 Intel Corporation.  All Rights Reserved.
+ * -------------------------------------------------------------------------
+***/
+
+#ifndef _LWPMUDRV_STRUCT_UTILS_H_
+#define _LWPMUDRV_STRUCT_UTILS_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+// processor execution modes
+#define MODE_UNKNOWN    99
+// the following defines must start at 0
+#define MODE_64BIT      3
+#define MODE_32BIT      2
+#define MODE_16BIT      1
+#define MODE_V86        0
+
+// sampling methods
+#define SM_RTC          2020     // real time clock
+#define SM_VTD          2021     // OS Virtual Timer Device
+#define SM_NMI          2022     // non-maskable interrupt time based
+#define SM_EBS          2023     // event based sampling
+#define SM_EBC          2024     // event based counting
+
+// sampling mechanism bitmap definitions
+#define INTERRUPT_RTC   0x1
+#define INTERRUPT_VTD   0x2
+#define INTERRUPT_NMI   0x4
+#define INTERRUPT_EBS   0x8
+
+// Device types
+#define DEV_CORE        0x01
+#define DEV_UNC         0x02
+
+// eflags defines
+#define EFLAGS_VM             0x00020000  // V86 mode
+#define EFLAGS_IOPL0          0
+#define EFLAGS_IOPL1          0x00001000
+#define EFLAGS_IOPL2          0x00002000
+#define EFLAGS_IOPL3          0x00003000
+#define MAX_EMON_GROUPS       1000
+#define MAX_PCI_BUSNO         256
+#define MAX_DEVICES           30
+#define MAX_REGS              64
+#define MAX_EMON_GROUPS       1000
+#define MAX_PCI_DEVNO         32
+#define MAX_PCI_FUNCNO        8
+#define MAX_PCI_DEVUNIT       16
+#define MAX_TURBO_VALUES      32
+#define REG_BIT_MASK          0xFFFFFFFFFFFFFFFFULL
+
+extern float freq_multiplier;
+
+// Enumeration for invoking dispatch on multiple cpus or not
+typedef enum {
+    DRV_MULTIPLE_INSTANCE = 0,
+    DRV_SINGLE_INSTANCE
+} DRV_PROG_TYPE;
+
+
+typedef struct DRV_CONFIG_NODE_S  DRV_CONFIG_NODE;
+typedef        DRV_CONFIG_NODE   *DRV_CONFIG;
+
+struct DRV_CONFIG_NODE_S {
+    U32          size;
+    U16          version;
+    U16          reserved1;
+    U32          reserved2;
+    U32          num_events;
+    DRV_BOOL     start_paused;
+    DRV_BOOL     counting_mode;
+    U32          dispatch_id;
+    DRV_BOOL     enable_chipset;
+    U32          num_chipset_events;
+    U32          chipset_offset;
+    DRV_BOOL     enable_gfx;
+    DRV_BOOL     enable_pwr;
+    DRV_BOOL     emon_mode;
+    U32          pebs_mode;
+    U32          pebs_capture;
+    DRV_BOOL     collect_lbrs;
+    DRV_BOOL     collect_callstacks;
+    DRV_BOOL     debug_inject;
+    DRV_BOOL     virt_phys_translation;
+    DRV_BOOL     latency_capture;
+    U32          max_gp_counters;
+    DRV_BOOL     htoff_mode;
+    DRV_BOOL     power_capture;
+    U32          results_offset;   // this is to store the offset for this device's results
+    DRV_BOOL     eventing_ip_capture;
+    DRV_BOOL     hle_capture;
+    U32          emon_unc_offset[MAX_EMON_GROUPS];
+    DRV_BOOL     enable_p_state;   // adding MPERF and APERF values at the end of the samples
+    DRV_BOOL     enable_cp_mode;   // enabling continuous profiling mode
+    S32          seed_name_len;
+    DRV_BOOL     read_pstate_msrs;
+    U64          target_pid;
+    DRV_BOOL     use_pcl;
+    DRV_BOOL     enable_ebc;
+    DRV_BOOL     enable_tbc;
+    U32          ebc_group_id_offset;
+    union {
+        S8      *seed_name;
+        U64      dummy1;
+    } u1;
+    union {
+        S8      *cpu_mask;
+        U64      dummy2;
+    } u2;
+    U32          device_type;
+    DRV_BOOL     ds_area_available;
+    DRV_BOOL     precise_ip_lbrs;
+    DRV_BOOL     store_lbrs;
+    DRV_BOOL     tsc_capture;
+    U32          os_of_interest;
+    U32          pebs_record_num;
+    DRV_BOOL     per_cpu_tsc;
+    DRV_BOOL     collect_kernel_callstacks;
+    union {
+        U32 enable_bit_fields;
+        struct {
+            U32 enable_perf_metrics        : 1;
+            U32 enable_adaptive_pebs       : 1;
+            U32 apebs_collect_mem_info     : 1;
+            U32 apebs_collect_gpr          : 1;
+            U32 apebs_collect_xmm          : 1;
+            U32 apebs_collect_lbrs         : 1;
+            U32 collect_fixed_counter_pebs : 1;
+            U32 collect_os_callstacks      : 1;
+            U32 reserved_field1            : 24;
+        } s1;
+    } u3;
+    U8           num_perf_metrics;
+    U8           apebs_num_lbr_entries;
+    U16          emon_perf_metrics_offset;
+    S32          p_state_trigger_index;
+    U64          reserved5;
+};
+
+#define DRV_CONFIG_size(cfg)                       (cfg)->size
+#define DRV_CONFIG_version(cfg)                    (cfg)->version
+#define DRV_CONFIG_num_events(cfg)                 (cfg)->num_events
+#define DRV_CONFIG_start_paused(cfg)               (cfg)->start_paused
+#define DRV_CONFIG_counting_mode(cfg)              (cfg)->counting_mode
+#define DRV_CONFIG_dispatch_id(cfg)                (cfg)->dispatch_id
+#define DRV_CONFIG_enable_chipset(cfg)             (cfg)->enable_chipset
+#define DRV_CONFIG_num_chipset_events(cfg)         (cfg)->num_chipset_events
+#define DRV_CONFIG_chipset_offset(cfg)             (cfg)->chipset_offset
+#define DRV_CONFIG_enable_gfx(cfg)                 (cfg)->enable_gfx
+#define DRV_CONFIG_enable_pwr(cfg)                 (cfg)->enable_pwr
+#define DRV_CONFIG_emon_mode(cfg)                  (cfg)->emon_mode
+#define DRV_CONFIG_pebs_mode(cfg)                  (cfg)->pebs_mode
+#define DRV_CONFIG_pebs_capture(cfg)               (cfg)->pebs_capture
+#define DRV_CONFIG_collect_lbrs(cfg)               (cfg)->collect_lbrs
+#define DRV_CONFIG_collect_callstacks(cfg)         (cfg)->collect_callstacks
+#define DRV_CONFIG_collect_kernel_callstacks(cfg)  (cfg)->collect_kernel_callstacks
+#define DRV_CONFIG_debug_inject(cfg)               (cfg)->debug_inject
+#define DRV_CONFIG_virt_phys_translation(cfg)      (cfg)->virt_phys_translation
+#define DRV_CONFIG_latency_capture(cfg)            (cfg)->latency_capture
+#define DRV_CONFIG_max_gp_counters(cfg)            (cfg)->max_gp_counters
+#define DRV_CONFIG_htoff_mode(cfg)                 (cfg)->htoff_mode
+#define DRV_CONFIG_power_capture(cfg)              (cfg)->power_capture
+#define DRV_CONFIG_results_offset(cfg)             (cfg)->results_offset
+#define DRV_CONFIG_eventing_ip_capture(cfg)        (cfg)->eventing_ip_capture
+#define DRV_CONFIG_hle_capture(cfg)                (cfg)->hle_capture
+#define DRV_CONFIG_emon_unc_offset(cfg,grp_num)    (cfg)->emon_unc_offset[grp_num]
+#define DRV_CONFIG_enable_p_state(cfg)             (cfg)->enable_p_state
+#define DRV_CONFIG_enable_cp_mode(cfg)             (cfg)->enable_cp_mode
+#define DRV_CONFIG_seed_name(cfg)                  (cfg)->u1.seed_name
+#define DRV_CONFIG_seed_name_len(cfg)              (cfg)->seed_name_len
+#define DRV_CONFIG_read_pstate_msrs(cfg)           (cfg)->read_pstate_msrs
+#define DRV_CONFIG_cpu_mask(cfg)                   (cfg)->u2.cpu_mask
+#define DRV_CONFIG_target_pid(cfg)                 (cfg)->target_pid
+#define DRV_CONFIG_use_pcl(cfg)                    (cfg)->use_pcl
+#define DRV_CONFIG_event_based_counts(cfg)         (cfg)->enable_ebc
+#define DRV_CONFIG_ebc_group_id_offset(cfg)        (cfg)->ebc_group_id_offset
+#define DRV_CONFIG_timer_based_counts(cfg)         (cfg)->enable_tbc
+#define DRV_CONFIG_device_type(cfg)                (cfg)->device_type
+#define DRV_CONFIG_ds_area_available(cfg)          (cfg)->ds_area_available
+#define DRV_CONFIG_precise_ip_lbrs(cfg)            (cfg)->precise_ip_lbrs
+#define DRV_CONFIG_store_lbrs(cfg)                 (cfg)->store_lbrs
+#define DRV_CONFIG_tsc_capture(cfg)                (cfg)->tsc_capture
+#define DRV_CONFIG_os_of_interest(cfg)             (cfg)->os_of_interest
+#define DRV_CONFIG_pebs_record_num(cfg)            (cfg)->pebs_record_num
+#define DRV_CONFIG_per_cpu_tsc(cfg)                (cfg)->per_cpu_tsc
+#define DRV_CONFIG_enable_bit_fields(cfg)          (cfg)->u3.enable_bit_fields
+#define DRV_CONFIG_enable_perf_metrics(cfg)        (cfg)->u3.s1.enable_perf_metrics
+#define DRV_CONFIG_num_perf_metrics(cfg)           (cfg)->num_perf_metrics
+#define DRV_CONFIG_emon_perf_metrics_offset(cfg)   (cfg)->emon_perf_metrics_offset
+#define DRV_CONFIG_enable_adaptive_pebs(cfg)       (cfg)->u3.s1.enable_adaptive_pebs
+#define DRV_CONFIG_apebs_collect_mem_info(cfg)     (cfg)->u3.s1.apebs_collect_mem_info
+#define DRV_CONFIG_apebs_collect_gpr(cfg)          (cfg)->u3.s1.apebs_collect_gpr
+#define DRV_CONFIG_apebs_collect_xmm(cfg)          (cfg)->u3.s1.apebs_collect_xmm
+#define DRV_CONFIG_apebs_collect_lbrs(cfg)         (cfg)->u3.s1.apebs_collect_lbrs
+#define DRV_CONFIG_apebs_num_lbr_entries(cfg)      (cfg)->apebs_num_lbr_entries
+#define DRV_CONFIG_collect_fixed_counter_pebs(cfg) (cfg)->u3.s1.collect_fixed_counter_pebs
+#define DRV_CONFIG_collect_os_callstacks(cfg)      (cfg)->u3.s1.collect_os_callstacks
+#define DRV_CONFIG_p_state_trigger_index(cfg)      (cfg)->p_state_trigger_index
+
+#define DRV_CONFIG_VERSION                        1
+/*
+ *    X86 processor code descriptor
+ */
+typedef struct CodeDescriptor_s {
+    union {
+        U32 lowWord;                   // low dword of descriptor
+        struct {                       // low broken out by fields
+            U16 limitLow;              // segment limit 15:00
+            U16 baseLow;               // segment base 15:00
+        } s1;
+    } u1;
+    union {
+        U32   highWord;               // high word of descriptor
+        struct {                      // high broken out by bit fields
+            U32   baseMid      : 8;   // base 23:16
+            U32   accessed     : 1;   // accessed
+            U32   readable     : 1;   // readable
+            U32   conforming   : 1;   // conforming code segment
+            U32   oneOne       : 2;   // always 11
+            U32   dpl          : 2;   // Dpl
+            U32   pres         : 1;   // present bit
+            U32   limitHi      : 4;   // limit 19:16
+            U32   sys          : 1;   // available for use by system
+            U32   reserved_0   : 1;   // reserved, always 0
+            U32   default_size : 1;   // default operation size (1=32bit, 0=16bit)
+            U32   granularity  : 1;   // granularity (1=32 bit, 0=20 bit)
+            U32   baseHi       : 8;   // base hi 31:24
+        } s2;
+    } u2;
+} CodeDescriptor;
+
+/*
+ *  Module record.  These are emitted whenever a DLL or EXE is loaded or unloaded.
+ *  The filename fields may be 0 on an unload.  The records reperesent a module for a
+ *  certain span of time, delineated by the load / unload samplecounts.
+ *  Note:
+ *  The structure contains 64 bit fields which may cause the compiler to pad the
+ *  length of the structure to an 8 byte boundary.
+ */
+typedef struct ModuleRecord_s {
+   U16    recLength;          // total length of this record (including this length,
+                              // always U32 multiple)  output from sampler is variable
+                              // length (pathname at end of record) sampfile builder moves
+                              // path names to a separate "literal pool" area
+                              // so that these records become fixed length, and can be treated
+                              // as an array see modrecFixedLen in header
+
+   U16    segmentType :  2;   // V86, 16, 32, 64 (see MODE_ defines), maybe inaccurate for Win95
+                              // .. a 16 bit module may become a 32 bit module, inferred by
+                              // ..looking at 1st sample record that matches the module selector
+   U16    loadEvent   :  1;   // 0 for load, 1 for unload
+   U16    processed   :  1;   // 0 for load, 1 for unload
+   U16    reserved0   : 12;
+
+   U16    selector;           // code selector or V86 segment
+   U16    segmentNameLength;  // length of the segment name if the segmentNameSet bit is set
+   U32    segmentNumber;      // segment number, Win95 (and now Java) can have multiple pieces for one module
+   union {
+      U32 flags;                            // all the flags as one dword
+      struct {
+         U32 exe                     : 1;   // this module is an exe
+         U32 globalModule            : 1;   // globally loaded module.  There may be multiple
+                                            // module records for a global module, but the samples
+                                            // will only point to the 1st one, the others will be
+                                            // ignored.  NT's Kernel32 is an example of this.
+                                            // REVISIT this??
+         U32 bogusWin95              : 1;   // "bogus" win95 module.  By bogus, we mean a
+                                            // module that has a pid of 0, no length and no base.
+                                            // Selector actually used as a 32 bit module.
+         U32 pidRecIndexRaw          : 1;   // pidRecIndex is raw OS pid
+         U32 sampleFound             : 1;   // at least one sample referenced this module
+         U32 tscUsed                 : 1;   // tsc set when record written
+         U32 duplicate               : 1;   // 1st pass analysis has determined this is a
+                                            // duplicate load
+         U32 globalModuleTB5         : 1;   // module mapped into all processes on system
+         U32 segmentNameSet          : 1;   // set if the segment name was collected
+                                            // (initially done for xbox collections)
+         U32 firstModuleRecInProcess : 1;   // if the pidCreatesTrackedInModuleRecs flag is set
+                                            //  in the SampleHeaderEx struct and this flag
+                                            //  is set, the associated module indicates
+                                            //  the beginning of a new process
+         U32  source                 : 1;   // 0 for path in target system, 1 for path in host system (offloaded)
+         U32  unknownLoadAddress     : 1;   // for 0 valid loadAddr64 value, 1 for invalid loadAddr64 value
+         U32  reserved1              : 20;
+      } s1;
+   } u2;
+   U64   length64;         // module length
+   U64   loadAddr64;       // load address
+   U32   pidRecIndex;      // process ID rec index (index into  start of pid record section).
+                           // .. (see pidRecIndexRaw).  If pidRecIndex == 0 and pidRecIndexRaw == 1
+                           // ..then this is a kernel or global module.  Can validly
+                           // ..be 0 if not raw (array index).  Use ReturnPid() to access this
+                           // ..field
+   U32   osid;             // OS identifier
+   U64   unloadTsc;        // TSC collected on an unload event
+   U32   path;             // module path name (section offset on disk)
+                           // ..when initally written by sampler name is at end of this
+                           // ..struct, when merged with main file names are pooled at end
+                           // ..of ModuleRecord Section so ModulesRecords can be
+                           // ..fixed length
+   U16   pathLength;       // path name length (inludes terminating \0)
+   U16   filenameOffset;   // offset into path name of base filename
+   U32   segmentName;      // offset to the segmentName from the beginning of the
+                           //  module section in a processed module section
+                           //  (s/b 0 in a raw module record)
+                           // in a raw module record, the segment name will follow the
+                           //  module name and the module name's terminating NULL char
+   U32   page_offset_high;
+   U64   tsc;              // time stamp counter module event occurred
+   U32   parent_pid;       // Parent PID of the process
+   U32   page_offset_low;
+} ModuleRecord;
+
+#define MR_unloadTscSet(x,y)        (x)->unloadTsc = (y)
+#define MR_unloadTscGet(x)          (x)->unloadTsc
+
+#define MR_page_offset_Set(x,y)   (x)->page_offset_low = (y)&0xFFFFFFFF; (x)->page_offset_high=((y)>>32)&0xFFFFFFFF;
+#define MR_page_offset_Get(x)     ((((U64)(x)->page_offset_high)<<32) | (x)->page_offset_low)
+
+// Accessor macros for ModuleRecord
+#define MODULE_RECORD_rec_length(x)                     (x)->recLength
+#define MODULE_RECORD_segment_type(x)                   (x)->segmentType
+#define MODULE_RECORD_load_event(x)                     (x)->loadEvent
+#define MODULE_RECORD_processed(x)                      (x)->processed
+#define MODULE_RECORD_selector(x)                       (x)->selector
+#define MODULE_RECORD_segment_name_length(x)            (x)->segmentNameLength
+#define MODULE_RECORD_segment_number(x)                 (x)->segmentNumber
+#define MODULE_RECORD_flags(x)                          (x)->u2.flags
+#define MODULE_RECORD_exe(x)                            (x)->u2.s1.exe
+#define MODULE_RECORD_global_module(x)                  (x)->u2.s1.globalModule
+#define MODULE_RECORD_bogus_win95(x)                    (x)->u2.s1.bogusWin95
+#define MODULE_RECORD_pid_rec_index_raw(x)              (x)->u2.s1.pidRecIndexRaw
+#define MODULE_RECORD_sample_found(x)                   (x)->u2.s1.sampleFound
+#define MODULE_RECORD_tsc_used(x)                       (x)->u2.s1.tscUsed
+#define MODULE_RECORD_duplicate(x)                      (x)->u2.s1.duplicate
+#define MODULE_RECORD_global_module_tb5(x)              (x)->u2.s1.globalModuleTB5
+#define MODULE_RECORD_segment_name_set(x)               (x)->u2.s1.segmentNameSet
+#define MODULE_RECORD_first_module_rec_in_process(x)    (x)->u2.s1.firstModuleRecInProcess
+#define MODULE_RECORD_source(x)                         (x)->u2.s1.source
+#define MODULE_RECORD_unknown_load_address(x)           (x)->u2.s1.unknownLoadAddress
+#define MODULE_RECORD_length64(x)                       (x)->length64
+#define MODULE_RECORD_load_addr64(x)                    (x)->loadAddr64
+#define MODULE_RECORD_pid_rec_index(x)                  (x)->pidRecIndex
+#define MODULE_RECORD_load_sample_count(x)              (x)->u5.s2.loadSampleCount
+#define MODULE_RECORD_unload_sample_count(x)            (x)->u5.s2.unloadSampleCount
+#define MODULE_RECORD_unload_tsc(x)                     (x)->unloadTsc
+#define MODULE_RECORD_path(x)                           (x)->path
+#define MODULE_RECORD_path_length(x)                    (x)->pathLength
+#define MODULE_RECORD_filename_offset(x)                (x)->filenameOffset
+#define MODULE_RECORD_segment_name(x)                   (x)->segmentName
+#define MODULE_RECORD_tsc(x)                            (x)->tsc
+#define MODULE_RECORD_parent_pid(x)                     (x)->parent_pid
+#define MODULE_RECORD_osid(x)                           (x)->osid
+
+/*
+ *  Sample record.  Size can be determined by looking at the header record.
+ *  There can be up to 3 sections.  The SampleFileHeader defines the presence
+ *  of sections and their offsets. Within a sample file, all of the sample
+ *  records have the same number of sections and the same size.  However,
+ *  different sample record sections and sizes can exist in different
+ *  sample files.  Since recording counters and the time stamp counter for
+ *  each sample can be space consuming, the user can determine whether or not
+ *  this information is kept at sample collection time.
+ */
+
+typedef struct SampleRecordPC_s {   // Program Counter section
+    U32   descriptor_id;
+    U32   osid;                 // OS identifier
+    union {
+        struct {
+            U64 iip;            // IA64 interrupt instruction pointer
+            U64 ipsr;           // IA64 interrupt processor status register
+        } s1;
+        struct {
+            U32  eip;           // IA32 instruction pointer
+            U32  eflags;        // IA32 eflags
+            CodeDescriptor csd; // IA32 code seg descriptor (8 bytes)
+        } s2;
+    } u1;
+    U16    cs;                  // IA32 cs (0 for IA64)
+    union {
+        U16 cpuAndOS;                  // cpu and OS info as one word
+        struct {                       // cpu and OS info broken out
+            U16 cpuNum          : 12;  // cpu number (0 - 4096)
+            U16 notVmid0        : 1;   // win95, vmid0 flag (1 means NOT vmid 0)
+            U16 codeMode        : 2;   // processor mode, see MODE_ defines
+            U16 uncore_valid    : 1;   // identifies if the uncore count is valid
+        } s3;
+    } u2;
+    U32   tid;            // OS thread ID  (may get reused, see tidIsRaw)
+    U32   pidRecIndex;    // process ID rec index (index into start of pid
+                          // record section) .. can validly be 0 if not raw
+                          // (array index).  Use ReturnPid() to
+                          // ..access this field .. (see pidRecIndexRaw)
+    union {
+        U32 bitFields2;
+        struct {
+            U32   mrIndex        : 20;   // module record index (index into start of
+                                         // module rec section) .. (see mrIndexNone)
+            U32   eventIndex     : 8;    // index into the Events section
+            U32   tidIsRaw       : 1;    // tid is raw OS tid
+            U32   IA64PC         : 1;    // TRUE=this is a IA64 PC sample record
+            U32   pidRecIndexRaw : 1;    // pidRecIndex is raw OS pid
+            U32   mrIndexNone    : 1;    // no mrIndex (unknown module)
+        } s4;
+    } u3;
+    U64 tsc;                          // processor timestamp counter
+} SampleRecordPC, *PSampleRecordPC;
+
+#define SAMPLE_RECORD_descriptor_id(x)       (x)->descriptor_id
+#define SAMPLE_RECORD_osid(x)                (x)->osid
+#define SAMPLE_RECORD_iip(x)                 (x)->u1.s1.iip
+#define SAMPLE_RECORD_ipsr(x)                (x)->u1.s1.ipsr
+#define SAMPLE_RECORD_eip(x)                 (x)->u1.s2.eip
+#define SAMPLE_RECORD_eflags(x)              (x)->u1.s2.eflags
+#define SAMPLE_RECORD_csd(x)                 (x)->u1.s2.csd
+#define SAMPLE_RECORD_cs(x)                  (x)->cs
+#define SAMPLE_RECORD_cpu_and_os(x)          (x)->u2.cpuAndOS
+#define SAMPLE_RECORD_cpu_num(x)             (x)->u2.s3.cpuNum
+#define SAMPLE_RECORD_uncore_valid(x)        (x)->u2.s3.uncore_valid
+#define SAMPLE_RECORD_not_vmid0(x)           (x)->u2.s3.notVmid0
+#define SAMPLE_RECORD_code_mode(x)           (x)->u2.s3.codeMode
+#define SAMPLE_RECORD_tid(x)                 (x)->tid
+#define SAMPLE_RECORD_pid_rec_index(x)       (x)->pidRecIndex
+#define SAMPLE_RECORD_bit_fields2(x)         (x)->u3.bitFields2
+#define SAMPLE_RECORD_mr_index(x)            (x)->u3.s4.mrIndex
+#define SAMPLE_RECORD_event_index(x)         (x)->u3.s4.eventIndex
+#define SAMPLE_RECORD_tid_is_raw(x)          (x)->u3.s4.tidIsRaw
+#define SAMPLE_RECORD_ia64_pc(x)             (x)->u3.s4.IA64PC
+#define SAMPLE_RECORD_pid_rec_index_raw(x)   (x)->u3.s4.pidRecIndexRaw
+#define SAMPLE_RECORD_mr_index_none(x)       (x)->u3.s4.mrIndexNone
+#define SAMPLE_RECORD_tsc(x)                 (x)->tsc
+
+// end of SampleRecord sections
+
+/* Uncore Sample Record definition. This is a skinny sample record used by uncore boxes
+   to record samples. The sample record consists of a descriptor id, cpu info and timestamp.*/
+
+typedef struct UncoreSampleRecordPC_s {
+    U32   descriptor_id;
+    U32   osid;
+    U16   cpuNum;
+    U16   pkgNum;
+    union {
+        U32 flags;
+        struct {
+            U32 uncore_valid    : 1;   // identifies if the uncore count is valid
+            U32 reserved1       : 31;
+        } s1;
+    } u1;
+    U64 reserved2;
+    U64 tsc;                          // processor timestamp counter
+} UncoreSampleRecordPC, *PUnocreSampleRecordPC;
+
+#define UNCORE_SAMPLE_RECORD_descriptor_id(x)       (x)->descriptor_id
+#define UNCORE_SAMPLE_RECORD_osid(x)                (x)->osid
+#define UNCORE_SAMPLE_RECORD_cpu_num(x)             (x)->cpuNum
+#define UNCORE_SAMPLE_RECORD_pkg_num(x)             (x)->pkgNum
+#define UNCORE_SAMPLE_RECORD_uncore_valid(x)        (x)->u1.s1.uncore_valid
+#define UNCORE_SAMPLE_RECORD_tsc(x)                 (x)->tsc
+
+// end of UncoreSampleRecord section
+
+// Definitions for user markers data
+// The instances of these structures will be written to the user markers temp file.
+#define MARKER_DEFAULT_TYPE   "Default_Marker"
+#define MARKER_DEFAULT_ID     0
+#define MAX_MARKER_LENGTH     136
+
+#define MARK_ID     4
+#define MARK_DATA   2
+#define THREAD_INFO 8
+
+/* do not use it at ths moment
+typedef enum {
+        SMRK_USER_DEFINED = 0,
+        SMRK_THREAD_NAME,
+        SMRK_WALLCLOCK,
+        SMRK_TEXT,
+        SMRK_TYPE_ID
+}  SMRK_TYPE;
+*/
+
+/*
+ *  Common Register descriptions
+ */
+
+
+/*
+ *  Bits used in the debug control register
+ */
+#define DEBUG_CTL_LBR                          0x0000001
+#define DEBUG_CTL_BTF                          0x0000002
+#define DEBUG_CTL_TR                           0x0000040
+#define DEBUG_CTL_BTS                          0x0000080
+#define DEBUG_CTL_BTINT                        0x0000100
+#define DEBUG_CTL_BT_OFF_OS                    0x0000200
+#define DEBUG_CTL_BTS_OFF_USR                  0x0000400
+#define DEBUG_CTL_FRZ_LBR_ON_PMI               0x0000800
+#define DEBUG_CTL_FRZ_PMON_ON_PMI              0x0001000
+#define DEBUG_CTL_ENABLE_UNCORE_PMI_BIT        0x0002000
+
+
+#define DEBUG_CTL_NODE_lbr_get(reg)                   (reg) &   DEBUG_CTL_LBR
+#define DEBUG_CTL_NODE_lbr_set(reg)                   (reg) |=  DEBUG_CTL_LBR
+#define DEBUG_CTL_NODE_lbr_clear(reg)                 (reg) &= ~DEBUG_CTL_LBR
+
+#define DEBUG_CTL_NODE_btf_get(reg)                   (reg) &   DEBUG_CTL_BTF
+#define DEBUG_CTL_NODE_btf_set(reg)                   (reg) |=  DEBUG_CTL_BTF
+#define DEBUG_CTL_NODE_btf_clear(reg)                 (reg) &= ~DEBUG_CTL_BTF
+
+#define DEBUG_CTL_NODE_tr_get(reg)                    (reg) &   DEBUG_CTL_TR
+#define DEBUG_CTL_NODE_tr_set(reg)                    (reg) |=  DEBUG_CTL_TR
+#define DEBUG_CTL_NODE_tr_clear(reg)                  (reg) &= ~DEBUG_CTL_TR
+
+#define DEBUG_CTL_NODE_bts_get(reg)                   (reg) &   DEBUG_CTL_BTS
+#define DEBUG_CTL_NODE_bts_set(reg)                   (reg) |=  DEBUG_CTL_BTS
+#define DEBUG_CTL_NODE_bts_clear(reg)                 (reg) &= ~DEBUG_CTL_BTS
+
+#define DEBUG_CTL_NODE_btint_get(reg)                 (reg) &   DEBUG_CTL_BTINT
+#define DEBUG_CTL_NODE_btint_set(reg)                 (reg) |=  DEBUG_CTL_BTINT
+#define DEBUG_CTL_NODE_btint_clear(reg)               (reg) &= ~DEBUG_CTL_BTINT
+
+#define DEBUG_CTL_NODE_bts_off_os_get(reg)            (reg) &   DEBUG_CTL_BTS_OFF_OS
+#define DEBUG_CTL_NODE_bts_off_os_set(reg)            (reg) |=  DEBUG_CTL_BTS_OFF_OS
+#define DEBUG_CTL_NODE_bts_off_os_clear(reg)          (reg) &= ~DEBUG_CTL_BTS_OFF_OS
+
+#define DEBUG_CTL_NODE_bts_off_usr_get(reg)           (reg) &   DEBUG_CTL_BTS_OFF_USR
+#define DEBUG_CTL_NODE_bts_off_usr_set(reg)           (reg) |=  DEBUG_CTL_BTS_OFF_USR
+#define DEBUG_CTL_NODE_bts_off_usr_clear(reg)         (reg) &= ~DEBUG_CTL_BTS_OFF_USR
+
+#define DEBUG_CTL_NODE_frz_lbr_on_pmi_get(reg)        (reg) &   DEBUG_CTL_FRZ_LBR_ON_PMI
+#define DEBUG_CTL_NODE_frz_lbr_on_pmi_set(reg)        (reg) |=  DEBUG_CTL_FRZ_LBR_ON_PMI
+#define DEBUG_CTL_NODE_frz_lbr_on_pmi_clear(reg)      (reg) &= ~DEBUG_CTL_FRZ_LBR_ON_PMI
+
+#define DEBUG_CTL_NODE_frz_pmon_on_pmi_get(reg)       (reg) &   DEBUG_CTL_FRZ_PMON_ON_PMI
+#define DEBUG_CTL_NODE_frz_pmon_on_pmi_set(reg)       (reg) |=  DEBUG_CTL_FRZ_PMON_ON_PMI
+#define DEBUG_CTL_NODE_frz_pmon_on_pmi_clear(reg)     (reg) &= ~DEBUG_CTL_FRZ_PMON_ON_PMI
+
+#define DEBUG_CTL_NODE_enable_uncore_pmi_get(reg)     (reg) &   DEBUG_CTL_ENABLE_UNCORE_PMI
+#define DEBUG_CTL_NODE_enable_uncore_pmi_set(reg)     (reg) |=  DEBUG_CTL_ENABLE_UNCORE_PMI
+#define DEBUG_CTL_NODE_enable_uncore_pmi_clear(reg)   (reg) &= ~DEBUG_CTL_ENABLE_UNCORE_PMI
+
+/*
+ * @macro SEP_VERSION_NODE_S
+ * @brief
+ * This structure supports versioning in Sep. The field major indicates the major version,
+ * minor indicates the minor version and api indicates the api version for the current
+ * sep build. This structure is initialized at the time when the driver is loaded.
+ */
+
+typedef struct SEP_VERSION_NODE_S  SEP_VERSION_NODE;
+typedef        SEP_VERSION_NODE   *SEP_VERSION;
+
+struct SEP_VERSION_NODE_S {
+    union {
+        U32      sep_version;
+        struct {
+            S32  major :8;
+            S32  minor :8;
+            S32  api   :8;
+            S32  update:8;
+        }s1;
+    }u1;
+};
+
+#define SEP_VERSION_NODE_sep_version(version) (version)->u1.sep_version
+#define SEP_VERSION_NODE_major(version)       (version)->u1.s1.major
+#define SEP_VERSION_NODE_minor(version)       (version)->u1.s1.minor
+#define SEP_VERSION_NODE_api(version)         (version)->u1.s1.api
+#define SEP_VERSION_NODE_update(version)      (version)->u1.s1.update
+
+/*
+ *  The VTSA_SYS_INFO_STRUCT information that is shared across kernel mode
+ *  and user mode code, very specifically for tb5 file generation
+ */
+
+typedef enum {
+    GT_UNK     = 0,
+    GT_PER_CPU,
+    GT_PER_CHIPSET,
+    GT_CPUID,
+    GT_NODE,
+    GT_SYSTEM,
+    GT_SAMPLE_RECORD_INFO
+} GEN_ENTRY_TYPES;
+
+typedef enum {
+    GST_UNK = 0,
+    GST_X86,
+    GST_ITANIUM,
+    GST_SA,//strong arm
+    GST_XSC,
+    GST_EM64T,
+    GST_CS860
+} GEN_ENTRY_SUBTYPES;
+
+typedef struct __fixed_size_pointer {
+    union  {
+        U64     fs_force_alignment;
+        struct {
+            U32     fs_unused;
+            U32     is_ptr:1;
+        } s1;
+    } u1;
+    union {
+        U64     fs_offset;
+        void   *fs_ptr;
+    } u2;
+} VTSA_FIXED_SIZE_PTR;
+
+#define VTSA_FIXED_SIZE_PTR_is_ptr(fsp)     (fsp)->u1.s1.is_ptr
+#define VTSA_FIXED_SIZE_PTR_fs_offset(fsp)  (fsp)->u2.fs_offset
+#define VTSA_FIXED_SIZE_PTR_fs_ptr(fsp)     (fsp)->u2.fs_ptr
+
+
+typedef struct __generic_array_header {
+    //
+    // Information realted to the generic header
+    //
+    U32 hdr_size;       // size of this generic header
+                        // (for versioning and real data starts
+                        //  after the header)
+
+    U32 next_field_hdr_padding;    // make sure the next field is 8-byte aligned
+
+    //
+    // VTSA_FIXED_SIZE_PTR should always be on an 8-byte boundary...
+    //
+    // pointer to the next generic header if there is one
+    //
+    VTSA_FIXED_SIZE_PTR hdr_next_gen_hdr;
+
+    U32 hdr_reserved[7];     // padding for future use - force to 64 bytes...
+
+    //
+    // Information related to the array this header is describing
+    //
+    U32 array_num_entries;
+    U32 array_entry_size;
+    U16 array_type;         // from the GEN_ENTRY_TYPES enumeration
+    U16 array_subtype;      // from the GEN_ENTRY_SUBTYPES enumeration
+} VTSA_GEN_ARRAY_HDR;
+
+#define VTSA_GEN_ARRAY_HDR_hdr_size(gah)            (gah)->hdr_size
+#define VTSA_GEN_ARRAY_HDR_hdr_next_gen_hdr(gah)    (gah)->hdr_next_gen_hdr
+#define VTSA_GEN_ARRAY_HDR_array_num_entries(gah)   (gah)->array_num_entries
+#define VTSA_GEN_ARRAY_HDR_array_entry_size(gah)    (gah)->array_entry_size
+#define VTSA_GEN_ARRAY_HDR_array_type(gah)          (gah)->array_type
+#define VTSA_GEN_ARRAY_HDR_array_subtype(gah)       (gah)->array_subtype
+
+typedef struct __cpuid_x86 {
+    U32 cpuid_eax_input;
+    U32 cpuid_eax;
+    U32 cpuid_ebx;
+    U32 cpuid_ecx;
+    U32 cpuid_edx;
+} VTSA_CPUID_X86;
+
+#define VTSA_CPUID_X86_cpuid_eax_input(cid) (cid)->cpuid_eax_input
+#define VTSA_CPUID_X86_cpuid_eax(cid)       (cid)->cpuid_eax
+#define VTSA_CPUID_X86_cpuid_ebx(cid)       (cid)->cpuid_ebx
+#define VTSA_CPUID_X86_cpuid_ecx(cid)       (cid)->cpuid_ecx
+#define VTSA_CPUID_X86_cpuid_edx(cid)       (cid)->cpuid_edx
+
+typedef struct __cpuid_ipf {
+    U64 cpuid_select;
+    U64 cpuid_val;
+} VTSA_CPUID_IPF;
+
+#define VTSA_CPUID_IPF_cpuid_select(cid)    (cid)->cpuid_select
+#define VTSA_CPUID_IPF_cpuid_val(cid)       (cid)->cpuid_val
+
+typedef struct __generic_per_cpu {
+    //
+    // per cpu information
+    //
+    U32 cpu_number;             // cpu number (as defined by the OS)
+    U32 cpu_speed_mhz;          // cpu speed (in Mhz)
+    U32 cpu_fsb_mhz;            // Front Side Bus speed (in Mhz) (if known)
+    U32 cpu_cache_L2;           // ??? USER: cpu L2 (marketing definition) cache size (if known)
+
+    //
+    // And pointer to other structures. Keep this on an 8-byte boundary
+    //
+    // "pointer" to generic array header that should contain
+    // cpuid information for this cpu
+    //
+    VTSA_FIXED_SIZE_PTR cpu_cpuid_array;
+
+    S64 cpu_tsc_offset;         // TSC offset from CPU 0 computed as (TSC CPU N - TSC CPU 0)
+    //
+    // intel processor number (from mkting).
+    // Currently 3 decimal digits (3xx, 5xx and 7xx)
+    //
+    U32 cpu_intel_processor_number;
+
+    U32 cpu_cache_L3;           // ??? USER: cpu L3 (marketing definition) cache size (if known)
+
+    U64 platform_id;
+
+    //
+    // package/mapping information
+    //
+    // The hierarchy for uniquely identifying a logical processor
+    // in a system is node number/id (from the node structure),
+    // package number, core number, and thread number.
+    // Core number is for identifying a core within a package.
+    //
+    // Actually, on Itanium getting all this information is
+    // pretty involved with complicated algorithm using PAL calls.
+    // I don't know how important all this stuff is to the user.
+    // Maybe we can just have the place holder now and figure out
+    // how to fill them later.
+    //
+    U16 cpu_package_num;             // package number for this cpu (if known)
+    U16 cpu_core_num;                // core number (if known)
+    U16 cpu_hw_thread_num;           // hw thread number inside the core (if known)
+
+    U16 cpu_threads_per_core;        // total number of h/w threads per core (if known)
+    U16 cpu_module_id;               // Processor module number
+    U16 cpu_num_modules;             // Number of processor modules
+    U32 reserved;
+
+} VTSA_GEN_PER_CPU;
+
+#define VTSA_GEN_PER_CPU_cpu_number(p_cpu)                  (p_cpu)->cpu_number
+#define VTSA_GEN_PER_CPU_cpu_speed_mhz(p_cpu)               (p_cpu)->cpu_speed_mhz
+#define VTSA_GEN_PER_CPU_cpu_fsb_mhz(p_cpu)                 (p_cpu)->cpu_fsb_mhz
+#define VTSA_GEN_PER_CPU_cpu_cache_L2(p_cpu)                (p_cpu)->cpu_cache_L2
+#define VTSA_GEN_PER_CPU_cpu_cpuid_array(p_cpu)             (p_cpu)->cpu_cpuid_array
+#define VTSA_GEN_PER_CPU_cpu_tsc_offset(p_cpu)              (p_cpu)->cpu_tsc_offset
+#define VTSA_GEN_PER_CPU_cpu_intel_processor_number(p_cpu)  (p_cpu)->cpu_intel_processor_number
+#define VTSA_GEN_PER_CPU_cpu_cache_L3(p_cpu)                (p_cpu)->cpu_cache_L3
+#define VTSA_GEN_PER_CPU_platform_id(p_cpu)                 (p_cpu)->platform_id
+#define VTSA_GEN_PER_CPU_cpu_package_num(p_cpu)             (p_cpu)->cpu_package_num
+#define VTSA_GEN_PER_CPU_cpu_core_num(p_cpu)                (p_cpu)->cpu_core_num
+#define VTSA_GEN_PER_CPU_cpu_hw_thread_num(p_cpu)           (p_cpu)->cpu_hw_thread_num
+#define VTSA_GEN_PER_CPU_cpu_threads_per_core(p_cpu)        (p_cpu)->cpu_threads_per_core
+#define VTSA_GEN_PER_CPU_cpu_module_num(p_cpu)              (p_cpu)->cpu_module_id
+#define VTSA_GEN_PER_CPU_cpu_num_modules(p_cpu)             (p_cpu)->cpu_num_modules
+
+
+typedef struct __node_info {
+    U32 node_type_from_shell;
+    U32 node_id;                   // The node number/id (if known)
+
+    U32 node_num_available;        // total number cpus on this node
+    U32 node_num_used;             // USER: number used based on cpu mask at time of run
+
+    U64 node_physical_memory;      // amount of physical memory (bytes) on this node
+
+    //
+    // pointer to the first generic header that
+    // contains the per-cpu information
+    //
+    // Keep the VTSA_FIXED_SIZE_PTR on an 8-byte boundary...
+    //
+    VTSA_FIXED_SIZE_PTR node_percpu_array;
+
+    U32 node_reserved[2];           // leave some space
+
+} VTSA_NODE_INFO;
+
+#define VTSA_NODE_INFO_node_type_from_shell(vni)    (vni)->node_type_from_shell
+#define VTSA_NODE_INFO_node_id(vni)                 (vni)->node_id
+#define VTSA_NODE_INFO_node_num_available(vni)      (vni)->node_num_available
+#define VTSA_NODE_INFO_node_num_used(vni)           (vni)->node_num_used
+#define VTSA_NODE_INFO_node_physical_memory(vni)    (vni)->node_physical_memory
+#define VTSA_NODE_INFO_node_percpu_array(vni)       (vni)->node_percpu_array
+
+
+typedef struct __sys_info {
+    //
+    // Keep this on an 8-byte boundary
+    //
+    VTSA_FIXED_SIZE_PTR node_array;  // the per-node information
+
+    U64 min_app_address;         // USER: lower allowed user space address (if known)
+    U64 max_app_address;         // USER: upper allowed user space address (if known)
+    U32 page_size;               // Current page size
+    U32 allocation_granularity;  // USER: Granularity of allocation requests (if known)
+    U32 reserved1;               // added for future fields
+    U32 reserved2;               // alignment purpose
+    U64 reserved3[3];            // added for future fields
+
+} VTSA_SYS_INFO;
+
+#define VTSA_SYS_INFO_node_array(sys_info)                (sys_info)->node_array
+#define VTSA_SYS_INFO_min_app_address(sys_info)           (sys_info)->min_app_address
+#define VTSA_SYS_INFO_max_app_address(sys_info)           (sys_info)->max_app_address
+#define VTSA_SYS_INFO_page_size(sys_info)                 (sys_info)->page_size
+#define VTSA_SYS_INFO_allocation_granularity(sys_info)    (sys_info)->allocation_granularity
+
+typedef struct DRV_TOPOLOGY_INFO_NODE_S DRV_TOPOLOGY_INFO_NODE;
+typedef        DRV_TOPOLOGY_INFO_NODE  *DRV_TOPOLOGY_INFO;
+
+struct DRV_TOPOLOGY_INFO_NODE_S {
+    U32 cpu_number;                 // cpu number (as defined by the OS)
+    U16 cpu_package_num;            // package number for this cpu (if known)
+    U16 cpu_core_num;               // core number (if known)
+    U16 cpu_hw_thread_num;          // T0 or T1 if HT enabled
+    S32 socket_master;
+    S32 core_master;
+    S32 thr_master;
+    U32 cpu_module_num;
+    U32 cpu_module_master;
+    U32 cpu_num_modules;
+} ;
+
+#define DRV_TOPOLOGY_INFO_cpu_number(dti)          (dti)->cpu_number
+#define DRV_TOPOLOGY_INFO_cpu_package_num(dti)     (dti)->cpu_package_num
+#define DRV_TOPOLOGY_INFO_cpu_core_num(dti)        (dti)->cpu_core_num
+#define DRV_TOPOLOGY_INFO_socket_master(dti)       (dti)->socket_master
+#define DRV_TOPOLOGY_INFO_core_master(dti)         (dti)->core_master
+#define DRV_TOPOLOGY_INFO_thr_master(dti)          (dti)->thr_master
+#define DRV_TOPOLOGY_INFO_cpu_hw_thread_num(dti)   (dti)->cpu_hw_thread_num
+#define DRV_TOPOLOGY_INFO_cpu_module_num(dti)      (dti)->cpu_module_num
+#define DRV_TOPOLOGY_INFO_cpu_module_master(dti)   (dti)->cpu_module_master
+#define DRV_TOPOLOGY_INFO_cpu_num_modules(dti)     (dti)->cpu_num_modules
+
+#define VALUE_TO_BE_DISCOVERED                     0
+
+// dimm information
+typedef struct DRV_DIMM_INFO_NODE_S DRV_DIMM_INFO_NODE;
+typedef        DRV_DIMM_INFO_NODE  *DRV_DIMM_INFO;
+
+struct DRV_DIMM_INFO_NODE_S {
+  U32 platform_id;
+  U32 channel_num;
+  U32 rank_num;
+  U32 value;
+  U8  mc_num;
+  U8  dimm_valid;
+  U8  valid_value;
+  U8  rank_value;
+  U8  density_value;
+  U8  width_value;
+  U16 socket_num;
+  U64 reserved;
+};
+
+#define DRV_DIMM_INFO_platform_id(di)   (di)->platform_id
+#define DRV_DIMM_INFO_channel_num(di)   (di)->channel_num
+#define DRV_DIMM_INFO_rank_num(di)      (di)->rank_num
+#define DRV_DIMM_INFO_value(di)         (di)->value
+#define DRV_DIMM_INFO_mc_num(di)        (di)->mc_num
+#define DRV_DIMM_INFO_dimm_valid(di)    (di)->dimm_valid
+#define DRV_DIMM_INFO_valid_value(di)   (di)->valid_value
+#define DRV_DIMM_INFO_rank_value(di)    (di)->rank_value
+#define DRV_DIMM_INFO_density_value(di) (di)->density_value
+#define DRV_DIMM_INFO_width_value(di)   (di)->width_value
+#define DRV_DIMM_INFO_socket_num(di)    (di)->socket_num
+
+//platform information. need to get from driver
+#define MAX_PACKAGES  16
+#define MAX_CHANNELS  8
+#define MAX_RANKS     3
+
+typedef struct DRV_PLATFORM_INFO_NODE_S DRV_PLATFORM_INFO_NODE;
+typedef        DRV_PLATFORM_INFO_NODE  *DRV_PLATFORM_INFO;
+
+struct DRV_PLATFORM_INFO_NODE_S {
+    U64 info;                     // platform info
+    U64 ddr_freq_index;           // freq table index
+    U8  misc_valid;               // misc enabled valid bit
+    U8  reserved1;                // added for alignment purpose
+    U16 reserved2;
+    U32 vmm_timer_freq;           // timer frequency from VMM on SoFIA (in HZ)
+    U64 misc_info;                // misc enabled info
+    U64 ufs_freq;                 // ufs frequency (HSX only)
+    DRV_DIMM_INFO_NODE dimm_info[MAX_PACKAGES * MAX_CHANNELS * MAX_RANKS];
+    U64 energy_multiplier;        // Value of energy multiplier
+    U64 reserved3;
+    U64 reserved4;
+    U64 reserved5;
+    U64 reserved6;
+};
+
+#define DRV_PLATFORM_INFO_info(data)              (data)->info
+#define DRV_PLATFORM_INFO_ddr_freq_index(data)    (data)->ddr_freq_index
+#define DRV_PLATFORM_INFO_misc_valid(data)        (data)->misc_valid
+#define DRV_PLATFORM_INFO_misc_info(data)         (data)->misc_info
+#define DRV_PLATFORM_INFO_ufs_freq(data)          (data)->ufs_freq
+#define DRV_PLATFORM_INFO_dimm_info(data)         (data)->dimm_info
+#define DRV_PLATFORM_INFO_energy_multiplier(data) (data)->energy_multiplier
+#define DRV_PLATFORM_INFO_vmm_timer_freq(data)    (data)->vmm_timer_freq
+
+//platform information. need to get from Platform picker
+typedef struct PLATFORM_FREQ_INFO_NODE_S PLATFORM_FREQ_INFO_NODE;
+typedef        PLATFORM_FREQ_INFO_NODE  *PLATFORM_FREQ_INFO;
+
+struct PLATFORM_FREQ_INFO_NODE_S {
+    float   multiplier;          // freq multiplier
+    double *table;               // freq table
+    U32     table_size;          // freq table size
+    U64     reserved1;
+    U64     reserved2;
+    U64     reserved3;
+    U64     reserved4;
+};
+#define PLATFORM_FREQ_INFO_multiplier(data)       (data)->multiplier
+#define PLATFORM_FREQ_INFO_table(data)            (data)->table
+#define PLATFORM_FREQ_INFO_table_size(data)       (data)->table_size
+
+typedef struct DEVICE_INFO_NODE_S  DEVICE_INFO_NODE;
+typedef        DEVICE_INFO_NODE   *DEVICE_INFO; //NEEDED in PP
+
+struct DEVICE_INFO_NODE_S {
+    S8                 *dll_name;
+    PVOID               dll_handle;
+    S8                 *cpu_name;
+    S8                 *pmu_name;
+    S8                 *event_db_file_name;
+    //PLATFORM_IDENTITY plat_identity;  // this is undefined right now. Please take this as structure containing U64
+    U32                 plat_type;      // device type (e.g., DEVICE_INFO_CORE, etc. ... see enum below)
+    U32                 plat_sub_type;  // cti_type (e.g., CTI_Sandybridge, etc., ... see env_info_types.h)
+    S32                 dispatch_id;    // this will be set in user mode dlls and will be unique across all IPF, IA32 (including MIDS).
+    ECB                *ecb;
+    EVENT_CONFIG        ec;
+    DRV_CONFIG          pcfg;
+    U32                 num_of_groups;
+    U32                 size_of_alloc;  // size of each event control block
+    PVOID               drv_event;
+    U32                 num_events;
+    U32                 event_id_index; // event id index of device (basically how many events processed before this device)
+    U32                 num_counters;
+    U32                 group_index;
+    U32                 num_packages;
+    U32                 num_units;
+    U32                 device_type;
+    U64                 reserved1;
+    U32                 pmu_clone_id;   // cti_type of platform to impersonate in device DLLs
+    U32                 reserved2;
+    U64                 reserved3;
+    U64                 reserved4;
+};
+
+#define MAX_EVENT_NAME_LENGTH 64
+
+#define DEVICE_INFO_dll_name(pdev)                  (pdev)->dll_name
+#define DEVICE_INFO_dll_handle(pdev)                (pdev)->dll_handle
+#define DEVICE_INFO_cpu_name(pdev)                  (pdev)->cpu_name
+#define DEVICE_INFO_pmu_name(pdev)                  (pdev)->pmu_name
+#define DEVICE_INFO_event_db_file_name(pdev)        (pdev)->event_db_file_name
+#define DEVICE_INFO_plat_type(pdev)                 (pdev)->plat_type
+#define DEVICE_INFO_plat_sub_type(pdev)             (pdev)->plat_sub_type
+#define DEVICE_INFO_pmu_clone_id(pdev)              (pdev)->pmu_clone_id
+#define DEVICE_INFO_dispatch_id(pdev)               (pdev)->dispatch_id
+#define DEVICE_INFO_ecb(pdev)                       (pdev)->ecb
+#define DEVICE_INFO_ec(pdev)                        (pdev)->ec
+#define DEVICE_INFO_pcfg(pdev)                      (pdev)->pcfg
+#define DEVICE_INFO_num_groups(pdev)                (pdev)->num_of_groups
+#define DEVICE_INFO_size_of_alloc(pdev)             (pdev)->size_of_alloc
+#define DEVICE_INFO_drv_event(pdev)                 (pdev)->drv_event
+#define DEVICE_INFO_num_events(pdev)                (pdev)->num_events
+#define DEVICE_INFO_event_id_index(pdev)            (pdev)->event_id_index
+#define DEVICE_INFO_num_counters(pdev)              (pdev)->num_counters
+#define DEVICE_INFO_group_index(pdev)               (pdev)->group_index
+#define DEVICE_INFO_num_packages(pdev)              (pdev)->num_packages
+#define DEVICE_INFO_num_units(pdev)                 (pdev)->num_units
+#define DEVICE_INFO_device_type(pdev)               (pdev)->device_type
+
+
+typedef struct DEVICE_INFO_DATA_NODE_S DEVICE_INFO_DATA_NODE;
+typedef        DEVICE_INFO_DATA_NODE  *DEVICE_INFO_DATA; //NEEDED in PP
+
+struct DEVICE_INFO_DATA_NODE_S {
+    DEVICE_INFO         pdev_info;
+    U32                 num_elements;
+    U32                 num_allocated;
+    U64                 reserved1;
+    U64                 reserved2;
+    U64                 reserved3;
+    U64                 reserved4;
+};
+
+#define DEVICE_INFO_DATA_pdev_info(d)           (d)->pdev_info
+#define DEVICE_INFO_DATA_num_elements(d)        (d)->num_elements
+#define DEVICE_INFO_DATA_num_allocated(d)       (d)->num_allocated
+
+typedef enum
+{
+    DEVICE_INFO_CORE        =   0,
+    DEVICE_INFO_UNCORE      =   1,
+    DEVICE_INFO_CHIPSET     =   2,
+    DEVICE_INFO_GFX         =   3,
+    DEVICE_INFO_PWR         =   4,
+    DEVICE_INFO_TELEMETRY   =   5
+}   DEVICE_INFO_TYPE;
+
+typedef enum {
+    INVALID_TERMINATE_TYPE = 0,
+    STOP_TERMINATE,
+    CANCEL_TERMINATE
+} ABNORMAL_TERMINATE_TYPE;
+
+#if defined(__cplusplus)
+}
+#endif
+
+typedef struct EMON_SCHED_INFO_NODE_S   EMON_SCHED_INFO_NODE;
+typedef        EMON_SCHED_INFO_NODE     *EMON_SCHED_INFO;
+
+struct EMON_SCHED_INFO_NODE_S {
+     U32   max_counters_for_all_pmus;
+     U32   num_cpus;
+     U32   group_index[MAX_EMON_GROUPS];
+     U32   offset_for_next_device[MAX_EMON_GROUPS];
+     U32   device_id;
+     U32   num_packages;
+     U32   num_units;
+     U32   user_scheduled;
+     U64   reserved1;
+     U64   reserved2;
+     U64   reserved3;
+     U64   reserved4;
+};
+
+#define EMON_SCHED_INFO_max_counters_for_all_pmus(x)           (x)->max_counters_for_all_pmus
+#define EMON_SCHED_INFO_num_cpus(x)                            (x)->num_cpus
+#define EMON_SCHED_INFO_group_index(x,grp_num)                 (x)->group_index[grp_num]
+#define EMON_SCHED_INFO_offset_for_next_device(x, grp_num)     (x)->offset_for_next_device[grp_num]
+#define EMON_SCHED_INFO_device_id(x)                           (x)->device_id
+#define EMON_SCHED_INFO_num_packages(x)                        (x)->num_packages
+#define EMON_SCHED_INFO_num_units(x)                           (x)->num_units
+#define EMON_SCHED_INFO_user_scheduled(x)                      (x)->user_scheduled
+
+#define INITIALIZE_Emon_Sched_Info(x,j)                                                            \
+    for((j) =0; (j) < MAX_EMON_GROUPS; (j)++) {                                                    \
+        EMON_SCHED_INFO_group_index((x),(j))             = 0;                                      \
+        EMON_SCHED_INFO_offset_for_next_device((x), (j)) = 0;                                      \
+    }
+
+typedef struct PCIFUNC_INFO_NODE_S   PCIFUNC_INFO_NODE;
+typedef        PCIFUNC_INFO_NODE     *PCIFUNC_INFO;
+
+struct PCIFUNC_INFO_NODE_S {
+     U32   valid;
+     U32   num_entries;			// the number of entries found with same <dev_no, func_no> but difference bus_no.
+     U64   deviceId;
+     U64   reserved1;
+     U64   reserved2;
+};
+
+#define PCIFUNC_INFO_NODE_funcno(x)             (x)->funcno
+#define PCIFUNC_INFO_NODE_valid(x)              (x)->valid
+#define PCIFUNC_INFO_NODE_deviceId(x)           (x)->deviceId
+#define PCIFUNC_INFO_NODE_num_entries(x)        (x)->num_entries
+
+typedef struct PCIDEV_INFO_NODE_S   PCIDEV_INFO_NODE;
+typedef        PCIDEV_INFO_NODE     *PCIDEV_INFO;
+
+struct PCIDEV_INFO_NODE_S {
+     PCIFUNC_INFO_NODE   func_info[MAX_PCI_FUNCNO];
+     U32                 valid;
+     U32                 dispatch_id;
+     U64                 reserved1;
+     U64                 reserved2;
+};
+
+#define PCIDEV_INFO_NODE_func_info(x,i)        (x).func_info[i]
+#define PCIDEV_INFO_NODE_valid(x)              (x).valid
+
+
+typedef struct UNCORE_PCIDEV_NODE_S   UNCORE_PCIDEV_NODE;
+
+struct UNCORE_PCIDEV_NODE_S {
+    PCIDEV_INFO_NODE   pcidev[MAX_PCI_DEVNO];
+    U32                dispatch_id;
+    U32                scan;
+    U32                num_uncore_units;
+    U32                num_deviceid_entries;
+    U8                 dimm_device1;
+    U8                 dimm_device2;
+    U16                reserved1;
+    U32                reserved2;
+    U64                reserved3;
+    U64                reserved4;
+    U32                deviceid_list[MAX_PCI_DEVNO];
+};
+
+// Structure used to perform uncore device discovery
+
+typedef struct UNCORE_TOPOLOGY_INFO_NODE_S   UNCORE_TOPOLOGY_INFO_NODE;
+typedef        UNCORE_TOPOLOGY_INFO_NODE     *UNCORE_TOPOLOGY_INFO;
+
+struct UNCORE_TOPOLOGY_INFO_NODE_S {
+     UNCORE_PCIDEV_NODE              device[MAX_DEVICES];
+};
+
+#define UNCORE_TOPOLOGY_INFO_device(x, dev_index)                                             (x)->device[dev_index]
+#define UNCORE_TOPOLOGY_INFO_device_dispatch_id(x, dev_index)                                 (x)->device[dev_index].dispatch_id
+#define UNCORE_TOPOLOGY_INFO_device_scan(x, dev_index)                                        (x)->device[dev_index].scan
+#define UNCORE_TOPOLOGY_INFO_pcidev_valid(x, dev_index, devno)                                (x)->device[dev_index].pcidev[devno].valid
+#define UNCORE_TOPOLOGY_INFO_pcidev_dispatch_id(x, dev_index, devno)                          (x)->device[dev_index].pcidev[devno].dispatch_id
+#define UNCORE_TOPOLOGY_INFO_pcidev(x, dev_index, devno)                                      (x)->device[dev_index].pcidev[devno]
+#define UNCORE_TOPOLOGY_INFO_num_uncore_units(x, dev_index)                                   (x)->device[dev_index].num_uncore_units
+#define UNCORE_TOPOLOGY_INFO_num_deviceid_entries(x, dev_index)                               (x)->device[dev_index].num_deviceid_entries
+#define UNCORE_TOPOLOGY_INFO_dimm_device1(x, dev_index)                                       (x)->device[dev_index].dimm_device1
+#define UNCORE_TOPOLOGY_INFO_dimm_device2(x, dev_index)                                       (x)->device[dev_index].dimm_device2
+#define UNCORE_TOPOLOGY_INFO_deviceid(x, dev_index, deviceid_idx)                             (x)->device[dev_index].deviceid_list[deviceid_idx]
+#define UNCORE_TOPOLOGY_INFO_pcidev_set_funcno_valid(x, dev_index, devno, funcno)             ((x)->device[dev_index].pcidev[devno].func_info[funcno].valid = 1)
+#define UNCORE_TOPOLOGY_INFO_pcidev_is_found_in_platform(x, dev_index, devno, funcno)         ((x)->device[dev_index].pcidev[devno].func_info[funcno].num_entries)
+#define UNCORE_TOPOLOGY_INFO_pcidev_is_devno_funcno_valid(x, dev_index, devno, funcno)        ((x)->device[dev_index].pcidev[devno].func_info[funcno].valid ? TRUE : FALSE)
+#define UNCORE_TOPOLOGY_INFO_pcidev_is_device_found(x, dev_index, devno, funcno)              ((x)->device[dev_index].pcidev[devno].func_info[funcno].num_entries > 0)
+
+#define UNCORE_TOPOLOGY_INFO_pcidev_num_entries_found(x, dev_index, devno, funcno)              ((x)->device[dev_index].pcidev[devno].func_info[funcno].num_entries)
+
+typedef enum
+{
+    CORE_TOPOLOGY_NODE                = 0,
+    UNCORE_TOPOLOGY_NODE_IMC          = 1,
+    UNCORE_TOPOLOGY_NODE_UBOX         = 2,
+    UNCORE_TOPOLOGY_NODE_QPI          = 3,
+    MAX_TOPOLOGY_DEV                  = 4, // When you adding new topo node to this enum, make sue MAX_TOPOLOGY_DEV is always the last one.
+}   UNCORE_TOPOLOGY_NODE_INDEX_TYPE;
+
+typedef struct PLATFORM_TOPOLOGY_REG_NODE_S    PLATFORM_TOPOLOGY_REG_NODE;
+typedef        PLATFORM_TOPOLOGY_REG_NODE     *PLATFORM_TOPOLOGY_REG;
+
+struct PLATFORM_TOPOLOGY_REG_NODE_S {
+    U32 bus;
+    U32 device;
+    U32 function;
+    U32 reg_id;
+    U64 reg_mask;
+    U64 reg_value[MAX_PACKAGES];
+    U8  reg_type;
+    U8  device_valid;
+    U16 reserved1;
+    U32 reserved2;
+    U64 reserved3;
+    U64 reserved4;
+};
+
+#define PLATFORM_TOPOLOGY_REG_bus(x,i)                     (x)[(i)].bus
+#define PLATFORM_TOPOLOGY_REG_device(x,i)                  (x)[(i)].device
+#define PLATFORM_TOPOLOGY_REG_function(x,i)                (x)[(i)].function
+#define PLATFORM_TOPOLOGY_REG_reg_id(x,i)                  (x)[(i)].reg_id
+#define PLATFORM_TOPOLOGY_REG_reg_mask(x,i)                (x)[(i)].reg_mask
+#define PLATFORM_TOPOLOGY_REG_reg_type(x,i)                (x)[(i)].reg_type
+#define PLATFORM_TOPOLOGY_REG_device_valid(x,i)            (x)[(i)].device_valid
+#define PLATFORM_TOPOLOGY_REG_reg_value(x,i,package_no)    (x)[(i)].reg_value[package_no]
+
+typedef struct PLATFORM_TOPOLOGY_DISCOVERY_NODE_S    PLATFORM_TOPOLOGY_DISCOVERY_NODE;
+typedef        PLATFORM_TOPOLOGY_DISCOVERY_NODE     *PLATFORM_TOPOLOGY_DISCOVERY;
+
+struct PLATFORM_TOPOLOGY_DISCOVERY_NODE_S {
+    U32                         device_index;
+    U32                         device_id;
+    U32                         num_registers;
+    U8                          scope;
+    U8                          prog_valid;
+    U16                         reserved2;
+    U64                         reserved3;
+    U64                         reserved4;
+    U64                         reserved5;
+    PLATFORM_TOPOLOGY_REG_NODE  topology_regs[MAX_REGS];
+};
+
+//Structure used to discover the uncore device topology_device
+
+typedef struct PLATFORM_TOPOLOGY_PROG_NODE_S    PLATFORM_TOPOLOGY_PROG_NODE;
+typedef        PLATFORM_TOPOLOGY_PROG_NODE     *PLATFORM_TOPOLOGY_PROG;
+
+struct PLATFORM_TOPOLOGY_PROG_NODE_S {
+    U32                                  num_devices;
+    PLATFORM_TOPOLOGY_DISCOVERY_NODE     topology_device[MAX_TOPOLOGY_DEV];
+};
+
+#define PLATFORM_TOPOLOGY_PROG_num_devices(x)                                            (x)->num_devices
+#define PLATFORM_TOPOLOGY_PROG_topology_device(x, dev_index)                             (x)->topology_device[dev_index]
+#define PLATFORM_TOPOLOGY_PROG_topology_device_device_index(x, dev_index)                (x)->topology_device[dev_index].device_index
+#define PLATFORM_TOPOLOGY_PROG_topology_device_device_id(x, dev_index)                   (x)->topology_device[dev_index].device_id
+#define PLATFORM_TOPOLOGY_PROG_topology_device_scope(x, dev_index)                       (x)->topology_device[dev_index].scope
+#define PLATFORM_TOPOLOGY_PROG_topology_device_num_registers(x, dev_index)               (x)->topology_device[dev_index].num_registers
+#define PLATFORM_TOPOLOGY_PROG_topology_device_prog_valid(x, dev_index)                  (x)->topology_device[dev_index].prog_valid
+#define PLATFORM_TOPOLOGY_PROG_topology_topology_regs(x, dev_index)                      (x)->topology_device[dev_index].topology_regs
+
+typedef struct FPGA_GB_DISCOVERY_NODE_S         FPGA_GB_DISCOVERY_NODE;
+
+struct FPGA_GB_DISCOVERY_NODE_S {
+    U16                bar_num;
+    U16                feature_id;
+    U32                device_id;
+    U64                afu_id_l;
+    U64                afu_id_h;
+    U32                feature_offset;
+    U32                feature_len;
+    U8                 scan;
+    U8                 valid;
+    U16                reserved1;
+    U32                reserved2;
+};
+
+typedef struct FPGA_GB_DEV_NODE_S    FPGA_GB_DEV_NODE;
+typedef        FPGA_GB_DEV_NODE     *FPGA_GB_DEV;
+
+struct FPGA_GB_DEV_NODE_S {
+    U32                        num_devices;
+    FPGA_GB_DISCOVERY_NODE     fpga_gb_device[MAX_DEVICES];
+};
+
+#define FPGA_GB_DEV_num_devices(x)                                            (x)->num_devices
+#define FPGA_GB_DEV_device(x, dev_index)                                      (x)->fpga_gb_device[dev_index]
+#define FPGA_GB_DEV_bar_num(x, dev_index)                                     (x)->fpga_gb_device[dev_index].bar_num
+#define FPGA_GB_DEV_feature_id(x, dev_index)                                  (x)->fpga_gb_device[dev_index].feature_id
+#define FPGA_GB_DEV_device_id(x, dev_index)                                   (x)->fpga_gb_device[dev_index].device_id
+#define FPGA_GB_DEV_afu_id_low(x, dev_index)                                  (x)->fpga_gb_device[dev_index].afu_id_l
+#define FPGA_GB_DEV_afu_id_high(x, dev_index)                                 (x)->fpga_gb_device[dev_index].afu_id_h
+#define FPGA_GB_DEV_feature_offset(x, dev_index)                              (x)->fpga_gb_device[dev_index].feature_offset
+#define FPGA_GB_DEV_feature_len(x, dev_index)                                 (x)->fpga_gb_device[dev_index].feature_len
+#define FPGA_GB_DEV_scan(x, dev_index)                                        (x)->fpga_gb_device[dev_index].scan
+#define FPGA_GB_DEV_valid(x, dev_index)                                       (x)->fpga_gb_device[dev_index].valid
+
+typedef enum
+{
+    UNCORE_TOPOLOGY_INFO_NODE_IMC        =   0,
+    UNCORE_TOPOLOGY_INFO_NODE_QPILL      =   1,
+    UNCORE_TOPOLOGY_INFO_NODE_HA         =   2,
+    UNCORE_TOPOLOGY_INFO_NODE_R3         =   3,
+    UNCORE_TOPOLOGY_INFO_NODE_R2         =   4,
+    UNCORE_TOPOLOGY_INFO_NODE_IRP        =   5,
+    UNCORE_TOPOLOGY_INFO_NODE_IMC_UCLK   =   6,
+    UNCORE_TOPOLOGY_INFO_NODE_EDC_ECLK   =   7,
+    UNCORE_TOPOLOGY_INFO_NODE_EDC_UCLK   =   8,
+    UNCORE_TOPOLOGY_INFO_NODE_M2M        =   9,
+    UNCORE_TOPOLOGY_INFO_NODE_HFI_RXE    =   10,
+    UNCORE_TOPOLOGY_INFO_NODE_HFI_TXE    =   11,
+    UNCORE_TOPOLOGY_INFO_NODE_FPGA_CACHE =   12,
+    UNCORE_TOPOLOGY_INFO_NODE_FPGA_FAB   =   13,
+    UNCORE_TOPOLOGY_INFO_NODE_FPGA_THERMAL = 14,
+    UNCORE_TOPOLOGY_INFO_NODE_FPGA_POWER =   15,
+}   UNCORE_TOPOLOGY_INFO_NODE_INDEX_TYPE;
+
+
+typedef struct SIDEBAND_INFO_NODE_S  SIDEBAND_INFO_NODE;
+typedef        SIDEBAND_INFO_NODE   *SIDEBAND_INFO;
+
+struct SIDEBAND_INFO_NODE_S {
+    U32   tid;
+    U32   pid;
+    U64   tsc;
+};
+
+#define SIDEBAND_INFO_pid(x)              (x)->pid
+#define SIDEBAND_INFO_tid(x)              (x)->tid
+#define SIDEBAND_INFO_tsc(x)              (x)->tsc
+
+typedef struct SAMPLE_DROP_NODE_S   SAMPLE_DROP_NODE;
+typedef        SAMPLE_DROP_NODE     *SAMPLE_DROP;
+
+struct SAMPLE_DROP_NODE_S {
+     U32 os_id;
+     U32 cpu_id;
+     U32 sampled;
+     U32 dropped;
+};
+
+#define SAMPLE_DROP_os_id(x)                                            (x)->os_id
+#define SAMPLE_DROP_cpu_id(x)                                           (x)->cpu_id
+#define SAMPLE_DROP_sampled(x)                                          (x)->sampled
+#define SAMPLE_DROP_dropped(x)                                          (x)->dropped
+
+#define MAX_SAMPLE_DROP_NODES   20
+
+typedef struct SAMPLE_DROP_INFO_NODE_S   SAMPLE_DROP_INFO_NODE;
+typedef        SAMPLE_DROP_INFO_NODE     *SAMPLE_DROP_INFO;
+
+struct SAMPLE_DROP_INFO_NODE_S {
+    U32 size;
+    SAMPLE_DROP_NODE drop_info[MAX_SAMPLE_DROP_NODES];
+};
+
+#define SAMPLE_DROP_INFO_size(x)                                        (x)->size
+#define SAMPLE_DROP_INFO_drop_info(x, index)                            (x)->drop_info[index]
+
+#define IS_PEBS_SAMPLE_RECORD(sample_record)                     \
+    ((SAMPLE_RECORD_pid_rec_index(sample_record) == (U32)-1) &&  \
+     (SAMPLE_RECORD_tid(sample_record) == (U32)-1))
+
+typedef struct DRV_EVENT_MASK_NODE_S  DRV_EVENT_MASK_NODE;
+typedef        DRV_EVENT_MASK_NODE    *DRV_EVENT_MASK;
+
+struct DRV_EVENT_MASK_NODE_S {
+    U8 event_idx;    // 0 <= index < MAX_EVENTS
+    union {
+        U8 bitFields1;
+        struct {
+            U8 precise        : 1;
+            U8 lbr_capture    : 1;
+            U8 dear_capture   : 1;  // Indicates which events need to have additional registers read
+                                    // because they are DEAR events.
+            U8 iear_capture   : 1;  // Indicates which events need to have additional registers read
+                                    // because they are IEAR events.
+            U8 btb_capture    : 1;  // Indicates which events need to have additional registers read
+                                    // because they are BTB events.
+            U8 ipear_capture  : 1;  // Indicates which events need to have additional registers read
+                                    // because they are IPEAR events.
+            U8 uncore_capture : 1;
+            U8 branch         : 1;  // Indicates whether the event is related to branch opertion or
+                                    // not
+        } s1;
+    } u1;
+};
+
+#define DRV_EVENT_MASK_event_idx(d)             (d)->event_idx
+#define DRV_EVENT_MASK_bitFields1(d)            (d)->u1.bitFields1
+#define DRV_EVENT_MASK_precise(d)               (d)->u1.s1.precise
+#define DRV_EVENT_MASK_lbr_capture(d)           (d)->u1.s1.lbr_capture
+#define DRV_EVENT_MASK_dear_capture(d)          (d)->u1.s1.dear_capture
+#define DRV_EVENT_MASK_iear_capture(d)          (d)->u1.s1.iear_capture
+#define DRV_EVENT_MASK_btb_capture(d)           (d)->u1.s1.btb_capture
+#define DRV_EVENT_MASK_ipear_capture(d)         (d)->u1.s1.ipear_capture
+#define DRV_EVENT_MASK_uncore_capture(d)        (d)->u1.s1.uncore_capture
+#define DRV_EVENT_MASK_branch(d)                (d)->u1.s1.branch
+
+#define MAX_OVERFLOW_EVENTS 11    // This defines the maximum number of overflow events per interrupt.
+                                  // In order to reduce memory footprint, the value should be at least
+                                  // the number of fixed and general PMU registers.
+                                  // Sandybridge with HT off has 11 PMUs(3 fixed and 8 generic)
+
+typedef struct DRV_MASKS_NODE_S  DRV_MASKS_NODE;
+typedef        DRV_MASKS_NODE    *DRV_MASKS;
+
+/*
+ * @macro DRV_EVENT_MASK_NODE_S
+ * @brief
+ * The structure is used to store overflow events when handling PMU interrupt.
+ * This approach should be more efficient than checking all event masks
+ * if there are many events to be monitored
+ * and only a few events among them have overflow per interrupt.
+ */
+struct DRV_MASKS_NODE_S {
+    DRV_EVENT_MASK_NODE eventmasks[MAX_OVERFLOW_EVENTS];
+    U8 masks_num;               // 0 <= mask_num <= MAX_OVERFLOW_EVENTS
+    U8 padding;                 // data structure alignment
+};
+
+#define DRV_MASKS_masks_num(d)           (d)->masks_num
+#define DRV_MASKS_eventmasks(d)          (d)->eventmasks
+
+
+/*
+ *  VMM vendor information
+ */
+#define  KVM_SIGNATURE              "KVMKVMKVM\0\0\0"
+#define  XEN_SIGNATURE              "XenVMMXenVMM"
+#define  VMWARE_SIGNATURE           "VMwareVMware"
+#define  HYPERV_SIGNATURE           "Microsoft Hv"
+
+#define  DRV_VMM_UNKNOWN            0
+#define  DRV_VMM_INTEL              1
+#define  DRV_VMM_KVM                2
+#define  DRV_VMM_XEN                3
+#define  DRV_VMM_HYPERV             4
+#define  DRV_VMM_VMWARE             5
+
+/*
+ * @macro DRV_SETUP_INFO_NODE_S
+ * @brief
+ * This structure supports driver information such as NMI profiling mode.
+ */
+
+typedef struct DRV_SETUP_INFO_NODE_S  DRV_SETUP_INFO_NODE;
+typedef        DRV_SETUP_INFO_NODE   *DRV_SETUP_INFO;
+
+struct DRV_SETUP_INFO_NODE_S {
+    union {
+        U32      modes;
+        struct {
+            U32  nmi_mode            :1;
+            U32  vmm_mode            :1;
+            U32  vmm_vendor          :8;
+            U32  vmm_guest_vm        :1;
+            U32  pebs_accessible     :1;
+            U32  cpu_hotplug_mode    :1;
+            U32  matrix_inaccessible :1;
+            U32  page_table_isolation:2;
+            U32  pebs_ignored_by_pti :1;
+            U32  reserved1           :15;
+        }s1;
+    }u1;
+    U32 reserved2;
+    U64 reserved3;
+    U64 reserved4;
+};
+
+#define DRV_SETUP_INFO_nmi_mode(info)              (info)->u1.s1.nmi_mode
+#define DRV_SETUP_INFO_vmm_mode(info)              (info)->u1.s1.vmm_mode
+#define DRV_SETUP_INFO_vmm_vendor(info)            (info)->u1.s1.vmm_vendor
+#define DRV_SETUP_INFO_vmm_guest_vm(info)          (info)->u1.s1.vmm_guest_vm
+#define DRV_SETUP_INFO_pebs_accessible(info)       (info)->u1.s1.pebs_accessible
+#define DRV_SETUP_INFO_cpu_hotplug_mode(info)      (info)->u1.s1.cpu_hotplug_mode
+#define DRV_SETUP_INFO_matrix_inaccessible(info)   (info)->u1.s1.matrix_inaccessible
+#define DRV_SETUP_INFO_page_table_isolation(info)  (info)->u1.s1.page_table_isolation
+#define DRV_SETUP_INFO_pebs_ignored_by_pti(info)   (info)->u1.s1.pebs_ignored_by_pti
+
+#define DRV_SETUP_INFO_PTI_DISABLED    0
+#define DRV_SETUP_INFO_PTI_KPTI        1
+#define DRV_SETUP_INFO_PTI_KAISER      2
+#define DRV_SETUP_INFO_PTI_VA_SHADOW   3
+#define DRV_SETUP_INFO_PTI_UNKNOWN     4
+
+/*
+  Type: task_info_t
+  Description:
+      Represents the equivalent of a Linux Thread.
+  Fields:
+      o  id: A unique identifier. May be `NULL_TASK_ID`.
+      o  name: Human-readable name for this task
+      o  executable_name: Literal path to the binary elf that this task's
+              entry point is executing from.
+      o  address_space_id: The unique ID for the address space this task is
+              running in.
+  */
+struct task_info_node_s {
+    U64   id;
+    char  name[32];
+    U64   address_space_id;
+};
+
+/*
+  Type: REMOTE_SWITCH
+  Description:
+      Collection switch set on target
+*/
+typedef struct REMOTE_SWITCH_NODE_S   REMOTE_SWITCH_NODE;
+typedef        REMOTE_SWITCH_NODE    *REMOTE_SWITCH;
+
+struct REMOTE_SWITCH_NODE_S {
+    U32   auto_mode           : 1;
+    U32   adv_hotspot         : 1;
+    U32   lbr_callstack       : 2;
+    U32   full_pebs           : 1;
+    U32   uncore_supported    : 1;
+    U32   reserved1           : 26;
+    U32   reserved2;
+};
+
+
+/*
+  Type: REMOTE_OS_INFO
+  Description:
+      Remote target OS system information
+*/
+#define OSINFOLEN    64
+typedef struct REMOTE_OS_INFO_NODE_S   REMOTE_OS_INFO_NODE;
+typedef        REMOTE_OS_INFO_NODE    *REMOTE_OS_INFO;
+
+struct REMOTE_OS_INFO_NODE_S {
+    U32  os_family;
+    U32  reserved1;
+    S8   sysname[OSINFOLEN];
+    S8   release[OSINFOLEN];
+    S8   version[OSINFOLEN];
+};
+
+
+/*
+  Type: REMOTE_HARDWARE_INFO
+  Description:
+      Remote target hardware information
+*/
+typedef struct REMOTE_HARDWARE_INFO_NODE_S   REMOTE_HARDWARE_INFO_NODE;
+typedef        REMOTE_HARDWARE_INFO_NODE    *REMOTE_HARDWARE_INFO;
+
+struct REMOTE_HARDWARE_INFO_NODE_S {
+    U32  num_cpus;
+    U32  family;
+    U32  model;
+    U32  stepping;
+    U64  tsc_freq;
+    U64  reserved2;
+    U64  reserved3;
+};
+
+
+/*
+ ************************************
+ *  DRIVER LOG BUFFER DECLARATIONS  *
+ ************************************
+ */
+
+#define DRV_MAX_NB_LOG_CATEGORIES        256   // Must be a multiple of 8
+#define DRV_NB_LOG_CATEGORIES             14
+#define DRV_LOG_CATEGORY_LOAD              0
+#define DRV_LOG_CATEGORY_INIT              1
+#define DRV_LOG_CATEGORY_DETECTION         2
+#define DRV_LOG_CATEGORY_ERROR             3
+#define DRV_LOG_CATEGORY_STATE_CHANGE      4
+#define DRV_LOG_CATEGORY_MARK              5
+#define DRV_LOG_CATEGORY_DEBUG             6
+#define DRV_LOG_CATEGORY_FLOW              7
+#define DRV_LOG_CATEGORY_ALLOC             8
+#define DRV_LOG_CATEGORY_INTERRUPT         9
+#define DRV_LOG_CATEGORY_TRACE            10
+#define DRV_LOG_CATEGORY_REGISTER         11
+#define DRV_LOG_CATEGORY_NOTIFICATION     12
+#define DRV_LOG_CATEGORY_WARNING          13
+
+#define LOG_VERBOSITY_UNSET       0xFF
+#define LOG_VERBOSITY_DEFAULT     0xFE
+#define LOG_VERBOSITY_NONE           0
+
+#define LOG_CHANNEL_MEMLOG         0x1
+#define LOG_CHANNEL_AUXMEMLOG      0x2
+#define LOG_CHANNEL_PRINTK         0x4
+#define LOG_CHANNEL_TRACEK         0x8
+#define LOG_CHANNEL_MOSTWHERE     (LOG_CHANNEL_MEMLOG    |   \
+                                   LOG_CHANNEL_AUXMEMLOG |   \
+                                   LOG_CHANNEL_PRINTK)
+#define LOG_CHANNEL_EVERYWHERE    (LOG_CHANNEL_MEMLOG    |   \
+                                   LOG_CHANNEL_AUXMEMLOG |   \
+                                   LOG_CHANNEL_PRINTK    |   \
+                                   LOG_CHANNEL_TRACEK)
+#define LOG_CHANNEL_MASK           LOG_CATEGORY_VERBOSITY_EVERYWHERE
+
+#define LOG_CONTEXT_REGULAR        0x10
+#define LOG_CONTEXT_INTERRUPT      0x20
+#define LOG_CONTEXT_NOTIFICATION   0x40
+#define LOG_CONTEXT_ALL           (LOG_CONTEXT_REGULAR     |   \
+                                   LOG_CONTEXT_INTERRUPT   |   \
+                                   LOG_CONTEXT_NOTIFICATION)
+#define LOG_CONTEXT_MASK           LOG_CONTEXT_ALL
+#define LOG_CONTEXT_SHIFT          4
+
+#define DRV_LOG_NOTHING            0
+#define DRV_LOG_FLOW_IN            1
+#define DRV_LOG_FLOW_OUT           2
+
+
+/*
+ * @macro DRV_LOG_ENTRY_NODE_S
+ * @brief
+ * This structure is used to store a log message from the driver.
+ */
+
+#define DRV_LOG_MESSAGE_LENGTH       64
+#define DRV_LOG_FUNCTION_NAME_LENGTH 32
+
+typedef struct DRV_LOG_ENTRY_NODE_S  DRV_LOG_ENTRY_NODE;
+typedef        DRV_LOG_ENTRY_NODE   *DRV_LOG_ENTRY;
+struct DRV_LOG_ENTRY_NODE_S {
+
+    char function_name[DRV_LOG_FUNCTION_NAME_LENGTH];
+    char message      [DRV_LOG_MESSAGE_LENGTH];
+
+    U16  temporal_tag;
+    U16  integrity_tag;
+
+    U8   category;
+    U8   secondary_info;          // Secondary attribute:
+                                  // former driver state for STATE category
+                                  // 'ENTER' or 'LEAVE' for FLOW and TRACE categories
+    U16  processor_id;            // NB: not guaranteed to be accurate (due to preemption / core migration)
+
+    U64  tsc;
+
+    U16  nb_active_interrupts;    // never 100% accurate, merely indicative
+    U8   active_drv_operation;    // only 100% accurate for IOCTL-called functions
+    U8   driver_state;
+
+    U16  line_number;             // as per the __LINE__ macro
+
+    U16  nb_active_notifications;
+
+    U64  reserved;               // need padding to reach 128 bytes
+}; // this structure should be exactly 128-byte long
+
+#define DRV_LOG_ENTRY_temporal_tag(ent)            (ent)->temporal_tag
+#define DRV_LOG_ENTRY_integrity_tag(ent)           (ent)->integrity_tag
+#define DRV_LOG_ENTRY_category(ent)                (ent)->category
+#define DRV_LOG_ENTRY_secondary_info(ent)          (ent)->secondary_info
+#define DRV_LOG_ENTRY_processor_id(ent)            (ent)->processor_id
+#define DRV_LOG_ENTRY_tsc(ent)                     (ent)->tsc
+#define DRV_LOG_ENTRY_driver_state(ent)            (ent)->driver_state
+#define DRV_LOG_ENTRY_active_drv_operation(ent)    (ent)->active_drv_operation
+#define DRV_LOG_ENTRY_nb_active_interrupts(ent)    (ent)->nb_active_interrupts
+#define DRV_LOG_ENTRY_nb_active_notifications(ent) (ent)->nb_active_notifications
+#define DRV_LOG_ENTRY_line_number(ent)             (ent)->line_number
+#define DRV_LOG_ENTRY_message(ent)                 (ent)->message
+#define DRV_LOG_ENTRY_function_name(ent)           (ent)->function_name
+
+
+/*
+ * @macro DRV_LOG_BUFFER_NODE_S
+ * @brief
+ * Circular buffer structure storing the latest DRV_LOG_MAX_NB_ENTRIES driver messages
+ */
+
+#define DRV_LOG_SIGNATURE_SIZE        8                    // Must be a multiple of 8
+#define DRV_LOG_SIGNATURE_0          'S'
+#define DRV_LOG_SIGNATURE_1          'e'
+#define DRV_LOG_SIGNATURE_2          'P'
+#define DRV_LOG_SIGNATURE_3          'd'
+#define DRV_LOG_SIGNATURE_4          'R'
+#define DRV_LOG_SIGNATURE_5          'v'
+#define DRV_LOG_SIGNATURE_6          '4'
+#define DRV_LOG_SIGNATURE_7          '\0'
+// The signature is "SePdRv4"; not declared as string on purpose to avoid false positives when trying to identify the log buffer in a crash dump
+
+#define DRV_LOG_VERSION               1
+#define DRV_LOG_FILLER_BYTE           1
+
+#define DRV_LOG_DRIVER_VERSION_SIZE   64                   // Must be a multiple of 8
+#define DRV_LOG_MAX_NB_PRI_ENTRIES   (8192 * 2)            // 2MB buffer [*HAS TO BE* a power of 2!] [8192 entries = 1 MB]
+#define DRV_LOG_MAX_NB_AUX_ENTRIES   (8192)                // 1MB buffer [*HAS TO BE* a power of 2!]
+#define DRV_LOG_MAX_NB_ENTRIES       (DRV_LOG_MAX_NB_PRI_ENTRIES + DRV_LOG_MAX_NB_AUX_ENTRIES)
+
+typedef struct DRV_LOG_BUFFER_NODE_S  DRV_LOG_BUFFER_NODE;
+typedef        DRV_LOG_BUFFER_NODE   *DRV_LOG_BUFFER;
+struct DRV_LOG_BUFFER_NODE_S {
+
+    char      header_signature[DRV_LOG_SIGNATURE_SIZE]; // some signature to be able to locate the log even without -g; ASCII would help
+                                                        // should we change the signature for each log's version instead of keeping it in a
+                                                        // dedicated field?
+
+    U32       log_size;                                // filled with sizeof(this structure) at init.
+    U32       max_nb_pri_entries;                      // filled with the driver's "DRV_LOG_MAX_NB_PRIM_ENTRIES" at init.
+
+    U32       max_nb_aux_entries;                      // filled with the driver's "DRV_LOG_MAX_NB_AUX_ENTRIES" at init.
+    U32       reserved1;
+
+    U64       init_time;                               // primary log disambiguator
+
+    U32       disambiguator;                           // used to differentiate the driver's version of the log when a full memory dump can contain some from userland
+    U32       log_version;                             // 0 at first, increase when format changes?
+
+    U32       pri_entry_index;                         // should be incremented *atomically* as a means to (re)allocate the next primary log entry.
+    U32       aux_entry_index;                         // should be incremented *atomically* as a means to (re)allocate the next auxiliary log entry.
+
+    char      driver_version[DRV_LOG_DRIVER_VERSION_SIZE];
+
+    U8        driver_state;
+    U8        active_drv_operation;
+    U16       reserved2;
+    U32       nb_drv_operations;
+
+    U32       nb_interrupts;
+    U16       nb_active_interrupts;
+    U16       nb_active_notifications;
+
+    U32       nb_notifications;
+    U32       nb_driver_state_transitions;
+
+    U8        contiguous_physical_memory;
+    U8        reserved3;
+    U16       reserved4;
+    U32       reserved5;
+
+    U8        verbosities[DRV_MAX_NB_LOG_CATEGORIES];
+
+    DRV_LOG_ENTRY_NODE entries[DRV_LOG_MAX_NB_ENTRIES];
+
+    char      footer_signature[DRV_LOG_SIGNATURE_SIZE];
+};
+
+#define DRV_LOG_BUFFER_pri_entry_index(log)             (log)->pri_entry_index
+#define DRV_LOG_BUFFER_aux_entry_index(log)             (log)->aux_entry_index
+#define DRV_LOG_BUFFER_header_signature(log)            (log)->header_signature
+#define DRV_LOG_BUFFER_footer_signature(log)            (log)->footer_signature
+#define DRV_LOG_BUFFER_log_size(log)                    (log)->log_size
+#define DRV_LOG_BUFFER_driver_version(log)              (log)->driver_version
+#define DRV_LOG_BUFFER_driver_state(log)                (log)->driver_state
+#define DRV_LOG_BUFFER_active_drv_operation(log)        (log)->active_drv_operation
+#define DRV_LOG_BUFFER_nb_interrupts(log)               (log)->nb_interrupts
+#define DRV_LOG_BUFFER_nb_active_interrupts(log)        (log)->nb_active_interrupts
+#define DRV_LOG_BUFFER_nb_notifications(log)            (log)->nb_notifications
+#define DRV_LOG_BUFFER_nb_active_notifications(log)     (log)->nb_active_notifications
+#define DRV_LOG_BUFFER_nb_driver_state_transitions(log) (log)->nb_driver_state_transitions
+#define DRV_LOG_BUFFER_nb_drv_operations(log)           (log)->nb_drv_operations
+#define DRV_LOG_BUFFER_max_nb_pri_entries(log)          (log)->max_nb_pri_entries
+#define DRV_LOG_BUFFER_max_nb_aux_entries(log)          (log)->max_nb_aux_entries
+#define DRV_LOG_BUFFER_init_time(log)                   (log)->init_time
+#define DRV_LOG_BUFFER_disambiguator(log)               (log)->disambiguator
+#define DRV_LOG_BUFFER_log_version(log)                 (log)->log_version
+#define DRV_LOG_BUFFER_entries(log)                     (log)->entries
+#define DRV_LOG_BUFFER_contiguous_physical_memory(log)  (log)->contiguous_physical_memory
+#define DRV_LOG_BUFFER_verbosities(log)                 (log)->verbosities
+
+
+#define DRV_LOG_CONTROL_MAX_DATA_SIZE   DRV_MAX_NB_LOG_CATEGORIES   // Must be a multiple of 8
+
+typedef struct DRV_LOG_CONTROL_NODE_S   DRV_LOG_CONTROL_NODE;
+typedef        DRV_LOG_CONTROL_NODE    *DRV_LOG_CONTROL;
+
+struct DRV_LOG_CONTROL_NODE_S {
+     U32   command;
+     U32   reserved1;
+     U8    data[DRV_LOG_CONTROL_MAX_DATA_SIZE];     // only DRV_NB_LOG_CATEGORIES elements will be used, but let's plan for backwards compatibility
+                                                    // if LOG_CATEGORY_UNSET, then READ instead of WRITE
+
+     U64   reserved2;                               // may later want to add support for resizing the buffer, or only log 100 first interrupts, etc.
+     U64   reserved3;
+     U64   reserved4;
+     U64   reserved5;
+};
+
+#define DRV_LOG_CONTROL_command(x)              (x)->command
+#define DRV_LOG_CONTROL_verbosities(x)          (x)->data
+#define DRV_LOG_CONTROL_message(x)              (x)->data   // Userland 'MARK' messages use the 'data' field too.
+#define DRV_LOG_CONTROL_log_size(x)             (*((U32*)((x)->data)))
+
+#define DRV_LOG_CONTROL_COMMAND_NONE             0
+#define DRV_LOG_CONTROL_COMMAND_ADJUST_VERBOSITY 1
+#define DRV_LOG_CONTROL_COMMAND_MARK             2
+#define DRV_LOG_CONTROL_COMMAND_QUERY_SIZE       3
+#define DRV_LOG_CONTROL_COMMAND_BENCHMARK        4
+
+
+#endif
+
diff --git a/drivers/misc/intel/soc_perf/include/lwpmudrv_types.h b/drivers/misc/intel/soc_perf/include/lwpmudrv_types.h
new file mode 100644
index 000000000000..6b6d82b18cd2
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/include/lwpmudrv_types.h
@@ -0,0 +1,139 @@
+/***
+ * -------------------------------------------------------------------------
+ *               INTEL CORPORATION PROPRIETARY INFORMATION
+ *  This software is supplied under the terms of the accompanying license
+ *  agreement or nondisclosure agreement with Intel Corporation and may not
+ *  be copied or disclosed except in accordance with the terms of that
+ *  agreement.
+ *        Copyright(C) 2007-2018 Intel Corporation.  All Rights Reserved.
+ * -------------------------------------------------------------------------
+***/
+
+#ifndef _LWPMUDRV_TYPES_H_
+#define _LWPMUDRV_TYPES_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+typedef unsigned char       U8;
+typedef          char       S8;
+typedef          short      S16;
+typedef unsigned short      U16;
+typedef unsigned int        U32;
+typedef          int        S32;
+#if defined(DRV_OS_WINDOWS)
+typedef unsigned __int64    U64;
+typedef          __int64    S64;
+#elif defined (DRV_OS_LINUX) || defined(DRV_OS_SOLARIS) || defined(DRV_OS_MAC) || defined (DRV_OS_ANDROID) || defined(DRV_OS_FREEBSD)
+typedef unsigned long long  U64;
+typedef          long long  S64;
+typedef unsigned long       ULONG;
+typedef          void       VOID;
+typedef          void*      LPVOID;
+#else
+#error "Undefined OS"
+#endif
+
+#if defined(DRV_IA32)
+typedef S32                 SIOP;
+typedef U32                 UIOP;
+#elif defined(DRV_EM64T)
+typedef S64                 SIOP;
+typedef U64                 UIOP;
+#else
+#error "Unexpected Architecture seen"
+#endif
+
+typedef U32                 DRV_BOOL;
+typedef void*               PVOID;
+
+#if !defined(__DEFINE_STCHAR__)
+#define __DEFINE_STCHAR__
+#if defined(UNICODE)
+typedef wchar_t             STCHAR;
+#define VTSA_T(x)           L ## x
+#else
+typedef char                STCHAR;
+#define VTSA_T(x)           x
+#endif
+#endif
+
+#if defined(DRV_OS_WINDOWS)
+#include <wchar.h>
+typedef   wchar_t           DRV_STCHAR;
+typedef   wchar_t           VTSA_CHAR;
+#else
+typedef   char              DRV_STCHAR;
+#endif
+
+//
+// Handy Defines
+//
+typedef   U32                             DRV_STATUS;
+
+#define   MAX_STRING_LENGTH             1024
+#define   MAXNAMELEN                     256
+
+#if defined(DRV_OS_WINDOWS)
+#define   UNLINK                        _unlink
+#define   RENAME                        rename
+#define   WCSDUP                        _wcsdup
+#endif
+#if defined(DRV_OS_LINUX) || defined(DRV_OS_SOLARIS) || defined(DRV_OS_MAC) || defined (DRV_OS_ANDROID) || defined(DRV_OS_FREEBSD)
+#define   UNLINK                        unlink
+#define   RENAME                        rename
+#endif
+
+#if defined(DRV_OS_SOLARIS) && !defined(_KERNEL)
+//wcsdup is missing on Solaris
+#include <stdlib.h>
+#include <wchar.h>
+
+static inline wchar_t* solaris_wcsdup(const wchar_t *wc)
+{
+	wchar_t *tmp = (wchar_t *)malloc((wcslen(wc) + 1) * sizeof(wchar_t));
+	wcscpy(tmp, wc);
+	return tmp;
+}
+#define   WCSDUP                        solaris_wcsdup
+#endif
+
+#if defined(DRV_OS_LINUX) || defined(DRV_OS_FREEBSD) || defined(DRV_OS_MAC)
+#define   WCSDUP                        wcsdup
+#endif
+
+#if !defined(_WCHAR_T_DEFINED)
+#if defined(DRV_OS_LINUX) || defined(DRV_OS_ANDROID) || defined(DRV_OS_SOLARIS)
+#if !defined(_GNU_SOURCE)
+#define _GNU_SOURCE
+#endif
+#endif
+#endif
+
+#if (defined(DRV_OS_LINUX) || defined(DRV_OS_ANDROID)) && !defined(__KERNEL__)
+#include <wchar.h>
+typedef wchar_t VTSA_CHAR;
+#endif
+
+#if (defined(DRV_OS_MAC) || defined(DRV_OS_FREEBSD) || defined(DRV_OS_SOLARIS)) && !defined(_KERNEL)
+#include <wchar.h>
+typedef wchar_t VTSA_CHAR;
+#endif
+
+
+#define   TRUE                          1
+#define   FALSE                         0
+
+#define ALIGN_4(x)    (((x) +  3) &  ~3)
+#define ALIGN_8(x)    (((x) +  7) &  ~7)
+#define ALIGN_16(x)   (((x) + 15) & ~15)
+#define ALIGN_32(x)   (((x) + 31) & ~31)
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
+
diff --git a/drivers/misc/intel/soc_perf/include/lwpmudrv_version.h b/drivers/misc/intel/soc_perf/include/lwpmudrv_version.h
new file mode 100644
index 000000000000..efc54926b9fc
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/include/lwpmudrv_version.h
@@ -0,0 +1,148 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2010-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2010-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+/*
+ *  File  : lwpmudrv_version.h
+ */
+
+#ifndef _LWPMUDRV_VERSION_H_
+#define _LWPMUDRV_VERSION_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/*
+ * @macro SOCPERF_VERSION_NODE_S
+ * @brief
+ * This structure supports versioning in Sep. The field major indicates the major version,
+ * minor indicates the minor version and api indicates the api version for the current
+ * sep build. This structure is initialized at the time when the driver is loaded.
+ */
+
+typedef struct SOCPERF_VERSION_NODE_S  SOCPERF_VERSION_NODE;
+typedef        SOCPERF_VERSION_NODE   *SOCPERF_VERSION;
+
+struct SOCPERF_VERSION_NODE_S {
+    union {
+        U32      socperf_version;
+        struct {
+            S32  major :8;
+            S32  minor :8;
+            S32  api   :8;
+            S32  update:8;
+        }s1;
+    }u1;
+};
+
+#define SOCPERF_VERSION_NODE_socperf_version(version) (version)->u1.socperf_version
+#define SOCPERF_VERSION_NODE_major(version)           (version)->u1.s1.major
+#define SOCPERF_VERSION_NODE_minor(version)           (version)->u1.s1.minor
+#define SOCPERF_VERSION_NODE_api(version)             (version)->u1.s1.api
+#define SEP_VERSION_NODE_update(version)      (version)->u1.s1.update
+
+#if defined(__cplusplus)
+}
+#endif
+
+// SOCPERF VERSIONING
+
+#define _STRINGIFY(x)     #x
+#define STRINGIFY(x)      _STRINGIFY(x)
+#define _STRINGIFY_W(x)   L#x
+#define STRINGIFY_W(x)    _STRINGIFY_W(x)
+
+#define SOCPERF_MAJOR_VERSION  2
+#define SOCPERF_MINOR_VERSION  0
+#define SOCPERF_API_VERSION    0
+#define SOCPERF_UPDATE_VERSION 0
+#if SOCPERF_UPDATE_VERSION > 0
+#define SOCPERF_UPDATE_STRING  " Update "STRINGIFY(SOCPERF_UPDATE_VERSION)
+#else
+#define SOCPERF_UPDATE_STRING  ""
+#endif
+
+#define SOCPERF_PRODUCT_NAME  "Sampling Enabling Product"
+#define PRODUCT_VERSION_DATE    __DATE__ " at " __TIME__
+#define PRODUCT_COPYRIGHT   "Copyright (C) 2011-2018 Intel Corporation. All rights reserved."
+#define PRODUCT_DISCLAIMER  "Warning: This computer program is protected under U.S. and international\ncopyright laws, and may only be used or copied in accordance with the terms\nof the license agreement. Except as permitted by such license, no part\nof this computer program may be reproduced, stored in a retrieval system,\nor transmitted in any form or by any means without the express written consent\nof Intel Corporation."
+#define PRODUCT_VERSION     "4.1"
+
+#define SOCPERF_NAME          "socperf"
+#define SOCPERF_NAME_W        L"socperf"
+
+#define SOCPERF_MSG_PREFIX    SOCPERF_NAME""STRINGIFY(SOCPERF_MAJOR_VERSION)"_"STRINGIFY(SOCPERF_MINOR_VERSION)":"
+#define SOCPERF_VERSION_STR   STRINGIFY(SOCPERF_MAJOR_VERSION)"."STRINGIFY(SOCPERF_MINOR_VERSION)"."STRINGIFY(SOCPERF_API_VERSION)
+
+#if defined(DRV_OS_WINDOWS)
+#define SOCPERF_DRIVER_NAME   SOCPERF_NAME STRINGIFY(SOCPERF_MAJOR_VERSION)"_"STRINGIFY(SOCPERF_MINOR_VERSION)
+#define SOCPERF_DRIVER_NAME_W SOCPERF_NAME_W STRINGIFY_W(SOCPERF_MAJOR_VERSION) L"_" STRINGIFY_W(SOCPERF_MINOR_VERSION)
+#define SOCPERF_DEVICE_NAME   SOCPERF_DRIVER_NAME
+#endif
+
+#if defined(DRV_OS_LINUX) || defined(DRV_OS_SOLARIS) || defined(DRV_OS_ANDROID) || defined(DRV_OS_FREEBSD)
+#define SOCPERF_DRIVER_NAME   SOCPERF_NAME""STRINGIFY(SOCPERF_MAJOR_VERSION)"_"STRINGIFY(SOCPERF_MINOR_VERSION)
+#define SOCPERF_SAMPLES_NAME  SOCPERF_DRIVER_NAME"_s"
+#define SOCPERF_DEVICE_NAME   "/dev/"SOCPERF_DRIVER_NAME
+#endif
+
+#if defined(DRV_OS_MAC)
+#define SOCPERF_DRIVER_NAME   SOCPERF_NAME""STRINGIFY(SOCPERF_MAJOR_VERSION)"_"STRINGIFY(SOCPERF_MINOR_VERSION)
+#define SOCPERF_SAMPLES_NAME  SOCPERF_DRIVER_NAME"_s"
+#define SOCPERF_DEVICE_NAME   SOCPERF_DRIVER_NAME
+#endif
+
+#endif
diff --git a/drivers/misc/intel/soc_perf/include/rise_errors.h b/drivers/misc/intel/soc_perf/include/rise_errors.h
new file mode 100644
index 000000000000..15998ef5c014
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/include/rise_errors.h
@@ -0,0 +1,328 @@
+/***
+ * -------------------------------------------------------------------------
+ *               INTEL CORPORATION PROPRIETARY INFORMATION
+ *  This software is supplied under the terms of the accompanying license
+ *  agreement or nondisclosure agreement with Intel Corporation and may not
+ *  be copied or disclosed except in accordance with the terms of that
+ *  agreement.
+ *        Copyright(C) 2004-2018 Intel Corporation.  All Rights Reserved.
+ * -------------------------------------------------------------------------
+***/
+
+#ifndef _RISE_ERRORS_H_
+#define _RISE_ERRORS_H_
+
+//
+// NOTE:
+//
+// 1) Before adding an error code, first make sure the error code doesn't
+// already exist. If it does, use that, don't create a new one just because...
+//
+// 2) When adding an error code, add it to the end of the list. Don't insert
+// error numbers in the middle of the list! For backwards compatibility,
+// we don't want the numbers changing unless we really need them
+// to for some reason (like we want to switch to negative error numbers)
+//
+// 3) Change the VT_LAST_ERROR_CODE macro to point to the (newly added)
+// last error. This is done so SW can verify the number of error codes
+// possible matches the number of error strings it has
+//
+// 4) Don't forget to update the error string table to include your
+// error code (rise.c). Since the goal is something human readable
+// you don't need to use abbreviations in there (ie. don't say "bad param",
+// say "bad parameter" or "illegal parameter passed in")
+//
+// 5) Compile and run the test_rise app (in the test_rise directory) to
+// verify things are still working
+//
+//
+
+#define VT_SUCCESS                             0
+
+/*************************************************************/
+
+#define VT_INVALID_MAX_SAMP                    1
+#define VT_INVALID_SAMP_PER_BUFF               2
+#define VT_INVALID_SAMP_INTERVAL               3
+#define VT_INVALID_PATH                        4
+#define VT_TB5_IN_USE                          5
+#define VT_INVALID_NUM_EVENTS                  6
+#define VT_INTERNAL_ERROR                      8
+#define VT_BAD_EVENT_NAME                      9
+#define VT_NO_SAMP_SESSION                     10
+#define VT_NO_EVENTS                           11
+#define VT_MULTIPLE_RUNS                       12
+#define VT_NO_SAM_PARAMS                       13
+#define VT_SDB_ALREADY_EXISTS                  14
+#define VT_SAMPLING_ALREADY_STARTED            15
+#define VT_TBS_NOT_SUPPORTED                   16
+#define VT_INVALID_SAMPARAMS_SIZE              17
+#define VT_INVALID_EVENT_SIZE                  18
+#define VT_ALREADY_PROCESSES                   19
+#define VT_INVALID_EVENTS_PATH                 20
+#define VT_INVALID_LICENSE                     21
+
+/******************************************************/
+//SEP error codes
+
+#define VT_SAM_ERROR                           22
+#define VT_SAMPLE_FILE_ALREADY_MAPPED          23
+#define VT_INVALID_SAMPLE_FILE                 24
+#define VT_UNKNOWN_SECTION_NUMBER              25
+#define VT_NO_MEMORY                           26
+#define VT_ENV_VAR_NOT_FOUND                   27
+#define VT_SAMPLE_FILE_NOT_MAPPED              28
+#define VT_BUFFER_OVERFLOW                     29
+#define VT_USER_OP_COMPLETED                   30
+#define VT_BINARY_NOT_FOUND                    31
+#define VT_ISM_NOT_INITIALIZED                 32
+#define VT_NO_SYMBOLS                          33
+#define VT_SAMPLE_FILE_MAPPING_ERROR           34
+#define VT_BUFFER_NULL                         35
+#define VT_UNEXPECTED_NULL_PTR                 36
+#define VT_BINARY_LOAD_FAILED                  37
+#define VT_FUNCTION_NOT_FOUND_IN_BINARY        38
+#define VT_ENTRY_NOT_FOUND                     39
+#define VT_SEP_SYNTAX_ERROR                    40
+#define VT_SEP_OPTIONS_ERROR                   41
+#define VT_BAD_EVENT_MODIFIER                  42
+#define VT_INCOMPATIBLE_PARAMS                 43
+#define VT_FILE_OPEN_FAILED                    44
+#define VT_EARLY_EXIT                          45
+#define VT_TIMEOUT_RETURN                      46
+#define VT_NO_CHILD_PROCESS                    47
+#define VT_DRIVER_RUNNING                      48
+#define VT_DRIVER_STOPPED                      49
+#define VT_MULTIPLE_RUNS_NEEDED                50
+#define VT_QUIT_IMMEDIATE                      51
+#define VT_DRIVER_INIT_FAILED                  52
+#define VT_NO_TB5_CREATED                      53
+#define VT_NO_WRITE_PERMISSION                 54
+#define VT_DSA_INIT_FAILED                     55
+#define VT_INVALID_CPU_MASK                    56
+#define VT_SAMP_IN_RUNNING_STATE               57
+#define VT_SAMP_IN_PAUSE_STATE                 58
+#define VT_SAMP_IN_STOP_STATE                  59
+#define VT_SAMP_NO_SESSION                     60
+#define VT_NOT_CONFIGURED                      61
+#define VT_LAUNCH_BUILD64_FAILED               62
+#define VT_BAD_PARAMETER                       63
+#define VT_ISM_INIT_FAILED                     64
+#define VT_INVALID_STATE_TRANS                 65
+#define VT_EARLY_EXIT_N_CANCEL                 66
+#define VT_EVT_MGR_NOT_INIT                    67
+#define VT_ISM_SECTION_ENUM_FAILED             68
+#define VT_VG_PARSER_ERROR                     69
+#define VT_MISSING_VALUE_FOR_TOKEN             70
+#define VT_EMPTY_SAMPLE_FILE_NAME              71
+#define VT_UNEXPECTED_VALUE                    72
+#define VT_NOT_IMPLEMENTED                     73
+#define VT_MISSING_COL_DEPNDNCIES              74
+#define VT_DEP_COL_NOT_LIB_DEFINED             75
+#define VT_COL_NOT_REG_WITH_LIB                76
+#define VT_SECTION_ALREADY_IN_USE              77
+#define VT_SECTION_NOT_EXIST                   78
+#define VT_STREAM_NOT_EXIST                    79
+#define VT_INVALID_STREAM                      80
+#define VT_STREAM_ALREADY_IN_USE               81
+#define VT_DATA_DESC_NOT_EXIST                 82
+#define VT_INVALID_ERROR_CODE                  83
+#define VT_INCOMPATIBLE_VERSION                84
+#define VT_LEGACY_DATA_NOT_EXIST               85
+#define VT_INVALID_READ_START                  86
+#define VT_DRIVER_OPEN_FAILED                  87
+#define VT_DRIVER_IOCTL_FAILED                 88
+#define VT_SAMP_FILE_CREATE_FAILED             89
+#define VT_MODULE_FILE_CREATE_FAILED           90
+#define VT_INVALID_SAMPLE_FILE_NAME            91
+#define VT_INVALID_MODULE_FILE_NAME            92
+#define VT_FORK_CHILD_PROCESS_FAILED           93
+#define VT_UNEXPECTED_MISMATCH_IN_STRING_TYPES 94
+#define VT_INCOMPLETE_TB5_ENCOUNTERED          95
+#define VT_ERR_CONVERSION_FROM_STRING_2_NUMBER 96
+#define VT_INVALID_STRING                      97
+#define VT_UNSUPPORTED_DATA_SIZE               98
+#define VT_TBRW_INIT_FAILED                    99
+#define VT_PLUGIN_UNLOAD                       100
+#define VT_PLUGIN_ENTRY_NULL                   101
+#define VT_UNKNOWN_PLUGIN                      102
+#define VT_BUFFER_TOO_SMALL                    103
+#define VT_CANNOT_MODIFY_COLUMN                104
+#define VT_MULT_FILTERS_NOT_ALLOWED            105
+#define VT_ADDRESS_IN_USE                      106
+#define VT_NO_MORE_MMAPS                       107
+#define VT_MAX_PAGES_IN_DS_EXCEEDED            108
+#define VT_INVALID_COL_TYPE_IN_GROUP_INFO      109
+#define VT_AGG_FN_ON_VARCHAR_NOT_SUPP          110
+#define VT_INVALID_ACCESS_PERMS                111
+#define VT_NO_DATA_TO_DISPLAY                  112
+#define VT_TB5_IS_NOT_BOUND                    113
+#define VT_MISSING_GROUP_BY_COLUMN             114
+#define VT_SMRK_MAX_STREAMS_EXCEEDED           115
+#define VT_SMRK_STREAM_NOT_CREATED             116
+#define VT_SMRK_NOT_IMPL                       117
+#define VT_SMRK_TYPE_NOT_IMPL                  118
+#define VT_SMRK_TYPE_ALREADY_SET               119
+#define VT_SMRK_NO_STREAM                      120
+#define VT_SMRK_INVALID_STREAM_TYPE            121
+#define VT_SMRK_STREAM_NOT_FOUND               122
+#define VT_SMRK_FAIL                           123
+#define VT_SECTION_NOT_READABLE                124
+#define VT_SECTION_NOT_WRITEABLE               125
+#define VT_GLOBAL_SECTION_NOT_CLOSED           126
+#define VT_STREAM_SECTION_NOT_CLOSED           127
+#define VT_STREAM_NOT_CLOSED                   128
+#define VT_STREAM_NOT_BOUND                    129
+#define VT_NO_COLS_SPECIFIED                   130
+#define VT_NOT_ALL_SECTIONS_CLOSED             131
+#define VT_SMRK_INVALID_PTR                    132
+#define VT_UNEXPECTED_BIND_MISMATCH            133
+#define VT_WIN_TIMER_ERROR                     134
+#define VT_ONLY_SNGL_DEPNDT_COL_ALLWD          135
+#define VT_BAD_MODULE                          136
+#define VT_INPUT_SOURCE_INFO_NOT_SET           137
+#define VT_UNSUPPORTED_TIME_GRAN               138
+#define VT_NO_SAMPLES_COLLECTED                139
+#define VT_INVALID_CPU_TYPE_VERSION            140
+#define VT_BIND_UNEXPECTED_1STMODREC           141
+#define VT_BIND_MODULES_NOT_SORTED             142
+#define VT_UNEXPECTED_NUM_CPUIDS               143
+#define VT_UNSUPPORTED_ARCH_TYPE               144
+#define VT_NO_DATA_TO_WRITE                    145
+#define VT_EM_TIME_SLICE_TOO_SMALL             146
+#define VT_EM_TOO_MANY_EVENT_GROUPS            147
+#define VT_EM_ZERO_GROUPS                      148
+#define VT_EM_NOT_SUPPORTED                    149
+#define VT_PMU_IN_USE                          150
+#define VT_TOO_MANY_INTERRUPTS                 151
+#define VT_MAX_SAMPLES_REACHED                 152
+#define VT_MODULE_COLLECTION_FAILED            153
+#define VT_INCOMPATIBLE_DRIVER                 154
+#define VT_UNABLE_LOCATE_TRIGGER_EVENT         155
+#define VT_COMMAND_NOT_HANDLED                 156
+#define VT_DRIVER_VERSION_MISMATCH             157
+#define VT_MAX_MARKERS                         158
+#define VT_DRIVER_COMM_FAILED                  159
+#define VT_CHIPSET_CONFIG_FAILED               160
+#define VT_BAD_DATA_BASE                       161
+#define VT_PAX_SERVICE_NOT_CONNECTED           162
+#define VT_PAX_SERVICE_ERROR                   163
+#define VT_PAX_PMU_RESERVE_FAILED              164
+#define VT_INVALID_CPU_INFO_TYPE               165
+#define VT_CACHE_DOESNT_EXIST                  166
+#define VT_UNSUPPORTED_UNCORE_ARCH_TYPE        167
+#define VT_EXCEEDED_MAX_EVENTS                 168
+#define VT_MARKER_TIMER_FAILED                 169
+#define VT_PAX_PMU_UNRESERVE_FAILED            170
+#define VT_MULTIPLE_PROCESSES_FOUND            171
+#define VT_NO_SUCH_PROCESS_FOUND               172
+#define VT_PCL_NOT_ENABLED                     173
+#define VT_PCL_UID_CHECK                       174
+#define VT_DEL_RESULTS_DIR_FAILED              175
+#define VT_NO_VALID_EVENTS                     176
+#define VT_INVALID_EVENT                       177
+#define VT_EVENTS_COUNTED                      178
+#define VT_EVENTS_COLLECTED                    179
+#define VT_UNSUPPORTED_GFX_ARCH_TYPE           180
+#define VT_GFX_CONFIG_FAILED                   181
+#define VT_UNSUPPORTED_NON_NATIVE_MODE         182
+#define VT_INVALID_DEVICE                      183
+#define VT_ENV_SETUP_FAILED                    184
+#define VT_RESUME_NOT_RECEIVED                 185
+#define VT_UNSUPPORTED_PWR_ARCH_TYPE           186
+#define VT_PWR_CONFIG_FAILED                   187
+#define VT_NMI_WATCHDOG_FOUND                  188
+#define VT_NO_PMU_RESOURCES                    189
+#define VT_MIC_CARD_NOT_ONLINE                 190
+#define VT_FREEZE_ON_PMI_NOT_AVAIL             191
+#define VT_FLUSH_FAILED                        192
+#define VT_FLUSH_SUCCESS                       193
+#define VT_WRITE_ERROR                         194
+#define VT_NO_SPACE                            195
+#define VT_MSR_ACCESS_ERROR                    196
+#define VT_PEBS_NOT_SUPPORTED                  197
+#define VT_LUA_PARSE_ERROR                     198
+#define VT_COMM_CONNECTION_CLOSED_BY_REMOTE    199
+#define VT_COMM_LISTEN_ERROR                   200
+#define VT_COMM_BIND_ERROR                     201
+#define VT_COMM_ACCEPT_ERROR                   202
+#define VT_COMM_SEND_ERROR                     203
+#define VT_COMM_RECV_ERROR                     204
+#define VT_COMM_SOCKET_ERROR                   205
+#define VT_COMM_CONNECT_ERROR                  206
+#define VT_TARGET_COLLECTION_MISMATCH          207
+#define VT_INVALID_SEP_DRIVER_LOG              208
+#define VT_COMM_PROTOCOL_VERSION_MISTMATCH     209
+#define VT_SAMP_IN_UNEXPECTED_STATE            210
+#define VT_COMM_RECV_BUF_RESIZE_ERROR          211
+
+/*
+ * define error code for checking on async marker request
+ */
+#define VT_INVALID_MARKER_ID                   -1
+
+/*
+ * ************************************************************
+ * NOTE: after adding new error code(s), remember to also
+ *       update the following:
+ *           1) VT_LAST_ERROR_CODE below
+ *           2) viewer/sampling_utils/src/rise.c
+ *           3) collector/controller/sep_msg_catalog.xmc
+ *           4) qnx_kernel/sepdk/include/rise_errors.h
+ *
+ * ************************************************************
+ */
+
+//
+// To make error checking easier, the special VT_LAST_ERROR_CODE
+// should be set to whatever is the last error on the list above
+//
+#define VT_LAST_ERROR_CODE                     VT_COMM_RECV_BUF_RESIZE_ERROR
+
+//
+// Define a macro to determine success or failure. Users of this
+// error header file should use the macros instead of direct
+// checks so that we can change the error numbers in the future
+// (such as making negative numbers be an error indication and positive
+// numbers being a success with a value indication)
+//
+#define VTSA_SUCCESS(x)                        ((x) == VT_SUCCESS)
+#define VTSA_FAILED(x)                         (!VTSA_SUCCESS(x))
+
+//
+// These should be deprecated, but we'll keep them here just in case
+//
+#define SEP_IS_SUCCESS(x)                      VTSA_SUCCESS(x)
+#define SEP_IS_FAILED(x)                       VTSA_FAILED(x)
+
+
+
+/*************************************************************
+ * API Error Codes
+ *************************************************************/
+#define VTAPI_INVALID_MAX_SAMP                 VT_INVALID_MAX_SAMP
+#define VTAPI_INVALID_SAMP_PER_BUFF            VT_INVALID_SAMP_PER_BUFF
+#define VTAPI_INVALID_SAMP_INTERVAL            VT_INVALID_SAMP_INTERVAL
+#define VTAPI_INVALID_PATH                     VT_INVALID_PATH
+#define VTAPI_TB5_IN_USE                       VT_TB5_IN_USE
+#define VTAPI_INVALID_NUM_EVENTS               VT_INVALID_NUM_EVENTS
+#define VTAPI_INTERNAL_ERROR                   VT_INTERNAL_ERROR
+#define VTAPI_BAD_EVENT_NAME                   VT_BAD_EVENT_NAME
+#define VTAPI_NO_SAMP_SESSION                  VT_NO_SAMP_SESSION
+#define VTAPI_NO_EVENTS                        VT_NO_EVENTS
+#define VTAPI_MULTIPLE_RUNS                    VT_MULTIPLE_RUNS
+#define VTAPI_NO_SAM_PARAMS                    VT_NO_SAM_PARAMS
+#define VTAPI_SDB_ALREADY_EXISTS               VT_SDB_ALREADY_EXISTS
+#define VTAPI_SAMPLING_ALREADY_STARTED         VT_SAMPLING_ALREADY_STARTED
+#define VTAPI_TBS_NOT_SUPPORTED                VT_TBS_NOT_SUPPORTED
+#define VTAPI_INVALID_SAMPARAMS_SIZE           VT_INVALID_SAMPARAMS_SIZE
+#define VTAPI_INVALID_EVENT_SIZE               VT_INVALID_EVENT_SIZE
+#define VTAPI_ALREADY_PROCESSES                VT_ALREADY_PROCESSES
+#define VTAPI_INVALID_EVENTS_PATH              VT_INVALID_EVENTS_PATH
+#define VTAPI_INVALID_LICENSE                  VT_INVALID_LICENSE
+
+typedef int RISE_ERROR;
+typedef void *RISE_PTR;
+
+#endif
+
-- 
2.18.0

