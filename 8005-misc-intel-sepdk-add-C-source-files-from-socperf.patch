From dc8aa460aa37c3829e6dacb753ec4d021411fc0f Mon Sep 17 00:00:00 2001
From: Miguel Bernal Marin <miguel.bernal.marin@linux.intel.com>
Date: Sun, 19 Aug 2018 11:12:15 -0500
Subject: [PATCH 8005/8021] misc: intel: sepdk: add C source files from socperf

---
 drivers/misc/intel/sepdk/socperf/control.c    |  749 ++++++++
 .../misc/intel/sepdk/socperf/haswellunc_sa.c  |  391 ++++
 drivers/misc/intel/sepdk/socperf/npk_uncore.c |  514 ++++++
 drivers/misc/intel/sepdk/socperf/pci.c        |  205 +++
 drivers/misc/intel/sepdk/socperf/soc_uncore.c |  903 +++++++++
 drivers/misc/intel/sepdk/socperf/socperfdrv.c | 1623 +++++++++++++++++
 drivers/misc/intel/sepdk/socperf/utility.c    |  194 ++
 7 files changed, 4579 insertions(+)
 create mode 100644 drivers/misc/intel/sepdk/socperf/control.c
 create mode 100644 drivers/misc/intel/sepdk/socperf/haswellunc_sa.c
 create mode 100644 drivers/misc/intel/sepdk/socperf/npk_uncore.c
 create mode 100644 drivers/misc/intel/sepdk/socperf/pci.c
 create mode 100644 drivers/misc/intel/sepdk/socperf/soc_uncore.c
 create mode 100644 drivers/misc/intel/sepdk/socperf/socperfdrv.c
 create mode 100644 drivers/misc/intel/sepdk/socperf/utility.c

diff --git a/drivers/misc/intel/sepdk/socperf/control.c b/drivers/misc/intel/sepdk/socperf/control.c
new file mode 100644
index 000000000000..57001ba54b76
--- /dev/null
+++ b/drivers/misc/intel/sepdk/socperf/control.c
@@ -0,0 +1,749 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#include "lwpmudrv_defines.h"
+#include <linux/version.h>
+#include <linux/mm.h>
+#include <linux/mempool.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "lwpmudrv_types.h"
+#include "rise_errors.h"
+#include "lwpmudrv_ecb.h"
+#include "socperfdrv.h"
+#include "control.h"
+#include <linux/sched.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+#define SMP_CALL_FUNCTION(func,ctx,retry,wait)    smp_call_function((func),(ctx),(wait))
+#else
+#define SMP_CALL_FUNCTION(func,ctx,retry,wait)    smp_call_function((func),(ctx),(retry),(wait))
+#endif
+
+/*
+ *  Global State Nodes - keep here for now.  Abstract out when necessary.
+ */
+GLOBAL_STATE_NODE         socperf_driver_state;
+static MEM_TRACKER        mem_tr_head   = NULL;   // start of the mem tracker list
+static MEM_TRACKER        mem_tr_tail   = NULL;   // end of mem tracker list
+static spinlock_t         mem_tr_lock;            // spinlock for mem tracker list
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn       VOID SOCPERF_Invoke_Cpu (func, ctx, arg)
+ *
+ * @brief    Set up a DPC call and insert it into the queue
+ *
+ * @param    IN cpu_idx  - the core id to dispatch this function to
+ *           IN func     - function to be invoked by the specified core(s)
+ *           IN ctx      - pointer to the parameter block for each function
+ *                         invocation
+ *
+ * @return   None
+ *
+ * <I>Special Notes:</I>
+ *
+ */
+extern VOID
+SOCPERF_Invoke_Cpu (
+    int     cpu_idx,
+    VOID    (*func)(PVOID),
+    PVOID   ctx
+)
+{
+    SOCPERF_Invoke_Parallel(func, ctx);
+
+    return;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * @fn VOID SOCPERF_Invoke_Parallel_Service(func, ctx, blocking, exclude)
+ *
+ * @param    func     - function to be invoked by each core in the system
+ * @param    ctx      - pointer to the parameter block for each function invocation
+ * @param    blocking - Wait for invoked function to complete
+ * @param    exclude  - exclude the current core from executing the code
+ *
+ * @returns  None
+ *
+ * @brief    Service routine to handle all kinds of parallel invoke on all CPU calls
+ *
+ * <I>Special Notes:</I>
+ *           Invoke the function provided in parallel in either a blocking or
+ *           non-blocking mode.  The current core may be excluded if desired.
+ *           NOTE - Do not call this function directly from source code.
+ *           Use the aliases SOCPERF_Invoke_Parallel(), SOCPERF_Invoke_Parallel_NB(),
+ *           or SOCPERF_Invoke_Parallel_XS().
+ *
+ */
+extern VOID
+SOCPERF_Invoke_Parallel_Service (
+    VOID   (*func)(PVOID),
+    PVOID  ctx,
+    int    blocking,
+    int    exclude
+)
+{
+    GLOBAL_STATE_cpu_count(socperf_driver_state) = 0;
+    GLOBAL_STATE_dpc_count(socperf_driver_state) = 0;
+
+    preempt_disable();
+    SMP_CALL_FUNCTION (func, ctx, 0, blocking);
+
+    if (!exclude) {
+        func(ctx);
+    }
+    preempt_enable();
+
+    return;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * @fn VOID control_Memory_Tracker_Delete_Node(mem_tr)
+ *
+ * @param    IN mem_tr    - memory tracker node to delete
+ *
+ * @returns  None
+ *
+ * @brief    Delete specified node in the memory tracker
+ *
+ * <I>Special Notes:</I>
+ *           Assumes mem_tr_lock is already held while calling this function!
+ */
+static VOID
+control_Memory_Tracker_Delete_Node (
+    MEM_TRACKER mem_tr
+)
+{
+    MEM_TRACKER prev_tr = NULL;
+    MEM_TRACKER next_tr = NULL;
+    U32         size    = MEM_EL_MAX_ARRAY_SIZE * sizeof(MEM_EL_NODE);
+
+    if (! mem_tr) {
+        return;
+    }
+
+    // free the allocated mem_el array (if any)
+    if (MEM_TRACKER_mem(mem_tr)) {
+        if (size < MAX_KMALLOC_SIZE) {
+            kfree(MEM_TRACKER_mem(mem_tr));
+        }
+        else {
+            free_pages((unsigned long)MEM_TRACKER_mem(mem_tr), get_order(size));
+        }
+    }
+
+    // update the linked list
+    prev_tr = MEM_TRACKER_prev(mem_tr);
+    next_tr = MEM_TRACKER_next(mem_tr);
+    if (prev_tr) {
+        MEM_TRACKER_next(prev_tr) = next_tr;
+    }
+    if (next_tr) {
+        MEM_TRACKER_prev(next_tr) = prev_tr;
+    }
+
+    // free the mem_tracker node
+    kfree(mem_tr);
+
+    return;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * @fn VOID control_Memory_Tracker_Create_Node(void)
+ *
+ * @param    None    - size of the memory to allocate
+ *
+ * @returns  OS_SUCCESS if successful, otherwise error
+ *
+ * @brief    Initialize the memory tracker
+ *
+ * <I>Special Notes:</I>
+ *           Assumes mem_tr_lock is already held while calling this function!
+ *
+ *           Since this function can be called within either GFP_KERNEL or
+ *           GFP_ATOMIC contexts, the most restrictive allocation is used
+ *           (viz., GFP_ATOMIC).
+ */
+static U32
+control_Memory_Tracker_Create_Node (
+    void
+)
+{
+    U32         size     = MEM_EL_MAX_ARRAY_SIZE * sizeof(MEM_EL_NODE);
+    PVOID       location = NULL;
+    MEM_TRACKER mem_tr   = NULL;
+
+    // create a mem tracker node
+    mem_tr = (MEM_TRACKER)kmalloc(sizeof(MEM_TRACKER_NODE), GFP_ATOMIC);
+    if (!mem_tr) {
+        SOCPERF_PRINT_ERROR("control_Initialize_Memory_Tracker: failed to allocate mem tracker node\n");
+        return OS_FAULT;
+    }
+
+    // create an initial array of mem_el's inside the mem tracker node
+    if (size < MAX_KMALLOC_SIZE) {
+        location = (PVOID)kmalloc(size, GFP_ATOMIC);
+        SOCPERF_PRINT_DEBUG("control_Memory_Tracker_Create_Node: allocated small memory (0x%p, %d)\n", location, (S32) size);
+    }
+    else {
+        location = (PVOID)__get_free_pages(GFP_ATOMIC, get_order(size));
+        SOCPERF_PRINT_DEBUG("control_Memory_Tracker_Create_Node: allocated large memory (0x%p, %d)\n", location, (S32) size);
+    }
+
+    // initialize new mem tracker node
+    MEM_TRACKER_mem(mem_tr)  = location;
+    MEM_TRACKER_prev(mem_tr) = NULL;
+    MEM_TRACKER_next(mem_tr) = NULL;
+
+    // if mem_el array allocation failed, then remove node
+    if (!MEM_TRACKER_mem(mem_tr)) {
+        control_Memory_Tracker_Delete_Node(mem_tr);
+        SOCPERF_PRINT_ERROR("control_Memory_Tracker_Create_Node: failed to allocate mem_el array in tracker node ... deleting node\n");
+        return OS_FAULT;
+    }
+
+    // initialize mem_tracker's mem_el array
+    MEM_TRACKER_max_size(mem_tr) = MEM_EL_MAX_ARRAY_SIZE;
+    memset(MEM_TRACKER_mem(mem_tr), 0, size);
+
+    // update the linked list
+    if (!mem_tr_head) {
+        mem_tr_head = mem_tr;
+    }
+    else {
+        MEM_TRACKER_prev(mem_tr) = mem_tr_tail;
+        MEM_TRACKER_next(mem_tr_tail) = mem_tr;
+    }
+    mem_tr_tail = mem_tr;
+    SOCPERF_PRINT_DEBUG("control_Memory_Tracker_Create_node: allocating new node=0x%p, max_elements=%d, size=%d\n",
+                    MEM_TRACKER_mem(mem_tr_tail), MEM_EL_MAX_ARRAY_SIZE, size);
+
+    return OS_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * @fn VOID control_Memory_Tracker_Add(location, size, vmalloc_flag)
+ *
+ * @param    IN location     - memory location
+ * @param    IN size         - size of the memory to allocate
+ * @param    IN vmalloc_flag - flag that indicates if the allocation was done with vmalloc
+ *
+ * @returns  None
+ *
+ * @brief    Keep track of allocated memory with memory tracker
+ *
+ * <I>Special Notes:</I>
+ *           Starting from first mem_tracker node, the algorithm
+ *           finds the first "hole" in the mem_tracker list and
+ *           tracks the memory allocation there.
+ */
+static U32
+control_Memory_Tracker_Add (
+    PVOID     location,
+    ssize_t   size,
+    DRV_BOOL  vmalloc_flag
+)
+{
+    S32         i, n;
+    U32         status;
+    DRV_BOOL    found;
+    MEM_TRACKER mem_tr;
+
+    spin_lock(&mem_tr_lock);
+
+    // check if there is space in ANY of mem_tracker's nodes for the memory item
+    mem_tr = mem_tr_head;
+    found = FALSE;
+    status = OS_SUCCESS;
+    i = n = 0;
+    while (mem_tr && (!found)) {
+        for (i = 0; i < MEM_TRACKER_max_size(mem_tr); i++) {
+            if (!MEM_TRACKER_mem_address(mem_tr,i)) {
+                SOCPERF_PRINT_DEBUG("SOCPERF_Memory_Tracker_Add: found index %d of %d available\n",
+                                        i,
+                                        MEM_TRACKER_max_size(mem_tr)-1);
+                n = i;
+                found = TRUE;
+            }
+        }
+        if (!found) {
+            mem_tr = MEM_TRACKER_next(mem_tr);
+        }
+    }
+
+    if (!found) {
+        // extend into (i.e., create new) mem_tracker node ...
+        status = control_Memory_Tracker_Create_Node();
+        if (status != OS_SUCCESS) {
+            SOCPERF_PRINT_ERROR("Unable to create mem tracker node\n");
+            goto finish_add;
+        }
+        // use mem tracker tail node and first available entry in mem_el array
+        mem_tr = mem_tr_tail;
+        n = 0;
+    }
+
+    // we now have a location in mem tracker to keep track of the memory item
+    MEM_TRACKER_mem_address(mem_tr,n) = location;
+    MEM_TRACKER_mem_size(mem_tr,n)    = size;
+    MEM_TRACKER_mem_vmalloc(mem_tr,n) = vmalloc_flag;
+    SOCPERF_PRINT_DEBUG("control_Memory_Tracker_Add: tracking (0x%p, %d) in node %d of %d\n",
+                     location, (S32)size, n, MEM_TRACKER_max_size(mem_tr)-1);
+
+finish_add:
+    spin_unlock(&mem_tr_lock);
+
+    return status;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * @fn VOID SOCPERF_Memory_Tracker_Init(void)
+ *
+ * @param    None
+ *
+ * @returns  None
+ *
+ * @brief    Initializes Memory Tracker
+ *
+ * <I>Special Notes:</I>
+ *           This should only be called when the driver is being loaded.
+ */
+extern VOID
+SOCPERF_Memory_Tracker_Init (
+    VOID
+)
+{
+    SOCPERF_PRINT_DEBUG("SOCPERF_Memory_Tracker_Init: initializing mem tracker\n");
+
+    mem_tr_head = NULL;
+    mem_tr_tail = NULL;
+
+    spin_lock_init(&mem_tr_lock);
+
+    return;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * @fn VOID SOCPERF_Memory_Tracker_Free(void)
+ *
+ * @param    None
+ *
+ * @returns  None
+ *
+ * @brief    Frees memory used by Memory Tracker
+ *
+ * <I>Special Notes:</I>
+ *           This should only be called when the driver is being unloaded.
+ */
+extern VOID
+SOCPERF_Memory_Tracker_Free (
+    VOID
+)
+{
+    S32         i;
+    MEM_TRACKER temp;
+
+    SOCPERF_PRINT_DEBUG("SOCPERF_Memory_Tracker_Free: destroying mem tracker\n");
+
+    spin_lock(&mem_tr_lock);
+
+    // check for any memory that was not freed, and free it
+    while (mem_tr_head) {
+        for (i = 0; i < MEM_TRACKER_max_size(mem_tr_head); i++) {
+            if (MEM_TRACKER_mem_address(mem_tr_head,i)) {
+                SOCPERF_PRINT_WARNING("SOCPERF_Memory_Tracker_Free: index %d of %d, not freed (0x%p, %d) ... freeing now\n",
+                                             i,
+                                             MEM_TRACKER_max_size(mem_tr_head)-1,
+                                             MEM_TRACKER_mem_address(mem_tr_head,i),
+                                             MEM_TRACKER_mem_size(mem_tr_head,i));
+                free_pages((unsigned long)MEM_TRACKER_mem_address(mem_tr_head,i), get_order(MEM_TRACKER_mem_size(mem_tr_head,i)));
+                MEM_TRACKER_mem_address(mem_tr_head,i) = NULL;
+                MEM_TRACKER_mem_size(mem_tr_head,i)    = 0;
+                MEM_TRACKER_mem_vmalloc(mem_tr_head,i) = FALSE;
+            }
+        }
+        temp = MEM_TRACKER_next(mem_tr_head);
+        control_Memory_Tracker_Delete_Node(mem_tr_head);
+        mem_tr_head = temp;
+    }
+
+    spin_unlock(&mem_tr_lock);
+
+    SOCPERF_PRINT_DEBUG("SOCPERF_Memory_Tracker_Free: mem tracker destruction complete\n");
+
+    return;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * @fn VOID SOCPERF_Memory_Tracker_Compaction(void)
+ *
+ * @param    None
+ *
+ * @returns  None
+ *
+ * @brief    Compacts the memory allocator if holes are detected
+ *
+ * <I>Special Notes:</I>
+ *           The algorithm compacts mem_tracker nodes such that
+ *           node entries are full starting from mem_tr_head
+ *           up until the first empty node is detected, after
+ *           which nodes up to mem_tr_tail will be empty.
+ *           At end of collection (or at other safe sync point),
+ *           we reclaim/compact space used by mem tracker.
+ */
+extern VOID
+SOCPERF_Memory_Tracker_Compaction (
+    void
+)
+{
+    S32         i, j, n, m, c, d;
+    DRV_BOOL    found, overlap;
+    MEM_TRACKER mem_tr1, mem_tr2;
+
+    spin_lock(&mem_tr_lock);
+
+    mem_tr1 = mem_tr_head;
+    mem_tr2 = mem_tr_tail;
+
+    // if memory tracker was never used, then no need to compact
+    if (!mem_tr1 || !mem_tr2) {
+        goto finish_compact;
+    }
+
+    i = j = n = c = d = 0;
+    m = MEM_TRACKER_max_size(mem_tr2) - 1;
+    overlap = FALSE;
+    while (!overlap) {
+        // find an empty node
+        found = FALSE;
+        while (!found && !overlap && mem_tr1) {
+            SOCPERF_PRINT_DEBUG("SOCPERF_Memory_Tracker_Compaction: looking at mem_tr1 0x%p, index=%d\n", mem_tr1, n);
+            for (i = n; i < MEM_TRACKER_max_size(mem_tr1); i++) {
+                if (!MEM_TRACKER_mem_address(mem_tr1,i)) {
+                    SOCPERF_PRINT_DEBUG("SOCPERF_Memory_Tracker_Compaction: found index %d of %d empty\n",
+                                            i,
+                                            MEM_TRACKER_max_size(mem_tr1)-1);
+                    found = TRUE;
+                }
+            }
+            // check for overlap
+            overlap = (mem_tr1==mem_tr2) && (i>=m);
+
+            // if no overlap and an empty node was not found, then advance to next node
+            if (!found && !overlap) {
+                mem_tr1 = MEM_TRACKER_next(mem_tr1);
+                n = 0;
+            }
+        }
+        // all nodes going in forward direction are full, so exit
+        if (!found || overlap) {
+            goto finish_compact;
+        }
+
+        // find a non-empty node
+        found = FALSE;
+        while (!found && !overlap && mem_tr2) {
+            SOCPERF_PRINT_DEBUG("SOCPERF_Memory_Tracker_Compaction: looking at mem_tr2 0x%p, index=%d\n", mem_tr2, m);
+            for (j = m; j >= 0; j--) {
+                if (MEM_TRACKER_mem_address(mem_tr2,j)) {
+                    SOCPERF_PRINT_DEBUG("SOCPERF_Memory_Tracker_Compaction: found index %d of %d non-empty\n",
+                                            j,
+                                            MEM_TRACKER_max_size(mem_tr2)-1);
+                    found = TRUE;
+                }
+            }
+            // check for overlap
+            overlap = (mem_tr1==mem_tr2) && (j<=i);
+
+            // if no overlap and no non-empty node was found, then retreat to prev node
+            if (!found && !overlap) {
+                MEM_TRACKER empty_tr = mem_tr2;  // keep track of empty node
+                mem_tr2 = MEM_TRACKER_prev(mem_tr2);
+                m = MEM_TRACKER_max_size(mem_tr2) - 1;
+                mem_tr_tail = mem_tr2; // keep track of new tail
+                // reclaim empty mem_tracker node
+                control_Memory_Tracker_Delete_Node(empty_tr);
+                // keep track of number of node deletions performed
+                d++;
+            }
+        }
+        // all nodes going in reverse direction are empty, so exit
+        if (!found || overlap) {
+            goto finish_compact;
+        }
+
+        // swap empty node with non-empty node so that "holes" get bubbled towards the end of list
+        MEM_TRACKER_mem_address(mem_tr1,i) = MEM_TRACKER_mem_address(mem_tr2,j);
+        MEM_TRACKER_mem_size(mem_tr1,i)    = MEM_TRACKER_mem_size(mem_tr2,j);
+        MEM_TRACKER_mem_vmalloc(mem_tr1,i) = MEM_TRACKER_mem_vmalloc(mem_tr2,j);
+
+        MEM_TRACKER_mem_address(mem_tr2,j) = NULL;
+        MEM_TRACKER_mem_size(mem_tr2,j)    = 0;
+        MEM_TRACKER_mem_vmalloc(mem_tr2,j) = FALSE;
+
+        // keep track of number of memory compactions performed
+        c++;
+
+        // start new search starting from next element in mem_tr1
+        n = i+1;
+
+        // start new search starting from prev element in mem_tr2
+        m = j-1;
+    }
+
+finish_compact:
+    spin_unlock(&mem_tr_lock);
+
+    SOCPERF_PRINT_DEBUG("SOCPERF_Memory_Tracker_Compaction: number of elements compacted = %d, nodes deleted = %d\n", c, d);
+
+    return;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * @fn PVOID SOCPERF_Allocate_Memory(size)
+ *
+ * @param    IN size     - size of the memory to allocate
+ *
+ * @returns  char*       - pointer to the allocated memory block
+ *
+ * @brief    Allocate and zero memory
+ *
+ * <I>Special Notes:</I>
+ *           Allocate memory in the GFP_KERNEL pool.
+ *
+ *           Use this if memory is to be allocated within a context where
+ *           the allocator can block the allocation (e.g., by putting
+ *           the caller to sleep) while it tries to free up memory to
+ *           satisfy the request.  Otherwise, if the allocation must
+ *           occur atomically (e.g., caller cannot sleep), then use
+ *           SOCPERF_Allocate_KMemory instead.
+ */
+extern PVOID
+SOCPERF_Allocate_Memory (
+    size_t size
+)
+{
+    U32   status;
+    PVOID location;
+
+    if (size <= 0) {
+        return NULL;
+    }
+
+    // determine whether to use mem_tracker or not
+    if (size < MAX_KMALLOC_SIZE) {
+        location = (PVOID)kmalloc(size, GFP_KERNEL);
+        SOCPERF_PRINT_DEBUG("SOCPERF_Allocate_Memory: allocated small memory (0x%p, %d)\n", location, (S32) size);
+    }
+    else {
+        location = (PVOID)vmalloc(size);
+        if (location) {
+            status = control_Memory_Tracker_Add(location, size, TRUE);
+            SOCPERF_PRINT_DEBUG("SOCPERF_Allocate_Memory: - allocated *large* memory (0x%p, %d)\n", location, (S32) size);
+            if (status != OS_SUCCESS) {
+                // failed to track in mem_tracker, so free up memory and return NULL
+                vfree(location);
+                SOCPERF_PRINT_ERROR("SOCPERF_Allocate_Memory: - able to allocate, but failed to track via MEM_TRACKER ... freeing\n");
+                return NULL;
+            }
+        }
+    }
+
+    if (!location) {
+        SOCPERF_PRINT_ERROR("SOCPERF_Allocate_Memory: failed for size %d bytes\n", (S32) size);
+        return NULL;
+    }
+
+    memset(location, 0, size);
+
+    return location;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * @fn PVOID SOCPERF_Allocate_KMemory(size)
+ *
+ * @param    IN size     - size of the memory to allocate
+ *
+ * @returns  char*       - pointer to the allocated memory block
+ *
+ * @brief    Allocate and zero memory
+ *
+ * <I>Special Notes:</I>
+ *           Allocate memory in the GFP_ATOMIC pool.
+ *
+ *           Use this if memory is to be allocated within a context where
+ *           the allocator cannot block the allocation (e.g., by putting
+ *           the caller to sleep) as it tries to free up memory to
+ *           satisfy the request.  Examples include interrupt handlers,
+ *           process context code holding locks, etc.
+ */
+extern PVOID
+SOCPERF_Allocate_KMemory (
+    size_t size
+)
+{
+    U32   status;
+    PVOID location;
+
+    if (size <= 0) {
+        return NULL;
+    }
+
+    if (size < MAX_KMALLOC_SIZE) {
+        location = (PVOID)kmalloc(size, GFP_ATOMIC);
+        SOCPERF_PRINT_DEBUG("SOCPERF_Allocate_KMemory: allocated small memory (0x%p, %d)\n", location, (S32) size);
+    }
+    else {
+        location = (PVOID)__get_free_pages(GFP_ATOMIC, get_order(size));
+        status = control_Memory_Tracker_Add(location, size, FALSE);
+        SOCPERF_PRINT_DEBUG("SOCPERF_Allocate_KMemory: allocated large memory (0x%p, %d)\n", location, (S32) size);
+        if (status != OS_SUCCESS) {
+            // failed to track in mem_tracker, so free up memory and return NULL
+            free_pages((unsigned long)location, get_order(size));
+            SOCPERF_PRINT_ERROR("SOCPERF_Allocate_KMemory: - able to allocate, but failed to track via MEM_TRACKER ... freeing\n");
+            return NULL;
+        }
+    }
+
+    if (!location) {
+        SOCPERF_PRINT_ERROR("SOCPERF_Allocate_KMemory: failed for size %d bytes\n", (S32) size);
+        return NULL;
+    }
+
+    memset(location, 0, size);
+
+    return location;
+}
+
+/* ------------------------------------------------------------------------- */
+/*
+ * @fn PVOID SOCPERF_Free_Memory(location)
+ *
+ * @param    IN location  - size of the memory to allocate
+ *
+ * @returns  pointer to the allocated memory block
+ *
+ * @brief    Frees the memory block
+ *
+ * <I>Special Notes:</I>
+ *           Does not try to free memory if fed with a NULL pointer
+ *           Expected usage:
+ *               ptr = SOCPERF_Free_Memory(ptr);
+ *           Does not do compaction ... can have "holes" in
+ *           mem_tracker list after this operation.
+ */
+extern PVOID
+SOCPERF_Free_Memory (
+    PVOID  location
+)
+{
+    S32         i;
+    DRV_BOOL    found;
+    MEM_TRACKER mem_tr;
+
+    if (!location) {
+        return NULL;
+    }
+
+    spin_lock(&mem_tr_lock);
+
+    // scan through mem_tracker nodes for matching entry (if any)
+    mem_tr = mem_tr_head;
+    found = FALSE;
+    while (mem_tr) {
+        for (i = 0; i < MEM_TRACKER_max_size(mem_tr); i++) {
+            if (location == MEM_TRACKER_mem_address(mem_tr,i)) {
+                SOCPERF_PRINT_DEBUG("SOCPERF_Free_Memory: freeing large memory location 0x%p\n", location);
+                found = TRUE;
+                if (MEM_TRACKER_mem_vmalloc(mem_tr, i)) {
+                    vfree(location);
+                }
+                else {
+                    free_pages((unsigned long)location, get_order(MEM_TRACKER_mem_size(mem_tr,i)));
+                }
+                MEM_TRACKER_mem_address(mem_tr,i) = NULL;
+                MEM_TRACKER_mem_size(mem_tr,i)    = 0;
+                MEM_TRACKER_mem_vmalloc(mem_tr,i) = FALSE;
+                goto finish_free;
+            }
+        }
+        mem_tr = MEM_TRACKER_next(mem_tr);
+    }
+
+finish_free:
+    spin_unlock(&mem_tr_lock);
+
+    // must have been of smaller than the size limit for mem tracker nodes
+    if (!found) {
+        SOCPERF_PRINT_DEBUG("SOCPERF_Free_Memory: freeing small memory location 0x%p\n", location);
+        kfree(location);
+    }
+
+    return NULL;
+}
diff --git a/drivers/misc/intel/sepdk/socperf/haswellunc_sa.c b/drivers/misc/intel/sepdk/socperf/haswellunc_sa.c
new file mode 100644
index 000000000000..04b629301006
--- /dev/null
+++ b/drivers/misc/intel/sepdk/socperf/haswellunc_sa.c
@@ -0,0 +1,391 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2011-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE
+
+  Copyright(C) 2011-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+
+#include "lwpmudrv_defines.h"
+#include <linux/version.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+
+#include "lwpmudrv_types.h"
+#include "lwpmudrv_ecb.h"
+#include "lwpmudrv_struct.h"
+
+#include "socperfdrv.h"
+#include "control.h"
+#include "haswellunc_sa.h"
+#include "ecb_iterators.h"
+#include "inc/pci.h"
+
+static U64            counter_virtual_address = 0;
+static U32            counter_overflow[HSWUNC_SA_MAX_COUNTERS];
+extern LWPMU_DEVICE   device_uncore;
+static U32            device_id = 0;
+
+/*!
+ * @fn          static VOID hswunc_sa_Write_PMU(VOID*)
+ *
+ * @brief       Initial write of PMU registers
+ *              Walk through the entries and write the value of the register accordingly.
+ *              When current_group = 0, then this is the first time this routine is called,
+ *
+ * @param       param - device index
+ *
+ * @return      None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+hswunc_sa_Write_PMU (
+    VOID  *param
+)
+{
+    U32                        dev_idx  = *((U32*)param);
+    U32                        cur_grp  = LWPMU_DEVICE_cur_group(device_uncore);
+    ECB                        pecb     = LWPMU_DEVICE_PMU_register_data(device_uncore)[cur_grp];
+    DRV_PCI_DEVICE_ENTRY       dpden;
+    U32                        pci_address;
+    U32                        bar_lo;
+    U64                        bar_hi;
+    U64                        final_bar;
+    U64                        physical_address;
+    U32                        dev_index       = 0;
+    S32                        bar_list[HSWUNC_SA_MAX_PCI_DEVICES];
+    U32                        bar_index       = 0;
+    U64                        gdxc_bar        = 0;
+    U32                        map_size        = 0;
+    U64                        virtual_address = 0;
+    U64                        mmio_offset     = 0;
+    U32                        bar_name        = 0;
+    DRV_PCI_DEVICE_ENTRY       curr_pci_entry  = NULL;
+    U32                        next_bar_offset = 0;
+    U32                        i               = 0;
+
+    for (dev_index = 0; dev_index < HSWUNC_SA_MAX_PCI_DEVICES; dev_index++) {
+        bar_list[dev_index] = -1;
+    }
+
+    device_id = dev_idx;
+    // initialize the CHAP per-counter overflow numbers
+    for (i = 0; i < HSWUNC_SA_MAX_COUNTERS; i++) {
+        counter_overflow[i]          = 0;
+        socperf_pcb[0].last_uncore_count[i] = 0;
+    }
+
+    ECB_pcidev_entry_list(pecb) = (DRV_PCI_DEVICE_ENTRY)((S8*)pecb + ECB_pcidev_list_offset(pecb));
+    dpden = ECB_pcidev_entry_list(pecb);
+
+    if (counter_virtual_address) {
+        for (i = 0; i < ECB_num_entries(pecb); i++) {
+            writel(HSWUNC_SA_CHAP_STOP,
+                (U32*)(((char*)(UIOP)counter_virtual_address)+HSWUNC_SA_CHAP_CTRL_REG_OFFSET+i*0x10));
+        }
+    }
+
+    for (dev_index = 0; dev_index < ECB_num_pci_devices(pecb); dev_index++) {
+        curr_pci_entry = &dpden[dev_index];
+        mmio_offset    = DRV_PCI_DEVICE_ENTRY_base_offset_for_mmio(curr_pci_entry);
+        bar_name       = DRV_PCI_DEVICE_ENTRY_bar_name(curr_pci_entry);
+        if (DRV_PCI_DEVICE_ENTRY_config_type(curr_pci_entry) == UNC_PCICFG) {
+            pci_address = FORM_PCI_ADDR(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                        DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                        DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                        mmio_offset);
+            SOCPERF_PCI_Write_Ulong(pci_address, DRV_PCI_DEVICE_ENTRY_value(curr_pci_entry));
+            continue;
+        }
+        // UNC_MMIO programming
+        if (bar_list[bar_name] != -1) {
+            bar_index                                            = bar_list[bar_name];
+            virtual_address                                      = DRV_PCI_DEVICE_ENTRY_virtual_address(&dpden[bar_index]);
+            DRV_PCI_DEVICE_ENTRY_virtual_address(curr_pci_entry) = DRV_PCI_DEVICE_ENTRY_virtual_address(&dpden[bar_index]);
+            writel(DRV_PCI_DEVICE_ENTRY_value(curr_pci_entry), (U32*)(((char*)(UIOP)virtual_address)+mmio_offset));
+            continue;
+        }
+        if (bar_name == UNC_GDXCBAR) {
+            DRV_PCI_DEVICE_ENTRY_bar_address(curr_pci_entry) = gdxc_bar;
+        }
+        else {
+            pci_address     = FORM_PCI_ADDR(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                        DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                        DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                        DRV_PCI_DEVICE_ENTRY_bar_offset(curr_pci_entry));
+            bar_lo          = SOCPERF_PCI_Read_Ulong(pci_address);
+            next_bar_offset = DRV_PCI_DEVICE_ENTRY_bar_offset(curr_pci_entry)+HSWUNC_SA_NEXT_ADDR_OFFSET;
+            pci_address     = FORM_PCI_ADDR(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                        DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                        DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                        next_bar_offset);
+            bar_hi      = SOCPERF_PCI_Read_Ulong(pci_address);
+            final_bar   = (bar_hi << HSWUNC_SA_BAR_ADDR_SHIFT) | bar_lo;
+            final_bar  &= HSWUNC_SA_BAR_ADDR_MASK;
+
+            DRV_PCI_DEVICE_ENTRY_bar_address(curr_pci_entry) = final_bar;
+        }
+        physical_address = DRV_PCI_DEVICE_ENTRY_bar_address(curr_pci_entry);
+
+        if (physical_address) {
+            if (bar_name == UNC_MCHBAR) {
+                map_size = HSWUNC_SA_MCHBAR_MMIO_PAGE_SIZE;
+            }
+            else if (bar_name == UNC_PCIEXBAR) {
+                map_size = HSWUNC_SA_PCIEXBAR_MMIO_PAGE_SIZE;
+            }
+            else {
+                map_size = HSWUNC_SA_OTHER_BAR_MMIO_PAGE_SIZE;
+            }
+            DRV_PCI_DEVICE_ENTRY_virtual_address(curr_pci_entry) = (U64) (UIOP)ioremap_nocache(physical_address, map_size);
+            virtual_address = DRV_PCI_DEVICE_ENTRY_virtual_address(curr_pci_entry);
+
+            if (!gdxc_bar && bar_name == UNC_MCHBAR) {
+                bar_lo   = readl((U32*)((char*)(UIOP)virtual_address+HSWUNC_SA_GDXCBAR_OFFSET_LO));
+                bar_hi   = readl((U32*)((char*)(UIOP)virtual_address+HSWUNC_SA_GDXCBAR_OFFSET_HI));
+                gdxc_bar = (bar_hi << HSWUNC_SA_BAR_ADDR_SHIFT) | bar_lo;
+                gdxc_bar = gdxc_bar & HSWUNC_SA_GDXCBAR_MASK;
+            }
+            writel((U32)DRV_PCI_DEVICE_ENTRY_value(curr_pci_entry), (U32*)(((char*)(UIOP)virtual_address)+mmio_offset));
+            bar_list[bar_name] = dev_index;
+            if (counter_virtual_address == 0 && bar_name == UNC_CHAPADR) {
+                counter_virtual_address = virtual_address;
+            }
+        }
+    }
+
+    return;
+}
+
+/*!
+ * @fn         static VOID hswunc_sa_Disable_PMU(PVOID)
+ *
+ * @brief      Unmap the virtual address when sampling/driver stops
+ *
+ * @param      param - device index
+ *
+ * @return     None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+hswunc_sa_Disable_PMU (
+    PVOID  param
+)
+{
+
+    DRV_PCI_DEVICE_ENTRY  dpden;
+    U32                   dev_index = 0;
+    U32                   cur_grp   = LWPMU_DEVICE_cur_group(device_uncore);
+    ECB                   pecb      = LWPMU_DEVICE_PMU_register_data(device_uncore)[cur_grp];
+    U32                   i         = 0;
+
+    if (GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_PREPARE_STOP) {
+
+        if (counter_virtual_address) {
+            for (i = 0; i < ECB_num_entries(pecb); i++) {
+                writel(HSWUNC_SA_CHAP_STOP,
+                    (U32*)(((char*)(UIOP)counter_virtual_address)+HSWUNC_SA_CHAP_CTRL_REG_OFFSET+i*0x10));
+            }
+        }
+
+        dpden = ECB_pcidev_entry_list(pecb);
+        for (dev_index = 0; dev_index < ECB_num_pci_devices(pecb); dev_index++) {
+            if (DRV_PCI_DEVICE_ENTRY_config_type(&dpden[dev_index]) == UNC_MMIO &&
+                DRV_PCI_DEVICE_ENTRY_bar_address(&dpden[dev_index]) != 0) {
+                iounmap((void*)(UIOP)(DRV_PCI_DEVICE_ENTRY_virtual_address(&dpden[dev_index])));
+            }
+        }
+        counter_virtual_address = 0;
+    }
+
+    return;
+}
+
+/*!
+ * @fn         static VOID hswunc_sa_Initialize(PVOID)
+ *
+ * @brief      Initialize any registers or addresses
+ *
+ * @param      param
+ *
+ * @return     None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+hswunc_sa_Initialize (
+    VOID  *param
+)
+{
+    counter_virtual_address = 0;
+    return;
+}
+
+
+/*!
+ * @fn         static VOID hswunc_sa_Clean_Up(PVOID)
+ *
+ * @brief      Reset any registers or addresses
+ *
+ * @param      param
+ *
+ * @return     None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+hswunc_sa_Clean_Up (
+    VOID   *param
+)
+{
+    counter_virtual_address = 0;
+    return;
+}
+
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn hswunc_sa_Read_Data(param, id)
+ *
+ * @param    data_buffer    data buffer to read data into
+ *
+ * @return   None     No return needed
+ *
+ * @brief    Read the Uncore count data and store into the buffer param;
+ *
+ */
+static VOID
+hswunc_sa_Read_Data (
+    PVOID data_buffer
+)
+{
+    U32                   event_id    = 0;
+    U64                  *data;
+    int                   data_index;
+    U32                   data_val    = 0;
+    U64                   total_count = 0;
+    U32                   cur_grp     = LWPMU_DEVICE_cur_group(device_uncore);
+
+    if (GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_UNINITIALIZED ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_IDLE          ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_RESERVED      ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_PREPARE_STOP  ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_STOPPED) {
+        SOCPERF_PRINT_ERROR("ERROR: RETURING EARLY from Read_Data\n");
+        return;
+    }
+    if (data_buffer == NULL) {
+        return;
+    }
+    data       = (U64 *)data_buffer;
+    data_index = 0;
+    // group id
+    data[data_index] = cur_grp + 1;
+    data_index++;
+
+    FOR_EACH_PCI_DATA_REG_RAW(pecb, i, dev_idx) {
+        //event_id = ECB_entries_event_id_index_local(pecb, i);
+        if (counter_virtual_address) {
+            writel(HSWUNC_SA_CHAP_SAMPLE_DATA,
+               (U32*)(((char*)(UIOP)counter_virtual_address) + HSWUNC_SA_CHAP_CTRL_REG_OFFSET + i*0x10));
+            data_val = readl((U32*)((char*)(UIOP)(counter_virtual_address) + ECB_entries_reg_offset(pecb, i)));
+        }
+
+        if (data_val < socperf_pcb[0].last_uncore_count[i]) {
+            counter_overflow[i]++;
+        }
+        socperf_pcb[0].last_uncore_count[i] = data_val;
+
+        total_count = data_val + counter_overflow[i]*HSWUNC_SA_MAX_COUNT;
+        data[data_index+event_id] = total_count;
+        SOCPERF_PRINT_DEBUG("DATA=%u\n", data_val);
+        event_id++;
+    } END_FOR_EACH_PCI_DATA_REG_RAW;
+
+    return;
+}
+
+/*
+ * Initialize the dispatch table
+ */
+DISPATCH_NODE  socperf_hswunc_sa_dispatch =
+{
+    hswunc_sa_Initialize,        // initialize
+    NULL,                        // destroy
+    hswunc_sa_Write_PMU ,        // write
+    hswunc_sa_Disable_PMU,       // freeze
+    NULL,                        // restart
+    NULL,                        // read
+    NULL,                        // check for overflow
+    NULL,
+    NULL,
+    hswunc_sa_Clean_Up,
+    NULL,
+    NULL,
+    NULL,
+    NULL,                        //read_counts
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    hswunc_sa_Read_Data,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
+
diff --git a/drivers/misc/intel/sepdk/socperf/npk_uncore.c b/drivers/misc/intel/sepdk/socperf/npk_uncore.c
new file mode 100644
index 000000000000..b99cad936cbe
--- /dev/null
+++ b/drivers/misc/intel/sepdk/socperf/npk_uncore.c
@@ -0,0 +1,514 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2013-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE
+
+  Copyright(C) 2013-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#include "lwpmudrv_defines.h"
+#include <linux/version.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+
+#include "lwpmudrv_types.h"
+#include "lwpmudrv_ecb.h"
+#include "lwpmudrv_struct.h"
+
+#include "inc/socperfdrv.h"
+#include "inc/ecb_iterators.h"
+#include "inc/pci.h"
+#include "inc/control.h"
+#include "inc/npk_uncore.h"
+
+
+extern LWPMU_DEVICE   device_uncore;
+static U32            counter_overflow[SOC_NPK_COUNTER_MAX_COUNTERS];
+static U64            counter_virtual_address = 0;
+static U64            mchbar_virtual_address  = 0;
+static U64            mchbar_offset           = 0;
+
+
+/*!
+ * @fn          static ULONG read_From_Register(U64  bar_virtual_address,
+                                                U64  mmio_offset,
+                                                U32 *data_val)
+ *
+ * @brief       Reads register programming info
+ *
+ * @param       bar_virtual_address - memory address
+ *              mmio_offset         - offset of the register
+ *              data_val            - register value read
+ *
+ * @return      data from the counter register
+ *
+ * <I>Special Notes:</I>
+ */
+static void
+read_From_Register (
+    U64  bar_virtual_address,
+    U64  mmio_offset,
+    U32 *data_val
+)
+{
+
+    if (data_val) {
+        *data_val = readl((U32*)((char*)(UIOP)(bar_virtual_address) + mmio_offset));
+    }
+    return;
+}
+
+
+/*!
+ * @fn          static ULONG write_To_Register(U64  bar_virtual_address,
+                                               U64  mmio_offset,
+                                               U32  value)
+ *
+ * @brief       Write register programming info
+ *
+ * @param       bar_virtual_address - memory address
+ *              mmio_offset         - offset of the register
+ *              value               - register value to be written
+ *
+ * @return      none
+ *
+ * <I>Special Notes:</I>
+ */
+static void
+write_To_Register (
+    U64   bar_virtual_address,
+    U64   mmio_offset,
+    ULONG value
+)
+{
+    U32 read_reg = 0;
+
+    writel(value, (U32*)(((char*)(UIOP)bar_virtual_address)+mmio_offset));
+    read_From_Register(bar_virtual_address, mmio_offset, &read_reg);
+
+    return;
+}
+
+
+/*!
+ * @fn          static VOID uncore_Reset_Counters(U32 dev_idx)
+ *
+ * @brief       Reset counters
+ *
+ * @param       dev_idx - device index
+ *
+ * @return      None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Reset_Counters (
+    U32 dev_idx
+)
+{
+    U32 data_reg   = 0;
+
+    if (counter_virtual_address) {
+        FOR_EACH_PCI_REG_RAW(pecb, i, dev_idx) {
+            if (ECB_entries_reg_type(pecb,i) == PMU_REG_EVENT_SELECT) {
+                data_reg = i + ECB_operations_register_len(pecb, PMU_OPERATION_WRITE);
+                if (ECB_entries_reg_type(pecb,data_reg) == PMU_REG_DATA) {
+                    write_To_Register(counter_virtual_address,
+                                      ECB_entries_reg_offset(pecb, data_reg),
+                                      (ULONG)0);
+                }
+                write_To_Register(counter_virtual_address,
+                                  ECB_entries_reg_offset(pecb,i),
+                                  (ULONG)SOC_NPK_UNCORE_STOP);
+            }
+        } END_FOR_EACH_PCI_REG_RAW;
+    }
+
+    return;
+}
+
+/*!
+ * @fn          static VOID uncore_Write_PMU(VOID*)
+ *
+ * @brief       Initial write of PMU registers
+ *              Walk through the entries and write the value of the register accordingly.
+ *              When current_group = 0, then this is the first time this routine is called,
+ *
+ * @param       param - device index
+ *
+ * @return      None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Write_PMU (
+    VOID  *param
+)
+{
+    U32                        dev_idx  = *((U32*)param);
+    ECB                        pecb;
+    DRV_PCI_DEVICE_ENTRY       dpden;
+    U32                        pci_address;
+    U32                        bar_lo;
+    U64                        bar_hi;
+    U64                        final_bar;
+    U64                        physical_address;
+    U32                        dev_index       = 0;
+    S32                        bar_list[SOC_NPK_UNCORE_MAX_PCI_DEVICES];
+    U32                        bar_index       = 0;
+    U64                        virtual_address = 0;
+    U32                        bar_name        = 0;
+    DRV_PCI_DEVICE_ENTRY       curr_pci_entry  = NULL;
+    U32                        next_bar_offset = 0;
+    U64                        mmio_offset     = 0;
+    U32                        i               = 0;
+    U32                        map_size        = 0;
+    U32                        cur_grp;
+
+    if (device_uncore == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: NULL device_uncore!\n");
+        return;
+    }
+    cur_grp = LWPMU_DEVICE_cur_group(device_uncore);
+
+    pecb     = (ECB)LWPMU_DEVICE_PMU_register_data(device_uncore)[cur_grp];
+    if (pecb == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: null pecb!\n");
+        return;
+    }
+
+    for (dev_index = 0; dev_index < SOC_NPK_UNCORE_MAX_PCI_DEVICES; dev_index++) {
+        bar_list[dev_index] = -1;
+    }
+
+    // initialize the per-counter overflow numbers
+    for (i = 0; i < SOC_NPK_COUNTER_MAX_COUNTERS; i++) {
+        counter_overflow[i]         = 0;
+        socperf_pcb[0].last_uncore_count[i] = 0;
+    }
+
+    ECB_pcidev_entry_list(pecb) = (DRV_PCI_DEVICE_ENTRY)((S8*)pecb + ECB_pcidev_list_offset(pecb));
+    dpden = ECB_pcidev_entry_list(pecb);
+
+    uncore_Reset_Counters(dev_idx);
+
+    SOCPERF_PRINT_DEBUG("Inside VISA Driver Write PMU: Number of entries=%d\n", ECB_num_pci_devices(pecb));
+    for (dev_index = 0; dev_index < ECB_num_pci_devices(pecb); dev_index++) {
+        curr_pci_entry = &dpden[dev_index];
+        bar_name       = DRV_PCI_DEVICE_ENTRY_bar_name(curr_pci_entry);
+        mmio_offset    = DRV_PCI_DEVICE_ENTRY_base_offset_for_mmio(curr_pci_entry);
+
+        // UNC_MMIO programming
+        if (bar_list[bar_name] != -1) {
+            bar_index = bar_list[bar_name];
+            virtual_address                                      = DRV_PCI_DEVICE_ENTRY_virtual_address(&dpden[bar_index]);
+            DRV_PCI_DEVICE_ENTRY_virtual_address(curr_pci_entry) = DRV_PCI_DEVICE_ENTRY_virtual_address(&dpden[bar_index]);
+            write_To_Register(virtual_address, mmio_offset, (U32)DRV_PCI_DEVICE_ENTRY_value(curr_pci_entry));
+            continue;
+        }
+
+        pci_address     = FORM_PCI_ADDR(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                    DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                    DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                    DRV_PCI_DEVICE_ENTRY_bar_offset(curr_pci_entry));
+        bar_lo          = SOCPERF_PCI_Read_Ulong(pci_address);
+        SOCPERF_PRINT_DEBUG("The bus=%x device=%x function=%x offset=%x\n",
+                            DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                            DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                            DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                            DRV_PCI_DEVICE_ENTRY_bar_offset(curr_pci_entry));
+        next_bar_offset = DRV_PCI_DEVICE_ENTRY_bar_offset(curr_pci_entry)+SOC_NPK_UNCORE_NEXT_ADDR_OFFSET;
+        pci_address     = FORM_PCI_ADDR(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                    DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                    DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                    next_bar_offset);
+        bar_hi      = SOCPERF_PCI_Read_Ulong(pci_address);
+        SOCPERF_PRINT_DEBUG("The bus=%x device=%x function=%x offset=%x\n",
+                            DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                            DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                            DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                            next_bar_offset);
+        final_bar   = (bar_hi << SOC_NPK_UNCORE_BAR_ADDR_SHIFT) | bar_lo;
+        if (bar_name == UNC_MCHBAR) {
+            final_bar  &= SOC_NPK_UNCORE_MCHBAR_ADDR_MASK;
+            map_size = SOC_NPK_UNCORE_MCHBAR_MMIO_PAGE_SIZE;
+        }
+        else {
+            final_bar  &= SOC_NPK_UNCORE_BAR_ADDR_MASK;
+            map_size = SOC_NPK_UNCORE_NPK_BAR_MMIO_PAGE_SIZE;
+        }
+        DRV_PCI_DEVICE_ENTRY_bar_address(curr_pci_entry) = final_bar;
+        physical_address = DRV_PCI_DEVICE_ENTRY_bar_address(curr_pci_entry);
+
+        if (physical_address) {
+            DRV_PCI_DEVICE_ENTRY_virtual_address(curr_pci_entry) = (U64) (UIOP)ioremap_nocache(physical_address, map_size);
+            virtual_address = DRV_PCI_DEVICE_ENTRY_virtual_address(curr_pci_entry);
+
+            write_To_Register(virtual_address, mmio_offset, (U32)DRV_PCI_DEVICE_ENTRY_value(curr_pci_entry));
+            bar_list[bar_name] = dev_index;
+            if (counter_virtual_address == 0) {
+                counter_virtual_address = virtual_address;
+            }
+            if (mchbar_virtual_address == 0 && bar_name == UNC_MCHBAR) {
+                mchbar_virtual_address = virtual_address;
+                mchbar_offset          = mmio_offset;
+            }
+        }
+    }
+
+    return;
+}
+
+
+
+/*!
+ * @fn         static VOID uncore_Disable_PMU(PVOID)
+ *
+ * @brief      Unmap the virtual address when sampling/driver stops
+ *
+ * @param      param - device index
+ *
+ * @return     None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Disable_PMU (
+    PVOID  param
+)
+{
+    U32                   dev_idx   = *((U32*)param);
+
+    if (GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_PREPARE_STOP) {
+        uncore_Reset_Counters(dev_idx);
+        if (mchbar_virtual_address) {
+            write_To_Register(mchbar_virtual_address, mchbar_offset, 0x0);
+            iounmap((void*)(UIOP)(mchbar_virtual_address));
+            SOCPERF_PRINT_DEBUG("Unmapping MCHBAR address=%x\n", mchbar_virtual_address);
+        }
+        if (counter_virtual_address) {
+            iounmap((void*)(UIOP)(counter_virtual_address));
+            SOCPERF_PRINT_DEBUG("Unmapping NPKBAR address=%x\n", counter_virtual_address);
+        }
+        counter_virtual_address = 0;
+        mchbar_virtual_address  = 0;
+        mchbar_offset           = 0;
+    }
+
+    return;
+}
+
+
+/*!
+ * @fn         static VOID uncore_Initialize(PVOID)
+ *
+ * @brief      Initialize any registers or addresses
+ *
+ * @param      param
+ *
+ * @return     None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Initialize (
+    VOID  *param
+)
+{
+    counter_virtual_address = 0;
+    mchbar_virtual_address  = 0;
+    mchbar_offset           = 0;
+    return;
+}
+
+
+/*!
+ * @fn         static VOID uncore_Clean_Up(PVOID)
+ *
+ * @brief      Reset any registers or addresses
+ *
+ * @param      param
+ *
+ * @return     None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Clean_Up (
+    VOID   *param
+)
+{
+    counter_virtual_address = 0;
+    mchbar_virtual_address  = 0;
+    mchbar_offset           = 0;
+    return;
+}
+
+
+
+
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn uncore_Read_Data()
+ *
+ * @param    None
+ *
+ * @return   None     No return needed
+ *
+ * @brief    Read the counters
+ *
+ */
+static VOID
+uncore_Read_Data (
+    PVOID data_buffer
+)
+{
+    U32              event_id    = 0;
+    U64             *data;
+    int              data_index;
+    U32              data_val    = 0;
+    U32              data_reg    = 0;
+    U64              total_count = 0;
+    U32              event_index = 0;
+    U32              cur_grp;
+
+    if (device_uncore == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: NULL device_uncore!\n");
+        return;
+    }
+    cur_grp = LWPMU_DEVICE_cur_group(device_uncore);
+
+    if (GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_UNINITIALIZED ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_IDLE          ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_RESERVED      ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_PREPARE_STOP  ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_STOPPED) {
+        SOCPERF_PRINT_ERROR("ERROR: RETURING EARLY from Read_Data\n");
+        return;
+    }
+
+    if (data_buffer == NULL) {
+        return;
+    }
+
+    data       = (U64*)data_buffer;
+    data_index = 0;
+
+    // Write GroupID
+    data[data_index] = cur_grp + 1;
+    // Increment the data index as the event id starts from zero
+    data_index++;
+
+    FOR_EACH_PCI_REG_RAW(pecb, i, dev_idx) {
+
+        if (ECB_entries_reg_type(pecb,i) == PMU_REG_EVENT_SELECT) {
+            write_To_Register(counter_virtual_address,
+                              ECB_entries_reg_offset(pecb,i),
+                              (ULONG)SOC_NPK_UNCORE_SAMPLE_DATA);
+
+            data_reg = i + ECB_operations_register_len(pecb, PMU_OPERATION_WRITE);
+            if (ECB_entries_reg_type(pecb,data_reg) == PMU_REG_DATA) {
+                read_From_Register(counter_virtual_address,
+                                   ECB_entries_reg_offset(pecb,data_reg),
+                                   &data_val);
+                if (data_val < socperf_pcb[0].last_uncore_count[event_index]) {
+                    counter_overflow[event_index]++;
+                }
+                socperf_pcb[0].last_uncore_count[event_index] = data_val;
+                total_count = data_val + counter_overflow[event_index]*SOC_NPK_COUNTER_MAX_COUNT;
+                event_index++;
+                data[data_index+event_id] = total_count;
+                SOCPERF_PRINT_DEBUG("DATA[%d]=%llu\n", event_id, total_count);
+                event_id++;
+            }
+        }
+
+    } END_FOR_EACH_PCI_REG_RAW;
+
+    return;
+}
+
+
+
+
+/*
+ * Initialize the dispatch table
+ */
+DISPATCH_NODE  npk_dispatch =
+{
+    uncore_Initialize,        // initialize
+    NULL,                     // destroy
+    uncore_Write_PMU,         // write
+    uncore_Disable_PMU,       // freeze
+    NULL,                     // restart
+    NULL,                     // read
+    NULL,                     // check for overflow
+    NULL,
+    NULL,
+    uncore_Clean_Up,
+    NULL,
+    NULL,
+    NULL,
+    NULL,                    // read counts
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    uncore_Read_Data,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
diff --git a/drivers/misc/intel/sepdk/socperf/pci.c b/drivers/misc/intel/sepdk/socperf/pci.c
new file mode 100644
index 000000000000..68b1d7dab77a
--- /dev/null
+++ b/drivers/misc/intel/sepdk/socperf/pci.c
@@ -0,0 +1,205 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#include "lwpmudrv_defines.h"
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <asm/page.h>
+#include <asm/io.h>
+
+#include "lwpmudrv_types.h"
+#include "rise_errors.h"
+#include "lwpmudrv_ecb.h"
+#include "socperfdrv.h"
+#include "pci.h"
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn extern int SOCPERF_PCI_Read_From_Memory_Address(addr, val)
+ *
+ * @param    addr    - physical address in mmio
+ * @param   *value  - value at this address
+ *
+ * @return  status
+ *
+ * @brief   Read memory mapped i/o physical location
+ *
+ */
+extern int
+SOCPERF_PCI_Read_From_Memory_Address (
+    U32 addr,
+    U32* val
+)
+{
+    U32 aligned_addr, offset, value;
+    PVOID base;
+
+    if (addr <= 0) {
+        return OS_INVALID;
+    }
+
+    SOCPERF_PRINT_DEBUG("SOCPERF_PCI_Read_From_Memory_Address: reading physical address:%x\n",addr);
+    offset       = addr & ~PAGE_MASK;
+    aligned_addr = addr & PAGE_MASK;
+    SOCPERF_PRINT_DEBUG("SOCPERF_PCI_Read_From_Memory_Address: aligned physical address:%x,offset:%x\n",aligned_addr,offset);
+
+    base = ioremap_nocache(aligned_addr, PAGE_SIZE);
+    if (base == NULL) {
+        return OS_INVALID;
+    }
+
+    value = readl(base+offset);
+    *val = value;
+    SOCPERF_PRINT_DEBUG("SOCPERF_PCI_Read_From_Memory_Address: value at this physical address:%x\n",value);
+
+    iounmap(base);
+
+    return OS_SUCCESS;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn extern int SOCPERF_PCI_Write_To_Memory_Address(addr, val)
+ *
+ * @param   addr   - physical address in mmio
+ * @param   value  - value to be written
+ *
+ * @return  status
+ *
+ * @brief   Write to memory mapped i/o physical location
+ *
+ */
+extern int
+SOCPERF_PCI_Write_To_Memory_Address (
+    U32 addr,
+    U32 val
+)
+{
+    U32 aligned_addr, offset;
+    PVOID base;
+
+    if (addr <= 0) {
+        return OS_INVALID;
+    }
+
+    SOCPERF_PRINT_DEBUG("SOCPERF_PCI_Write_To_Memory_Address: writing physical address:%x with value:%x\n",addr,val);
+    offset       = addr & ~PAGE_MASK;
+    aligned_addr = addr & PAGE_MASK;
+    SOCPERF_PRINT_DEBUG("SOCPERF_PCI_Write_To_Memory_Address: aligned physical address:%x,offset:%x\n",aligned_addr,offset);
+
+    base = ioremap_nocache(aligned_addr, PAGE_SIZE);
+    if (base == NULL) {
+        return OS_INVALID;
+    }
+
+    writel(val,base+offset);
+
+    iounmap(base);
+
+    return OS_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn extern int SOCPERF_PCI_Read_Ulong(pci_address)
+ *
+ * @param    pci_address - PCI configuration address
+ *
+ * @return  value at this location
+ *
+ * @brief   Reads a ULONG from PCI configuration space
+ *
+ */
+extern int
+SOCPERF_PCI_Read_Ulong (
+    U32 pci_address
+)
+{
+    U32 temp_ulong = 0;
+
+    outl(pci_address,PCI_ADDR_IO);
+    temp_ulong = inl(PCI_DATA_IO);
+
+    return temp_ulong;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn extern int SOCPERF_PCI_Write_Ulong(addr, val)
+ *
+ * @param    pci_address - PCI configuration address
+ * @param    value - Value to be written
+ *
+ * @return  status
+ *
+ * @brief   Writes a ULONG to PCI configuration space
+ *
+ */
+extern void
+SOCPERF_PCI_Write_Ulong (
+    U32 pci_address,
+    U32 value
+)
+{
+    outl(pci_address, PCI_ADDR_IO);
+    outl(value, PCI_DATA_IO);
+
+    return;
+}
diff --git a/drivers/misc/intel/sepdk/socperf/soc_uncore.c b/drivers/misc/intel/sepdk/socperf/soc_uncore.c
new file mode 100644
index 000000000000..f3ab3bd2ae04
--- /dev/null
+++ b/drivers/misc/intel/sepdk/socperf/soc_uncore.c
@@ -0,0 +1,903 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2013-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2013-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#include "lwpmudrv_defines.h"
+#include <linux/version.h>
+#include <linux/fs.h>
+
+#include "lwpmudrv_types.h"
+#include "lwpmudrv_ecb.h"
+#include "lwpmudrv_struct.h"
+
+#include "socperfdrv.h"
+#include "control.h"
+#include "soc_uncore.h"
+#include "inc/ecb_iterators.h"
+#include "inc/pci.h"
+
+#if defined (PCI_HELPERS_API)
+#include <asm/intel_mid_pcihelpers.h>
+#elif defined(DRV_CHROMEOS)
+#include <linux/pci.h>
+static struct pci_dev *pci_root = NULL;
+#define PCI_DEVFN(slot, func)   ((((slot) & 0x1f) << 3) | ((func) & 0x07))
+#endif
+
+static U32            counter_overflow[UNCORE_MAX_COUNTERS];
+static U32            counter_port_id         = 0;
+static U64            trace_virtual_address = 0;
+
+
+#if defined(DRV_CHROMEOS)
+/*!
+ * @fn          static VOID get_pci_device_handle(U32   bus_no,
+                                                  U32   dev_no,
+                                                  U32   func_no)
+ *
+ * @brief       Get PCI device handle to be able to read/write
+ *
+ * @param       bus_no      - bus number
+ *              dev_no      - device number
+ *              func_no     - function number
+ *
+ * @return      None
+ *
+ * <I>Special Notes:</I>
+ */
+static void
+get_pci_device_handle (
+    U32   bus_no,
+    U32   dev_no,
+    U32   func_no
+)
+{
+    if (!pci_root) {
+        pci_root = pci_get_bus_and_slot(bus_no, PCI_DEVFN(dev_no, func_no));
+        if (!pci_root) {
+            SOCPERF_PRINT_DEBUG("Unable to get pci device handle");
+        }
+    }
+
+    return;
+}
+#endif
+
+/*!
+ * @fn          static VOID write_To_Register(U32   bus_no,
+                                              U32   dev_no,
+                                              U32   func_no,
+                                              U32   port_id,
+                                              U32   op_code,
+                                              U64   mmio_offset,
+                                              ULONG value)
+ *
+ * @brief       Reads Uncore programming
+ *
+ * @param       bus_no      - bus number
+ *              dev_no      - device number
+ *              func_no     - function number
+ *              port_id     - port id
+ *              op_code     - operation code
+ *              mmio_offset - mmio offset
+ *              value       - data to be written to the register
+ *
+ * @return      None
+ *
+ * <I>Special Notes:</I>
+ */
+static void
+write_To_Register (
+    U32   bus_no,
+    U32   dev_no,
+    U32   func_no,
+    U32   port_id,
+    U32   op_code,
+    U64   mmio_offset,
+    ULONG value
+)
+{
+    U32 cmd  = 0;
+    U32 mmio_offset_lo;
+    U32 mmio_offset_hi;
+#if !defined(DRV_CHROMEOS) && !defined(PCI_HELPERS_API)
+    U32 pci_address;
+#endif
+
+    mmio_offset_hi = mmio_offset & SOC_UNCORE_OFFSET_HI_MASK;
+    mmio_offset_lo = mmio_offset & SOC_UNCORE_OFFSET_LO_MASK;
+    cmd            = (op_code << SOC_UNCORE_OP_CODE_SHIFT) +
+                       (port_id << SOC_UNCORE_PORT_ID_SHIFT) +
+                       (mmio_offset_lo << 8) +
+                       (SOC_UNCORE_BYTE_ENABLES << 4);
+    SOCPERF_PRINT_DEBUG("write off=%llx value=%x\n", mmio_offset, value);
+
+#if defined (PCI_HELPERS_API)
+    intel_mid_msgbus_write32_raw_ext(cmd, mmio_offset_hi, value);
+#elif defined(DRV_CHROMEOS)
+    if (!pci_root) {
+        get_pci_device_handle(bus_no, dev_no, func_no);
+    }
+    pci_write_config_dword(pci_root, SOC_UNCORE_MDR_REG_OFFSET, value);
+    pci_write_config_dword(pci_root, SOC_UNCORE_MCRX_REG_OFFSET, mmio_offset_hi);
+    pci_write_config_dword(pci_root, SOC_UNCORE_MCR_REG_OFFSET, cmd);
+#else
+    pci_address = FORM_PCI_ADDR(bus_no, dev_no, func_no, SOC_UNCORE_MDR_REG_OFFSET);
+    SOCPERF_PCI_Write_Ulong((ULONG)pci_address, (ULONG)value);
+    pci_address = FORM_PCI_ADDR(bus_no, dev_no, func_no, SOC_UNCORE_MCRX_REG_OFFSET);
+    SOCPERF_PCI_Write_Ulong((ULONG)pci_address, mmio_offset_hi);
+    pci_address = FORM_PCI_ADDR(bus_no, dev_no, func_no, SOC_UNCORE_MCR_REG_OFFSET);
+    SOCPERF_PCI_Write_Ulong((ULONG)pci_address, cmd);
+#endif
+
+    return;
+}
+
+/*!
+ * @fn          static ULONG read_From_Register(U32 bus_no,
+                                                U32 dev_no,
+                                                U32 func_no,
+                                                U32 port_id,
+                                                U32 op_code,
+                                                U64 mmio_offset)
+ *
+ * @brief       Reads Uncore programming info
+ *
+ * @param       bus_no      - bus number
+ *              dev_no      - device number
+ *              func_no     - function number
+ *              port_id     - port id
+ *              op_code     - operation code
+ *              mmio_offset - mmio offset
+ *
+ * @return      data from the counter
+ *
+ * <I>Special Notes:</I>
+ */
+static void
+read_From_Register (
+    U32  bus_no,
+    U32  dev_no,
+    U32  func_no,
+    U32  port_id,
+    U32  op_code,
+    U64  mmio_offset,
+    U32 *data_val
+)
+{
+    U32 data = 0;
+    U32 cmd  = 0;
+    U32 mmio_offset_hi;
+    U32 mmio_offset_lo;
+#if !defined(DRV_CHROMEOS) && !defined(PCI_HELPERS_API)
+    U32 pci_address;
+#endif
+
+    mmio_offset_hi = mmio_offset & SOC_UNCORE_OFFSET_HI_MASK;
+    mmio_offset_lo = mmio_offset & SOC_UNCORE_OFFSET_LO_MASK;
+    cmd      = (op_code << SOC_UNCORE_OP_CODE_SHIFT) +
+                (port_id << SOC_UNCORE_PORT_ID_SHIFT) +
+                (mmio_offset_lo << 8) +
+                (SOC_UNCORE_BYTE_ENABLES << 4);
+
+#if defined (PCI_HELPERS_API)
+    data = intel_mid_msgbus_read32_raw_ext(cmd, mmio_offset_hi);
+#elif defined(DRV_CHROMEOS)
+    if (!pci_root) {
+        get_pci_device_handle(bus_no, dev_no, func_no);
+    }
+    pci_write_config_dword(pci_root, SOC_UNCORE_MCRX_REG_OFFSET, mmio_offset_hi);
+    pci_write_config_dword(pci_root, SOC_UNCORE_MCR_REG_OFFSET, cmd);
+    pci_read_config_dword(pci_root, SOC_UNCORE_MDR_REG_OFFSET, &data);
+#else
+    pci_address = FORM_PCI_ADDR(bus_no, dev_no, func_no, SOC_UNCORE_MCRX_REG_OFFSET);
+    SOCPERF_PCI_Write_Ulong((ULONG)pci_address, mmio_offset_hi);
+    pci_address = FORM_PCI_ADDR(bus_no, dev_no, func_no, SOC_UNCORE_MCR_REG_OFFSET);
+    SOCPERF_PCI_Write_Ulong((ULONG)pci_address, cmd);
+    pci_address = FORM_PCI_ADDR(bus_no, dev_no, func_no, SOC_UNCORE_MDR_REG_OFFSET);
+    data = SOCPERF_PCI_Read_Ulong(pci_address);
+#endif
+    SOCPERF_PRINT_DEBUG("read off=%llx value=%x\n", mmio_offset, data);
+    if (data_val) {
+        *data_val = data;
+    }
+
+    return;
+}
+
+/*!
+ * @fn          static VOID uncore_Reset_Counters(U32 dev_idx)
+ *
+ * @brief       Reset counters
+ *
+ * @param       dev_idx - device index
+ *
+ * @return      None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Reset_Counters (
+    U32 dev_idx
+)
+{
+    U32 data_reg   = 0;
+
+    if (counter_port_id != 0) {
+        FOR_EACH_PCI_REG_RAW(pecb, i, dev_idx) {
+            if (ECB_entries_reg_type(pecb,i) == PMU_REG_EVENT_SELECT) {
+                data_reg = i + ECB_operations_register_len(pecb, PMU_OPERATION_WRITE);
+                if (ECB_entries_reg_type(pecb,data_reg) == PMU_REG_DATA) {
+                    write_To_Register(ECB_entries_bus_no(pecb, data_reg),
+                                      ECB_entries_dev_no(pecb, data_reg),
+                                      ECB_entries_func_no(pecb, data_reg),
+                                      counter_port_id,
+                                      SOC_COUNTER_WRITE_OP_CODE,
+                                      ECB_entries_reg_offset(pecb, data_reg),
+                                      (ULONG)0);
+                }
+                write_To_Register(ECB_entries_bus_no(pecb, i),
+                                  ECB_entries_dev_no(pecb, i),
+                                  ECB_entries_func_no(pecb, i),
+                                  counter_port_id,
+                                  SOC_COUNTER_WRITE_OP_CODE,
+                                  ECB_entries_reg_offset(pecb,i),
+                                  (ULONG)SOC_UNCORE_STOP);
+            }
+        } END_FOR_EACH_PCI_REG_RAW;
+    }
+
+    return;
+}
+
+/*!
+ * @fn          static VOID uncore_Write_PMU(VOID*)
+ *
+ * @brief       Initial write of PMU registers
+ *              Walk through the entries and write the value of the register accordingly.
+ *              When current_group = 0, then this is the first time this routine is called,
+ *
+ * @param       param - device index
+ *
+ * @return      None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Write_PMU (
+    VOID  *param
+)
+{
+    U32                        dev_idx;
+    ECB                        pecb;
+    DRV_PCI_DEVICE_ENTRY       dpden;
+    U32                        pci_address;
+    U32                        bar_lo;
+    U64                        bar_hi;
+    U64                        final_bar;
+    U64                        physical_address;
+    U32                        dev_index       = 0;
+    S32                        bar_list[SOC_UNCORE_MAX_PCI_DEVICES];
+    U32                        bar_index       = 0;
+    U32                        map_size        = 0;
+    U64                        virtual_address = 0;
+    U32                        bar_name        = 0;
+    DRV_PCI_DEVICE_ENTRY       curr_pci_entry  = NULL;
+    U32                        next_bar_offset = 0;
+    U64                        mmio_offset     = 0;
+    U64                        map_base        = 0;
+    U32                        i               = 0;
+    U32                        cur_grp;
+
+    dev_idx  = *((U32*)param);
+    if (device_uncore == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: NULL device_uncore!\n");
+        return;
+    }
+    cur_grp = LWPMU_DEVICE_cur_group(device_uncore);
+
+    pecb     = (ECB)LWPMU_DEVICE_PMU_register_data(device_uncore)[cur_grp];
+    if (pecb == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: null pecb!\n");
+        return;
+    }
+
+    for (dev_index = 0; dev_index < SOC_UNCORE_MAX_PCI_DEVICES; dev_index++) {
+        bar_list[dev_index] = -1;
+    }
+
+    // initialize the per-counter overflow numbers
+    for (i = 0; i < UNCORE_MAX_COUNTERS; i++) {
+        counter_overflow[i]         = 0;
+        socperf_pcb[0].last_uncore_count[i] = 0;
+    }
+
+    ECB_pcidev_entry_list(pecb) = (DRV_PCI_DEVICE_ENTRY)((S8*)pecb + ECB_pcidev_list_offset(pecb));
+    dpden = ECB_pcidev_entry_list(pecb);
+
+    uncore_Reset_Counters(dev_idx);
+
+    for (dev_index = 0; dev_index < ECB_num_pci_devices(pecb); dev_index++) {
+        curr_pci_entry = &dpden[dev_index];
+        bar_name       = DRV_PCI_DEVICE_ENTRY_bar_name(curr_pci_entry);
+        mmio_offset    = DRV_PCI_DEVICE_ENTRY_base_offset_for_mmio(curr_pci_entry);
+
+        if (counter_port_id == 0 && DRV_PCI_DEVICE_ENTRY_prog_type(curr_pci_entry) == UNC_COUNTER) {
+            counter_port_id = DRV_PCI_DEVICE_ENTRY_port_id(curr_pci_entry);
+            uncore_Reset_Counters(dev_idx);
+        }
+        if (DRV_PCI_DEVICE_ENTRY_config_type(curr_pci_entry) == UNC_PCICFG) {
+            if (bar_name == UNC_SOCPCI &&
+                (DRV_PCI_DEVICE_ENTRY_prog_type(curr_pci_entry) == UNC_MUX ||
+                DRV_PCI_DEVICE_ENTRY_prog_type(curr_pci_entry) == UNC_COUNTER) &&
+                DRV_PCI_DEVICE_ENTRY_operation(curr_pci_entry) == UNC_OP_WRITE) {
+                SOCPERF_PRINT_DEBUG("dev_index=%d OFFSET=%x VAL=%x\n", dev_index, DRV_PCI_DEVICE_ENTRY_base_offset_for_mmio(curr_pci_entry), DRV_PCI_DEVICE_ENTRY_value(curr_pci_entry));
+                write_To_Register(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                  DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                  DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                  DRV_PCI_DEVICE_ENTRY_port_id(curr_pci_entry),
+                                  DRV_PCI_DEVICE_ENTRY_op_code(curr_pci_entry),
+                                  DRV_PCI_DEVICE_ENTRY_base_offset_for_mmio(curr_pci_entry),
+                                  (ULONG)DRV_PCI_DEVICE_ENTRY_value(curr_pci_entry));
+            }
+            continue;
+        }
+        // UNC_MMIO programming
+        if (bar_list[bar_name] != -1) {
+            bar_index                                            = bar_list[bar_name];
+            virtual_address                                      = DRV_PCI_DEVICE_ENTRY_virtual_address(&dpden[bar_index]);
+            DRV_PCI_DEVICE_ENTRY_virtual_address(curr_pci_entry) = DRV_PCI_DEVICE_ENTRY_virtual_address(&dpden[bar_index]);
+            writel(DRV_PCI_DEVICE_ENTRY_value(curr_pci_entry), (U32*)(((char*)(UIOP)virtual_address)+mmio_offset));
+            continue;
+        }
+        pci_address     = FORM_PCI_ADDR(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                    DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                    DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                    DRV_PCI_DEVICE_ENTRY_bar_offset(curr_pci_entry));
+        bar_lo          = SOCPERF_PCI_Read_Ulong(pci_address);
+        next_bar_offset = DRV_PCI_DEVICE_ENTRY_bar_offset(curr_pci_entry)+SOC_UNCORE_NEXT_ADDR_OFFSET;
+        pci_address     = FORM_PCI_ADDR(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                    DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                    DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                    next_bar_offset);
+        bar_hi      = SOCPERF_PCI_Read_Ulong(pci_address);
+        final_bar   = (bar_hi << SOC_UNCORE_BAR_ADDR_SHIFT) | bar_lo;
+        final_bar  &= SOC_UNCORE_BAR_ADDR_MASK;
+        DRV_PCI_DEVICE_ENTRY_bar_address(curr_pci_entry) = final_bar;
+        physical_address = DRV_PCI_DEVICE_ENTRY_bar_address(curr_pci_entry);
+        if (physical_address) {
+            map_size = SOC_UNCORE_OTHER_BAR_MMIO_PAGE_SIZE;
+            map_base = (mmio_offset/map_size)*map_size;
+            if (mmio_offset > map_size) {
+                physical_address = physical_address + map_base;
+            }
+        }
+    }
+
+    return;
+}
+
+
+
+/*!
+ * @fn         static VOID uncore_Disable_PMU(PVOID)
+ *
+ * @brief      Unmap the virtual address when sampling/driver stops
+ *
+ * @param      param - device index
+ *
+ * @return     None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Disable_PMU (
+    PVOID  param
+)
+{
+    U32 dev_idx   = *((U32*)param);
+
+    if (GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_PREPARE_STOP) {
+        uncore_Reset_Counters(dev_idx);
+    }
+
+    return;
+}
+
+
+/*!
+ * @fn         static VOID uncore_Stop_Mem(VOID)
+ *
+ * @brief      Stop trace
+ *
+ * @param      param - None
+ *
+ * @return     None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Stop_Mem (
+    VOID
+)
+{
+    ECB                   pecb;
+    DRV_PCI_DEVICE_ENTRY  dpden;
+    U32                   bar_name        = 0;
+    DRV_PCI_DEVICE_ENTRY  curr_pci_entry  = NULL;
+    U64                   mmio_offset     = 0;
+    U32                   dev_index       = 0;
+    U32                   data_val        = 0;
+    U32                   cur_grp;
+
+    if (device_uncore == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: NULL device_uncore!\n");
+        return;
+    }
+    cur_grp = LWPMU_DEVICE_cur_group(device_uncore);
+
+    pecb     = (ECB)LWPMU_DEVICE_PMU_register_data(device_uncore)[cur_grp];
+    if (pecb == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: null pecb!\n");
+        return;
+    }
+
+    ECB_pcidev_entry_list(pecb) = (DRV_PCI_DEVICE_ENTRY)((S8*)pecb + ECB_pcidev_list_offset(pecb));
+    dpden = ECB_pcidev_entry_list(pecb);
+
+    for (dev_index = 0; dev_index < ECB_num_pci_devices(pecb); dev_index++) {
+        curr_pci_entry = &dpden[dev_index];
+        bar_name       = DRV_PCI_DEVICE_ENTRY_bar_name(curr_pci_entry);
+        mmio_offset    = DRV_PCI_DEVICE_ENTRY_base_offset_for_mmio(curr_pci_entry);
+
+        if (DRV_PCI_DEVICE_ENTRY_prog_type(curr_pci_entry) == UNC_STOP &&
+            DRV_PCI_DEVICE_ENTRY_config_type(curr_pci_entry) == UNC_PCICFG &&
+            bar_name == UNC_SOCPCI &&
+            DRV_PCI_DEVICE_ENTRY_operation(curr_pci_entry) == UNC_OP_READ) {
+                SOCPERF_PRINT_DEBUG("op=%d port=%d offset=%x val=%x\n",
+                                DRV_PCI_DEVICE_ENTRY_op_code(curr_pci_entry),
+                                DRV_PCI_DEVICE_ENTRY_port_id(curr_pci_entry),
+                                mmio_offset,
+                                data_val);
+                read_From_Register(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                   DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                   DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                   DRV_PCI_DEVICE_ENTRY_port_id(curr_pci_entry),
+                                   SOC_COUNTER_READ_OP_CODE,
+                                   mmio_offset,
+                                   &data_val);
+                SOCPERF_PRINT_DEBUG("op=%d port=%d offset=%x val=%x\n",
+                                DRV_PCI_DEVICE_ENTRY_op_code(curr_pci_entry),
+                                DRV_PCI_DEVICE_ENTRY_port_id(curr_pci_entry),
+                                mmio_offset,
+                                data_val);
+                write_To_Register(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                  DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                  DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                  DRV_PCI_DEVICE_ENTRY_port_id(curr_pci_entry),
+                                  SOC_COUNTER_WRITE_OP_CODE,
+                                  mmio_offset,
+                                  (ULONG)(data_val | 0x2000));
+        }
+    }
+
+    return;
+}
+
+/*!
+ * @fn         static VOID uncore_Initialize(PVOID)
+ *
+ * @brief      Initialize any registers or addresses
+ *
+ * @param      param
+ *
+ * @return     None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Initialize (
+    VOID  *param
+)
+{
+    return;
+}
+
+
+/*!
+ * @fn         static VOID uncore_Clean_Up(PVOID)
+ *
+ * @brief      Reset any registers or addresses
+ *
+ * @param      param
+ *
+ * @return     None
+ *
+ * <I>Special Notes:</I>
+ */
+static VOID
+uncore_Clean_Up (
+    VOID   *param
+)
+{
+    if (trace_virtual_address) {
+        iounmap((void*)(UIOP)trace_virtual_address);
+        trace_virtual_address = 0;
+    }
+    return;
+}
+
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn uncore_Read_Data()
+ *
+ * @param    None
+ *
+ * @return   None     No return needed
+ *
+ * @brief    Read the counters
+ *
+ */
+static VOID
+uncore_Read_Data (
+    PVOID data_buffer
+)
+{
+    U32              event_id    = 0;
+    U64             *data;
+    int              data_index;
+    U32              data_val    = 0;
+    U32              data_reg    = 0;
+    U64              total_count = 0;
+    U32              event_index = 0;
+    U32              cur_grp;
+
+    if (device_uncore == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: NULL device_uncore!\n");
+        return;
+    }
+    cur_grp = LWPMU_DEVICE_cur_group(device_uncore);
+
+    if (GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_UNINITIALIZED ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_IDLE          ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_RESERVED      ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_PREPARE_STOP  ||
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_STOPPED) {
+        SOCPERF_PRINT_ERROR("ERROR: RETURING EARLY from Read_Data\n");
+        return;
+    }
+
+    data       = data_buffer;
+    data_index = 0;
+
+    preempt_disable();
+
+    // Write GroupID
+    data[data_index] = cur_grp + 1;
+    // Increment the data index as the event id starts from zero
+    data_index++;
+
+    FOR_EACH_PCI_REG_RAW(pecb, i, dev_idx) {
+        if (ECB_entries_reg_type(pecb,i) == PMU_REG_EVENT_SELECT) {
+            write_To_Register(ECB_entries_bus_no(pecb, i),
+                              ECB_entries_dev_no(pecb, i),
+                              ECB_entries_func_no(pecb, i),
+                              counter_port_id,
+                              SOC_COUNTER_WRITE_OP_CODE,
+                              ECB_entries_reg_offset(pecb,i),
+                              (ULONG)SOC_UNCORE_SAMPLE_DATA);
+
+            data_reg = i + ECB_operations_register_len(pecb, PMU_OPERATION_WRITE);
+            if (ECB_entries_reg_type(pecb,data_reg) == PMU_REG_DATA) {
+                read_From_Register(ECB_entries_bus_no(pecb, data_reg),
+                                   ECB_entries_dev_no(pecb, data_reg),
+                                   ECB_entries_func_no(pecb, data_reg),
+                                   counter_port_id,
+                                   SOC_COUNTER_READ_OP_CODE,
+                                   ECB_entries_reg_offset(pecb,data_reg),
+                                   &data_val);
+                if (data_val < socperf_pcb[0].last_uncore_count[event_index]) {
+                    counter_overflow[event_index]++;
+                }
+                socperf_pcb[0].last_uncore_count[event_index] = data_val;
+                total_count = data_val + counter_overflow[event_index]*UNCORE_MAX_COUNT;
+                event_index++;
+                data[data_index+event_id] = total_count;
+                event_id++;
+            }
+        }
+
+    } END_FOR_EACH_PCI_REG_RAW;
+
+    preempt_enable();
+
+    return;
+}
+
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn uncore_Create_Mem()
+ *
+ * @param    None
+ *
+ * @return   None     No return needed
+ *
+ * @brief    Read the counters
+ *
+ */
+static VOID
+uncore_Create_Mem (
+    U32  memory_size,
+    U64 *trace_buffer
+)
+{
+    ECB                        pecb;
+    DRV_PCI_DEVICE_ENTRY       dpden;
+    U32                        bar_name        = 0;
+    DRV_PCI_DEVICE_ENTRY       curr_pci_entry  = NULL;
+    U64                        mmio_offset     = 0;
+    U32                        dev_index       = 0;
+    U32                        data_val        = 0;
+    U32                        reg_index       = 0;
+    U64                        physical_high   = 0;
+    U64                        odla_physical_address = 0;
+
+    if (device_uncore == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: NULL device_uncore!\n");
+        return;
+    }
+    pecb     = (ECB)LWPMU_DEVICE_PMU_register_data(device_uncore)[0];
+    if (pecb == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: null pecb!\n");
+        return;
+    }
+
+    if (!trace_buffer) {
+        return;
+    }
+
+    ECB_pcidev_entry_list(pecb) = (DRV_PCI_DEVICE_ENTRY)((S8*)pecb + ECB_pcidev_list_offset(pecb));
+    dpden = ECB_pcidev_entry_list(pecb);
+
+    for (dev_index = 0; dev_index < ECB_num_pci_devices(pecb); dev_index++) {
+        curr_pci_entry = &dpden[dev_index];
+        bar_name       = DRV_PCI_DEVICE_ENTRY_bar_name(curr_pci_entry);
+        mmio_offset    = DRV_PCI_DEVICE_ENTRY_base_offset_for_mmio(curr_pci_entry);
+
+        if (DRV_PCI_DEVICE_ENTRY_prog_type(curr_pci_entry) == UNC_MEMORY &&
+            DRV_PCI_DEVICE_ENTRY_config_type(curr_pci_entry) == UNC_PCICFG &&
+            bar_name == UNC_SOCPCI &&
+            DRV_PCI_DEVICE_ENTRY_operation(curr_pci_entry) == UNC_OP_WRITE) {
+                read_From_Register(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                                   DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                                   DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                                   DRV_PCI_DEVICE_ENTRY_port_id(curr_pci_entry),
+                                   SOC_COUNTER_READ_OP_CODE,
+                                   mmio_offset,
+                                   &data_val);
+                if (reg_index == 1) {
+                    odla_physical_address = data_val;
+                }
+                else if (reg_index == 2) {
+                    physical_high = data_val;
+                    odla_physical_address = odla_physical_address | (physical_high << 32);
+                }
+                SOCPERF_PRINT_DEBUG("op=%d port=%d offset=%x val=%x\n",
+                                DRV_PCI_DEVICE_ENTRY_op_code(curr_pci_entry),
+                                DRV_PCI_DEVICE_ENTRY_port_id(curr_pci_entry),
+                                mmio_offset,
+                                data_val);
+                reg_index++;
+        }
+        continue;
+    }
+    SOCPERF_PRINT_DEBUG("Physical Address=%llx\n", odla_physical_address);
+    if (odla_physical_address) {
+        trace_virtual_address = (U64) (UIOP) ioremap_nocache(odla_physical_address, 1024*sizeof(U64));
+        SOCPERF_PRINT_DEBUG("PHY=%llx ODLA VIRTUAL ADDRESS=%llx\n", odla_physical_address, trace_virtual_address);
+        if (trace_buffer) {
+           *trace_buffer = odla_physical_address;
+        }
+    }
+
+    return;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn uncore_Check_Status()
+ *
+ * @param    None
+ *
+ * @return   None     No return needed
+ *
+ * @brief    Read the counters
+ *
+ */
+static VOID
+uncore_Check_Status (
+    U64 *trace_buffer,
+    U32 *num_entries
+)
+{
+    U32                        dev_index       = 0;
+    ECB                        pecb;
+    DRV_PCI_DEVICE_ENTRY       dpden;
+    U32                        bar_name        = 0;
+    DRV_PCI_DEVICE_ENTRY       curr_pci_entry  = NULL;
+    U64                        mmio_offset     = 0;
+    U32                        data_val        = 0;
+    U32                        data_index      = 0;
+
+    if (device_uncore == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: NULL device_uncore!\n");
+        return;
+    }
+    pecb  = (ECB)LWPMU_DEVICE_PMU_register_data(device_uncore)[0];
+    if (pecb == NULL) {
+        SOCPERF_PRINT_ERROR("ERROR: null pecb!\n");
+        return;
+    }
+    if (!trace_buffer) {
+        return;
+    }
+
+    ECB_pcidev_entry_list(pecb) = (DRV_PCI_DEVICE_ENTRY)((S8*)pecb + ECB_pcidev_list_offset(pecb));
+    dpden = ECB_pcidev_entry_list(pecb);
+
+    for (dev_index = 0; dev_index < ECB_num_pci_devices(pecb); dev_index++) {
+        curr_pci_entry = &dpden[dev_index];
+        bar_name       = DRV_PCI_DEVICE_ENTRY_bar_name(curr_pci_entry);
+        mmio_offset    = DRV_PCI_DEVICE_ENTRY_base_offset_for_mmio(curr_pci_entry);
+
+        if (DRV_PCI_DEVICE_ENTRY_prog_type(curr_pci_entry) == UNC_STATUS &&
+            DRV_PCI_DEVICE_ENTRY_config_type(curr_pci_entry) == UNC_PCICFG &&
+            bar_name == UNC_SOCPCI &&
+            DRV_PCI_DEVICE_ENTRY_operation(curr_pci_entry) == UNC_OP_READ) {
+            read_From_Register(DRV_PCI_DEVICE_ENTRY_bus_no(curr_pci_entry),
+                               DRV_PCI_DEVICE_ENTRY_dev_no(curr_pci_entry),
+                               DRV_PCI_DEVICE_ENTRY_func_no(curr_pci_entry),
+                               DRV_PCI_DEVICE_ENTRY_port_id(curr_pci_entry),
+                               SOC_COUNTER_READ_OP_CODE,
+                               mmio_offset,
+                               &data_val);
+            SOCPERF_PRINT_DEBUG("TRACE STATUS=%x\n", data_val);
+            trace_buffer[data_index]  = data_val;
+            data_index++;
+            continue;
+        }
+    }
+
+    if (num_entries) {
+        *num_entries = data_index;
+    }
+
+    return;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn uncore_Read_Mem()
+ *
+ * @param    None
+ *
+ * @return   None     No return needed
+ *
+ * @brief    Read the counters
+ *
+ */
+static VOID
+uncore_Read_Mem (
+    U64  start_address,
+    U64 *trace_buffer,
+    U32  num_entries
+)
+{
+    U32 data_index = 0;
+    U32 data_value = 0;
+
+    if (num_entries == 0 || !trace_buffer) {
+        return;
+    }
+    SOCPERF_PRINT_DEBUG("Reading memory for num_entries=%d from address=%llx\n", num_entries, trace_virtual_address);
+    for (data_index = 0; data_index < num_entries; data_index++) {
+        if (trace_virtual_address) {
+            data_value = readl((U64*)(UIOP)trace_virtual_address + data_index);
+
+            SOCPERF_PRINT_DEBUG("DATA VALUE=%llx\n", data_value);
+            *(trace_buffer + data_index) = data_value;
+        }
+    }
+
+    return;
+}
+
+/*
+ * Initialize the dispatch table
+ */
+DISPATCH_NODE  soc_uncore_dispatch =
+{
+    uncore_Initialize,                 // initialize
+    NULL,                              // destroy
+    uncore_Write_PMU,                  // write
+    uncore_Disable_PMU,                // freeze
+    NULL,                              // restart
+    NULL,                              // read
+    NULL,                              // check for overflow
+    NULL,
+    NULL,
+    uncore_Clean_Up,
+    NULL,
+    NULL,
+    NULL,
+    NULL,                              // read counts
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    uncore_Read_Data,
+    uncore_Create_Mem,
+    uncore_Check_Status,
+    uncore_Read_Mem,
+    uncore_Stop_Mem
+};
diff --git a/drivers/misc/intel/sepdk/socperf/socperfdrv.c b/drivers/misc/intel/sepdk/socperf/socperfdrv.c
new file mode 100644
index 000000000000..82f042b01911
--- /dev/null
+++ b/drivers/misc/intel/sepdk/socperf/socperfdrv.c
@@ -0,0 +1,1623 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#include "lwpmudrv_defines.h"
+
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <asm/page.h>
+#include <linux/cdev.h>
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/syscalls.h>
+#include <asm/unistd.h>
+#include <linux/compat.h>
+
+#include "lwpmudrv_types.h"
+#include "rise_errors.h"
+#include "lwpmudrv_version.h"
+#include "lwpmudrv_ecb.h"
+#include "lwpmudrv_struct.h"
+#include "lwpmudrv_ioctl.h"
+#include "inc/ecb_iterators.h"
+#include "socperfdrv.h"
+#include "control.h"
+#include "inc/utility.h"
+
+
+MODULE_AUTHOR("Copyright(C) 2007-2018 Intel Corporation");
+MODULE_VERSION(SOCPERF_NAME"_"SOCPERF_VERSION_STR);
+MODULE_LICENSE("Dual BSD/GPL");
+
+typedef struct LWPMU_DEV_NODE_S  LWPMU_DEV_NODE;
+typedef        LWPMU_DEV_NODE   *LWPMU_DEV;
+
+struct LWPMU_DEV_NODE_S {
+  long              buffer;
+  struct semaphore  sem;
+  struct cdev       cdev;
+};
+
+#define LWPMU_DEV_buffer(dev)      (dev)->buffer
+#define LWPMU_DEV_sem(dev)         (dev)->sem
+#define LWPMU_DEV_cdev(dev)        (dev)->cdev
+
+/* Global variables of the driver */
+SOCPERF_VERSION_NODE    socperf_drv_version;
+U64                    *read_unc_ctr_info     = NULL;
+DISPATCH                dispatch_uncore       = NULL;
+DRV_CONFIG              drv_cfg               = NULL;
+EVENT_CONFIG            socperf_global_ec             = NULL;
+volatile S32            socperf_abnormal_terminate    = 0;
+LWPMU_DEV               socperf_control          = NULL;
+
+LWPMU_DEVICE            device_uncore           = NULL;
+CPU_STATE               socperf_pcb                   = NULL;
+size_t                  socperf_pcb_size              = 0;
+
+#if defined(DRV_USE_UNLOCKED_IOCTL)
+static   struct mutex   ioctl_lock;
+#endif
+
+#define  PMU_DEVICES            1   // pmu control
+
+static dev_t     lwpmu_DevNum;  /* the major and minor parts for SOCPERF base */
+
+static struct class         *pmu_class   = NULL;
+
+#define DRV_DEVICE_DELIMITER "!"
+
+#if !defined(DRV_USE_UNLOCKED_IOCTL)
+#define MUTEX_INIT(lock)
+#define MUTEX_LOCK(lock)
+#define MUTEX_UNLOCK(lock)
+#else
+#define MUTEX_INIT(lock)     mutex_init(&(lock));
+#define MUTEX_LOCK(lock)     mutex_lock(&(lock))
+#define MUTEX_UNLOCK(lock)   mutex_unlock(&(lock))
+#endif
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn  static OS_STATUS lwpmudrv_Initialize_State(void)
+ *
+ * @param none
+ *
+ * @return OS_STATUS
+ *
+ * @brief  Allocates the memory needed at load time.  Initializes all the
+ * @brief  necessary state variables with the default values.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Initialize_State (
+    VOID
+)
+{
+    S32 i, max_cpu_id = 0;
+
+    for_each_possible_cpu(i) {
+        if (cpu_present(i)) {
+            if (i > max_cpu_id) {
+                max_cpu_id = i;
+            }
+        }
+    }
+    max_cpu_id++;
+
+    /*
+     *  Machine Initializations
+     *  Abstract this information away into a separate entry point
+     *
+     *  Question:  Should we allow for the use of Hot-cpu
+     *    add/subtract functionality while the driver is executing?
+     */
+    if (max_cpu_id > num_present_cpus()) {
+         GLOBAL_STATE_num_cpus(socperf_driver_state)     = max_cpu_id;
+    }
+    else {
+         GLOBAL_STATE_num_cpus(socperf_driver_state)     = num_present_cpus();
+    }
+    GLOBAL_STATE_active_cpus(socperf_driver_state)       = num_online_cpus();
+    GLOBAL_STATE_cpu_count(socperf_driver_state)         = 0;
+    GLOBAL_STATE_dpc_count(socperf_driver_state)         = 0;
+    GLOBAL_STATE_num_em_groups(socperf_driver_state)     = 0;
+    GLOBAL_STATE_current_phase(socperf_driver_state)     = DRV_STATE_UNINITIALIZED;
+
+    SOCPERF_PRINT_DEBUG("lwpmudrv_Initialize_State: num_cpus=%d, active_cpus=%d\n",
+                    GLOBAL_STATE_num_cpus(socperf_driver_state),
+                    GLOBAL_STATE_active_cpus(socperf_driver_state));
+
+    return OS_SUCCESS;
+}
+
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn       VOID SOCPERF_Read_Data
+ *
+ * @brief    Reads counter data
+ *
+ * @param    param   data_buffer - buffer for reading counter data.
+ *
+ * @return  None
+ *
+ * <I>Special Notes:</I>
+ *              <NONE>
+ */
+extern  VOID
+SOCPERF_Read_Data3 (
+    PVOID data_buffer
+)
+{
+    if (dispatch_uncore && dispatch_uncore->read_current_data) {
+        dispatch_uncore->read_current_data(data_buffer);
+    }
+    SOCPERF_PRINT_DEBUG("SOCPERF_Read_Data called\n");
+    return ;
+}
+EXPORT_SYMBOL(SOCPERF_Read_Data3);
+
+/*********************************************************************
+ *  Internal Driver functions
+ *     Should be called only from the lwpmudrv_DeviceControl routine
+ *********************************************************************/
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn  static OS_STATUS lwpmudrv_Version(IOCTL_ARGS arg)
+ *
+ * @param arg - pointer to the IOCTL_ARGS structure
+ *
+ * @return OS_STATUS
+ *
+ * @brief  Local function that handles the LWPMU_IOCTL_VERSION call.
+ * @brief  Returns the version number of the kernel mode sampling.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Version (
+    IOCTL_ARGS   arg
+)
+{
+    OS_STATUS status;
+
+    // Check if enough space is provided for collecting the data
+    if ((arg->len_drv_to_usr != sizeof(U32))  || (arg->buf_drv_to_usr == NULL)) {
+        return OS_FAULT;
+    }
+
+    status = put_user(SOCPERF_VERSION_NODE_socperf_version(&socperf_drv_version), (U32 *)arg->buf_drv_to_usr);
+
+    return status;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn  static VOID lwpmudrv_Clean_Up(DRV_BOOL)
+ *
+ * @param  DRV_BOOL finish - Flag to call finish
+ *
+ * @return VOID
+ *
+ * @brief  Cleans up the memory allocation.
+ *
+ * <I>Special Notes</I>
+ */
+static VOID
+lwpmudrv_Clean_Up (
+    DRV_BOOL finish
+)
+{
+    U32  i = 0;
+
+    if (dispatch_uncore && dispatch_uncore->clean_up) {
+        dispatch_uncore->clean_up((VOID*) &i);
+    }
+
+    if (device_uncore) {
+        EVENT_CONFIG  ec;
+        if (LWPMU_DEVICE_PMU_register_data(device_uncore)) {
+            ec =  LWPMU_DEVICE_ec(device_uncore);
+            for (i = 0; i < EVENT_CONFIG_num_groups_unc(ec); i++) {
+                SOCPERF_Free_Memory(LWPMU_DEVICE_PMU_register_data(device_uncore)[i]);
+            }
+        }
+        LWPMU_DEVICE_pcfg(device_uncore) = SOCPERF_Free_Memory(LWPMU_DEVICE_pcfg(device_uncore));
+        LWPMU_DEVICE_ec(device_uncore)   = SOCPERF_Free_Memory(LWPMU_DEVICE_ec(device_uncore));
+        device_uncore = SOCPERF_Free_Memory(device_uncore);
+    }
+
+    socperf_pcb             = SOCPERF_Free_Memory(socperf_pcb);
+    socperf_pcb_size                = 0;
+    GLOBAL_STATE_num_em_groups(socperf_driver_state)   = 0;
+    GLOBAL_STATE_num_descriptors(socperf_driver_state) = 0;
+
+    return;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn  static OS_STATUS lwpmudrv_Initialize_Driver(PVOID buf_drv_to_usr, U32 len_drv_to_usr)
+ *
+ * @param  buf_drv_to_usr       - pointer to the input buffer
+ * @param  len_drv_to_usr   - size of the input buffer
+ *
+ * @return OS_STATUS
+ *
+ * @brief  Local function that handles the LWPMU_IOCTL_INIT_DRIVER call.
+ * @brief  Sets up the interrupt handler.
+ * @brief  Set up the output buffers/files needed to make the driver
+ * @brief  operational.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Initialize_Driver (
+    PVOID         buf_drv_to_usr,
+    U32           len_drv_to_usr
+)
+{
+    if (buf_drv_to_usr == NULL) {
+        SOCPERF_PRINT_ERROR("buf_drv_to_usr ERROR!\n");
+        return OS_FAULT;
+    }
+
+    drv_cfg = SOCPERF_Allocate_Memory(len_drv_to_usr);
+    if (!drv_cfg) {
+        SOCPERF_PRINT_ERROR("Memory allocation failure for drv_cfg!\n");
+        return OS_NO_MEM;
+    }
+
+    if (copy_from_user(drv_cfg, buf_drv_to_usr, len_drv_to_usr)) {
+        SOCPERF_PRINT_ERROR("Failed to copy from user");
+        return OS_FAULT;
+    }
+
+    return OS_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn  static OS_STATUS lwpmudrv_Initialize_Uncore(PVOID buf_drv_to_usr, U32 len_drv_to_usr)
+ *
+ * @param  buf_drv_to_usr       - pointer to the input buffer
+ * @param  len_drv_to_usr   - size of the input buffer
+ *
+ * @return OS_STATUS
+ *
+ * @brief  Local function that handles the LWPMU_IOCTL_INIT call.
+ * @brief  Sets up the interrupt handler.
+ * @brief  Set up the output buffers/files needed to make the driver
+ * @brief  operational.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Initialize_Uncore (
+    PVOID         buf_drv_to_usr,
+    U32           len_drv_to_usr
+)
+{
+    DEV_UNC_CONFIG  pcfg_unc;
+    U32  previous_state;
+    U32  i = 0;
+
+    SOCPERF_PRINT_DEBUG("Entered lwpmudrv_Initialize_UNC\n");
+    previous_state = cmpxchg(&GLOBAL_STATE_current_phase(socperf_driver_state),
+                             DRV_STATE_UNINITIALIZED,
+                             DRV_STATE_IDLE);
+
+    if (previous_state != DRV_STATE_UNINITIALIZED) {
+        SOCPERF_PRINT_ERROR("OS_IN_PROGRESS error!\n");
+        return OS_IN_PROGRESS;
+    }
+    /*
+     *   Program State Initializations:
+     *   Foreach device, copy over pcfg_unc and configure dispatch table
+     */
+    if (buf_drv_to_usr == NULL) {
+        SOCPERF_PRINT_ERROR("in_buff ERROR!\n");
+        return OS_FAULT;
+    }
+    if (len_drv_to_usr != sizeof(DEV_UNC_CONFIG_NODE)) {
+        SOCPERF_PRINT_ERROR("Got len_drv_to_usr=%d, expecting size=%d\n", len_drv_to_usr, (int)sizeof(DEV_UNC_CONFIG_NODE));
+        return OS_FAULT;
+    }
+
+    device_uncore = SOCPERF_Allocate_Memory(sizeof(LWPMU_DEVICE_NODE));
+    if (!device_uncore) {
+        SOCPERF_PRINT_ERROR("Memory allocation failure for device_uncore!\n");
+        return OS_NO_MEM;
+    }
+    socperf_pcb_size = GLOBAL_STATE_num_cpus(socperf_driver_state)*sizeof(CPU_STATE_NODE);
+    socperf_pcb      = SOCPERF_Allocate_Memory(socperf_pcb_size);
+    if (!socperf_pcb) {
+        SOCPERF_PRINT_ERROR("Memory allocation failure for socperf_pcb!\n");
+        return OS_NO_MEM;
+    }
+
+    // allocate memory
+    LWPMU_DEVICE_pcfg(device_uncore) = SOCPERF_Allocate_Memory(sizeof(DEV_UNC_CONFIG_NODE));
+    if (!LWPMU_DEVICE_pcfg(device_uncore)) {
+        SOCPERF_PRINT_ERROR("Memory allocation failure for LWPMU_DEVICE_pcfg(device_uncore)!\n");
+        return OS_NO_MEM;
+    }
+    // copy over pcfg_unc
+    if (copy_from_user(LWPMU_DEVICE_pcfg(device_uncore), buf_drv_to_usr, len_drv_to_usr)) {
+        SOCPERF_PRINT_ERROR("Failed to copy from user");
+        return OS_FAULT;
+    }
+    // configure dispatch from dispatch_id
+    pcfg_unc = (DEV_UNC_CONFIG)LWPMU_DEVICE_pcfg(device_uncore);
+
+    LWPMU_DEVICE_dispatch(device_uncore) = SOCPERF_UTILITY_Configure_CPU(DEV_UNC_CONFIG_dispatch_id(pcfg_unc));
+    if (LWPMU_DEVICE_dispatch(device_uncore) == NULL) {
+        SOCPERF_PRINT_ERROR("Unable to configure CPU");
+        return OS_FAULT;
+    }
+
+    LWPMU_DEVICE_em_groups_count(device_uncore) = 0;
+    LWPMU_DEVICE_cur_group(device_uncore)       = 0;
+    SOCPERF_PRINT_DEBUG("SocPerf Driver Config : uncore dispatch id   = %d\n", DEV_UNC_CONFIG_dispatch_id(pcfg_unc));
+    dispatch_uncore = LWPMU_DEVICE_dispatch(device_uncore);
+    if (dispatch_uncore && dispatch_uncore->init ) {
+        dispatch_uncore->init((VOID*) &i);
+    }
+
+    return OS_SUCCESS;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn  static OS_STATUS socperf_Terminate(void)
+ *
+ * @param  none
+ *
+ * @return OS_STATUS
+ *
+ * @brief  Local function that handles the LWPMUDRV_IOCTL_TERMINATE call.
+ * @brief  Cleans up the interrupt handler and resets the PMU state.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+socperf_Terminate (
+    VOID
+)
+{
+    U32            previous_state;
+
+    if (GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_UNINITIALIZED) {
+        return OS_SUCCESS;
+    }
+
+    previous_state = cmpxchg(&GLOBAL_STATE_current_phase(socperf_driver_state),
+                             DRV_STATE_STOPPED,
+                             DRV_STATE_UNINITIALIZED);
+    if (previous_state != DRV_STATE_STOPPED) {
+        SOCPERF_PRINT_ERROR("socperf_Terminate: Sampling is in progress, cannot terminate.\n");
+        return OS_IN_PROGRESS;
+    }
+
+    GLOBAL_STATE_current_phase(socperf_driver_state) = DRV_STATE_UNINITIALIZED;
+    lwpmudrv_Clean_Up(TRUE);
+
+    return OS_SUCCESS;
+}
+
+
+
+
+
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static OS_STATUS lwpmudrv_Trigger_Read(void)
+ *
+ * @param - none
+ *
+ * @return - OS_STATUS
+ *
+ * @brief Read the Counter Data.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Trigger_Read (
+    VOID
+)
+{
+    dispatch_uncore = LWPMU_DEVICE_dispatch(device_uncore);
+    if (dispatch_uncore && dispatch_uncore->trigger_read ) {
+        dispatch_uncore->trigger_read();
+    }
+
+    return OS_SUCCESS;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static OS_STATUS lwpmudrv_Init_PMU(void)
+ *
+ * @param - none
+ *
+ * @return - OS_STATUS
+ *
+ * @brief Initialize the PMU and the driver state in preparation for data collection.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Init_PMU (
+    VOID
+)
+{
+    U32        i = 0;
+
+    if (GLOBAL_STATE_current_phase(socperf_driver_state) != DRV_STATE_IDLE) {
+        return OS_IN_PROGRESS;
+    }
+    dispatch_uncore = LWPMU_DEVICE_dispatch(device_uncore);
+    if (dispatch_uncore && dispatch_uncore->write) {
+        dispatch_uncore->write((VOID *)&i);
+    }
+    SOCPERF_PRINT_DEBUG("lwpmudrv_Init_PMU: IOCTL_Init_PMU - finished initial Write\n");
+
+    return OS_SUCCESS;
+}
+
+
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static OS_STATUS lwpmudrv_Set_EM_Config_UNC(IOCTL_ARGS arg)
+ *
+ * @param arg - pointer to the IOCTL_ARGS structure
+ *
+ * @return OS_STATUS
+ *
+ * @brief  Set the number of em groups in the global state node.
+ * @brief  Also, copy the EVENT_CONFIG struct that has been passed in,
+ * @brief  into a global location for now.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Set_EM_Config_Uncore (
+    IOCTL_ARGS arg
+)
+{
+    EVENT_CONFIG    ec;
+    SOCPERF_PRINT_DEBUG("enter lwpmudrv_Set_EM_Config_UNC\n");
+    if (GLOBAL_STATE_current_phase(socperf_driver_state) != DRV_STATE_IDLE) {
+        return OS_IN_PROGRESS;
+    }
+
+    if (arg->buf_usr_to_drv == NULL || arg->len_usr_to_drv == 0) {
+        return OS_INVALID;
+    }
+    // allocate memory
+    LWPMU_DEVICE_ec(device_uncore) = SOCPERF_Allocate_Memory(sizeof(EVENT_CONFIG_NODE));
+    if (!LWPMU_DEVICE_ec(device_uncore)) {
+        SOCPERF_PRINT_ERROR("Memory allocation failure for LWPMU_DEVICE_ec(device_uncore)!\n");
+        return OS_NO_MEM;
+    }
+    if (copy_from_user(LWPMU_DEVICE_ec(device_uncore), arg->buf_usr_to_drv, arg->len_usr_to_drv)) {
+        return OS_FAULT;
+    }
+    // configure num_groups from ec of the specific device
+    ec = (EVENT_CONFIG)LWPMU_DEVICE_ec(device_uncore);
+    LWPMU_DEVICE_PMU_register_data(device_uncore) = SOCPERF_Allocate_Memory(EVENT_CONFIG_num_groups_unc(ec) *
+                                                                                   sizeof(VOID *));
+    if (!LWPMU_DEVICE_PMU_register_data(device_uncore)) {
+        SOCPERF_PRINT_ERROR("Memory allocation failure for LWPMU_DEVICE_PMU_register_data(device_uncore)!\n");
+        return OS_NO_MEM;
+    }
+    LWPMU_DEVICE_em_groups_count(device_uncore) = 0;
+
+    return OS_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static OS_STATUS socperf_Configure_Events_Uncore (IOCTL_ARGS arg)
+ *
+ * @param arg - pointer to the IOCTL_ARGS structure
+ *
+ * @return OS_STATUS
+ *
+ * @brief  Make a copy of the uncore registers that need to be programmed
+ * @brief  for the next event set used for event multiplexing
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+socperf_Configure_Events_Uncore (
+    IOCTL_ARGS arg
+)
+{
+    VOID              **PMU_register_data_unc;
+    S32               em_groups_count_unc;
+    ECB               ecb;
+    EVENT_CONFIG      ec_unc;
+    U32               group_id = 0;
+    ECB               in_ecb   = NULL;
+
+    if (GLOBAL_STATE_current_phase(socperf_driver_state) != DRV_STATE_IDLE) {
+        return OS_IN_PROGRESS;
+    }
+
+    em_groups_count_unc = LWPMU_DEVICE_em_groups_count(device_uncore);
+    PMU_register_data_unc = LWPMU_DEVICE_PMU_register_data(device_uncore);
+    ec_unc                = LWPMU_DEVICE_ec(device_uncore);
+
+    if (ec_unc == NULL) {
+        SOCPERF_PRINT_ERROR("socperf_Configure_Events_Uncore: ec_unc is NULL!\n");
+        return OS_INVALID;
+    }
+
+    if (em_groups_count_unc >= (S32)EVENT_CONFIG_num_groups_unc(ec_unc)) {
+        SOCPERF_PRINT_ERROR("socperf_Configure_Events_Uncore: Number of Uncore EM groups exceeded the initial configuration.");
+        return OS_INVALID;
+    }
+    if (arg->buf_usr_to_drv == NULL || arg->len_usr_to_drv < sizeof(ECB_NODE)) {
+        SOCPERF_PRINT_ERROR("socperf_Configure_Events_Uncore: args are invalid.");
+        return OS_INVALID;
+    }
+    //       size is in len_usr_to_drv, data is pointed to by buf_usr_to_drv
+    //
+    in_ecb = SOCPERF_Allocate_Memory(arg->len_usr_to_drv);
+    if (!in_ecb) {
+        SOCPERF_PRINT_ERROR("socperf_Configure_Events_Uncore: ECB memory allocation failed\n");
+        return OS_NO_MEM;
+    }
+    if (copy_from_user(in_ecb, arg->buf_usr_to_drv, arg->len_usr_to_drv)) {
+        SOCPERF_PRINT_ERROR("socperf_Configure_Events_Uncore: ECB copy failed\n");
+        in_ecb = SOCPERF_Free_Memory(in_ecb);
+        return OS_NO_MEM;
+    }
+
+    group_id                        = ECB_group_id(in_ecb);
+    if (group_id >= EVENT_CONFIG_num_groups_unc(ec_unc)) {
+        SOCPERF_PRINT_ERROR("socperf_Configure_Events_Uncore: group_id is larger than total number of groups\n");
+        in_ecb = SOCPERF_Free_Memory(in_ecb);
+        return OS_INVALID;
+    }
+
+    PMU_register_data_unc[group_id] = in_ecb;
+    if (!PMU_register_data_unc[group_id]) {
+        SOCPERF_PRINT_ERROR("socperf_Configure_Events_Uncore: ECB memory allocation failed\n");
+        in_ecb = SOCPERF_Free_Memory(in_ecb);
+        return OS_NO_MEM;
+    }
+
+    //
+    // Make a copy of the data for global use.
+    //
+    if (copy_from_user(PMU_register_data_unc[group_id], arg->buf_usr_to_drv, arg->len_usr_to_drv)) {
+        SOCPERF_PRINT_ERROR("socperf_Configure_Events_Uncore: ECB copy failed\n");
+        in_ecb = SOCPERF_Free_Memory(in_ecb);
+        return OS_NO_MEM;
+    }
+
+    // at this point, we know the number of uncore events for this device,
+    // so allocate the results buffer per thread for uncore only for event based uncore counting
+    if (em_groups_count_unc == 0) {
+        ecb = PMU_register_data_unc[0];
+        if (ecb == NULL) {
+            in_ecb = SOCPERF_Free_Memory(in_ecb);
+            return OS_INVALID;
+        }
+        LWPMU_DEVICE_num_events(device_uncore) = ECB_num_events(ecb);
+    }
+    LWPMU_DEVICE_em_groups_count(device_uncore) = group_id + 1;
+
+    return OS_SUCCESS;
+}
+
+
+
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static OS_STATUS socperf_Start(void)
+ *
+ * @param none
+ *
+ * @return OS_STATUS
+ *
+ * @brief  Local function that handles the LWPMU_IOCTL_START call.
+ * @brief  Set up the OS hooks for process/thread/load notifications.
+ * @brief  Write the initial set of MSRs.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+socperf_Start (
+    VOID
+)
+{
+    OS_STATUS  status       = OS_SUCCESS;
+    U32        previous_state;
+    U32        i = 0;
+
+    /*
+     * To Do: Check for state == STATE_IDLE and only then enable sampling
+     */
+    previous_state = cmpxchg(&GLOBAL_STATE_current_phase(socperf_driver_state),
+                             DRV_STATE_IDLE,
+                             DRV_STATE_RUNNING);
+    if (previous_state != DRV_STATE_IDLE) {
+        SOCPERF_PRINT_ERROR("socperf_Start: Unable to start sampling - State is %d\n",
+                        GLOBAL_STATE_current_phase(socperf_driver_state));
+        return OS_IN_PROGRESS;
+    }
+
+    if (dispatch_uncore && dispatch_uncore->restart) {
+        dispatch_uncore->restart((VOID*)&i);
+    }
+
+    return status;
+}
+
+/*
+ * @fn lwpmudrv_Prepare_Stop();
+ *
+ * @param        NONE
+ * @return       OS_STATUS
+ *
+ * @brief  Local function that handles the LWPMUDRV_IOCTL_STOP call.
+ * @brief  Cleans up the interrupt handler.
+ */
+static OS_STATUS
+socperf_Prepare_Stop (
+    VOID
+)
+{
+    U32 i = 0;
+    U32 current_state       = GLOBAL_STATE_current_phase(socperf_driver_state);
+
+    SOCPERF_PRINT_DEBUG("socperf_Prepare_Stop: About to stop sampling\n");
+    GLOBAL_STATE_current_phase(socperf_driver_state) = DRV_STATE_PREPARE_STOP;
+
+    if (current_state == DRV_STATE_UNINITIALIZED) {
+        return OS_SUCCESS;
+    }
+
+    if (dispatch_uncore && dispatch_uncore->freeze) {
+        dispatch_uncore->freeze((VOID*) &i);
+    }
+
+    return OS_SUCCESS;
+}
+
+/*
+ * @fn socperf_Finish_Stop();
+ *
+ * @param  NONE
+ * @return OS_STATUS
+ *
+ * @brief  Local function that handles the LWPMUDRV_IOCTL_STOP call.
+ * @brief  Cleans up the interrupt handler.
+ */
+static OS_STATUS
+socperf_Finish_Stop (
+    VOID
+)
+{
+    OS_STATUS  status        = OS_SUCCESS;
+
+    GLOBAL_STATE_current_phase(socperf_driver_state) = DRV_STATE_STOPPED;
+
+    return status;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static OS_STATUS lwpmudrv_Pause(void)
+ *
+ * @param - none
+ *
+ * @return OS_STATUS
+ *
+ * @brief Pause the collection
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Pause (
+    VOID
+)
+{
+    U32        previous_state;
+    U32        i = 0;
+
+    previous_state = cmpxchg(&GLOBAL_STATE_current_phase(socperf_driver_state),
+                             DRV_STATE_RUNNING,
+                             DRV_STATE_PAUSED);
+    if (previous_state == DRV_STATE_RUNNING) {
+        dispatch_uncore = LWPMU_DEVICE_dispatch(device_uncore);
+        if (dispatch_uncore && dispatch_uncore->freeze ) {
+            dispatch_uncore->freeze((VOID *)&i);
+        }
+    }
+    else {
+        if (previous_state == DRV_STATE_PAUSED) {
+            return VT_SAMP_IN_PAUSE_STATE;
+        }
+        SOCPERF_PRINT_ERROR("There is no sampling collection running at this time\n");
+        return VT_SAMP_IN_STOP_STATE;
+    }
+
+    return OS_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static NTSTATUS lwpmudrv_Resume(void)
+ *
+ * @param - none
+ *
+ * @return OS_STATUS
+ *
+ * @brief Resume the sampling after a pause.  Assumption, the pause duration
+ * @brief will be long enough for all interrupts to be processed and no
+ * @brief active sampling to occur.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Resume (
+    VOID
+)
+{
+    U32        previous_state;
+    U32        i = 0;
+
+    previous_state = cmpxchg(&GLOBAL_STATE_current_phase(socperf_driver_state),
+                             DRV_STATE_PAUSED,
+                             DRV_STATE_RUNNING);
+
+
+    if (previous_state == DRV_STATE_PAUSED) {
+        dispatch_uncore = LWPMU_DEVICE_dispatch(device_uncore);
+        if (dispatch_uncore && dispatch_uncore->restart ) {
+            dispatch_uncore->restart((VOID *)&i);
+        }
+        SOCPERF_PRINT_DEBUG("Resuming the sampling collection...\n");
+    }
+    else {
+        SOCPERF_PRINT_DEBUG("There is no paused sampling collection at this time.\n");
+    }
+
+    return OS_SUCCESS;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static OS_STATUS lwpmudrv_Read_Uncore_Counts(void buf_usr_to_drv, U32 len_usr_to_drv)
+ *
+ * @param - buf_usr_to_drv       - output buffer
+ *          len_usr_to_drv   - output buffer length
+ *
+ * @return - OS_STATUS
+ *
+ * @brief    Read the Counter Data.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Read_Uncore_Counts (
+    PVOID         buf_usr_to_drv,
+    U32           len_usr_to_drv
+)
+{
+    if (buf_usr_to_drv == NULL) {
+        SOCPERF_PRINT_ERROR("lwpmudrv_Read_Uncore_Counts: counter buffer is NULL\n");
+        return OS_FAULT;
+    }
+
+    if (dispatch_uncore && dispatch_uncore->read_current_data) {
+        dispatch_uncore->read_current_data(buf_usr_to_drv);
+    }
+
+    return OS_SUCCESS;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn  static OS_STATUS SOCPERF_Switch_Group(void)
+ *
+ * @param none
+ *
+ * @return OS_STATUS
+ *
+ * @brief Switch the current uncore group that is being collected.
+ *
+ * <I>Special Notes</I>
+ *     This routine is called from the user mode code to handle the multiple uncore group
+ *     situation.  4 distinct steps are taken:
+ *     Step 1: Pause the sampling
+ *     Step 2: Increment the current uncore group count
+ *     Step 3: Write the new group to the uncore PMU
+ *     Step 4: Resume sampling
+ */
+OS_STATUS
+SOCPERF_Switch_Group3 (
+    VOID
+)
+{
+    OS_STATUS       status        = OS_SUCCESS;
+    U32            current_state = GLOBAL_STATE_current_phase(socperf_driver_state);
+    U32            i = 0;
+    DEV_UNC_CONFIG     pcfg_unc;
+
+    SOCPERF_PRINT_DEBUG("Switching Uncore Group...\n");
+    if (current_state != DRV_STATE_RUNNING &&
+        current_state != DRV_STATE_PAUSED) {
+        return status;
+    }
+    status = lwpmudrv_Pause();
+    LWPMU_DEVICE_cur_group(device_uncore)++;
+    LWPMU_DEVICE_cur_group(device_uncore) %= LWPMU_DEVICE_em_groups_count(device_uncore);
+    dispatch_uncore = LWPMU_DEVICE_dispatch(device_uncore);
+    if (dispatch_uncore && dispatch_uncore->write ) {
+        dispatch_uncore->write((VOID *)&i);
+    }
+
+    pcfg_unc = (DEV_UNC_CONFIG)LWPMU_DEVICE_pcfg(device_uncore);
+    if (pcfg_unc && (DRV_CONFIG_start_paused(drv_cfg) == FALSE)) {
+        status = lwpmudrv_Resume();
+    }
+
+    return status;
+}
+EXPORT_SYMBOL(SOCPERF_Switch_Group3);
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static OS_STATUS lwpmudrv_Create_Mem(IOCTL_ARGS arg)
+ *
+ * @param - none
+ *
+ * @return - OS_STATUS
+ *
+ * @brief Read the Counter Data.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Create_Mem (
+    IOCTL_ARGS arg
+)
+{
+    U32   memory_size           = 0;
+    U64   trace_phys_address = 0;
+
+    if (arg->buf_usr_to_drv == NULL || arg->len_usr_to_drv == 0) {
+        SOCPERF_PRINT_ERROR("lwpmudrv_Create_Mem: Counter buffer is NULL\n");
+        return OS_FAULT;
+    }
+
+    if (copy_from_user(&memory_size, (U32*)arg->buf_usr_to_drv, sizeof(U32))) {
+        return OS_FAULT;
+    }
+
+    if (arg->buf_drv_to_usr == NULL || arg->len_drv_to_usr == 0) {
+        SOCPERF_PRINT_ERROR("lwpmudrv_Create_Mem: output buffer is NULL\n");
+        return OS_FAULT;
+    }
+    SOCPERF_PRINT_DEBUG("Read size=%llx\n", arg->len_drv_to_usr);
+    SOCPERF_PRINT_DEBUG("Write size=%llx\n", arg->len_usr_to_drv);
+    if (arg->len_drv_to_usr != sizeof(U64)) {
+        return OS_FAULT;
+    }
+
+    dispatch_uncore = LWPMU_DEVICE_dispatch(device_uncore);
+    if (dispatch_uncore && dispatch_uncore->create_mem) {
+        dispatch_uncore->create_mem(memory_size, &trace_phys_address);
+    }
+    else {
+        SOCPERF_PRINT_ERROR("dispatch table could not be called\n");
+    }
+
+    if (copy_to_user(arg->buf_drv_to_usr, (void*)&trace_phys_address, sizeof(U64))) {
+        return OS_FAULT;
+    }
+
+    return OS_SUCCESS;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static OS_STATUS lwpmudrv_Check_Status( IOCTL_ARGS arg)
+ *
+ * @param - none
+ *
+ * @return - OS_STATUS
+ *
+ * @brief Read the Counter Data.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Check_Status (
+    IOCTL_ARGS arg
+)
+{
+    U32   num_entries = 0;
+    U64  *status_data = 0;
+
+    if ((arg->len_drv_to_usr == 0) || (arg->buf_drv_to_usr == NULL)) {
+        return OS_FAULT;
+    }
+
+    status_data = SOCPERF_Allocate_Memory(arg->len_drv_to_usr);
+    if (dispatch_uncore && dispatch_uncore->check_status) {
+        dispatch_uncore->check_status(status_data,  &num_entries);
+    }
+
+    if (copy_to_user(arg->buf_drv_to_usr, (void*)status_data, num_entries*sizeof(U64))) {
+        SOCPERF_Free_Memory(status_data);
+        return OS_FAULT;
+    }
+    SOCPERF_Free_Memory(status_data);
+
+    return OS_SUCCESS;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static OS_STATUS lwpmudrv_Read_Mem( IOCTL_ARGS arg)
+ *
+ * @param - none
+ *
+ * @return - OS_STATUS
+ *
+ * @brief Read the Counter Data.
+ *
+ * <I>Special Notes</I>
+ */
+static OS_STATUS
+lwpmudrv_Read_Mem (
+ IOCTL_ARGS  arg
+)
+{
+    U64   start_address   = 0;
+    U64  *mem_address     = NULL;
+    U32   mem_size        = 0;
+    U32   num_entries     = 0;
+
+     if (arg->buf_usr_to_drv == NULL || arg->len_usr_to_drv == 0) {
+        SOCPERF_PRINT_ERROR("lwpmudrv_Read_Mem: Counter buffer is NULL\n");
+        return OS_FAULT;
+    }
+
+    if (copy_from_user(&start_address, (U64*)arg->buf_usr_to_drv, sizeof(U64))) {
+        return OS_FAULT;
+    }
+
+    if ((arg->len_drv_to_usr == 0) || (arg->buf_drv_to_usr == NULL)) {
+        return OS_FAULT;
+    }
+    mem_size = (U32) arg->len_drv_to_usr;
+    mem_address = SOCPERF_Allocate_Memory(mem_size);
+    if (!mem_address) {
+        return OS_NO_MEM;
+    }
+
+    num_entries = (U32)(mem_size/sizeof(U64));
+    if (dispatch_uncore && dispatch_uncore->read_mem) {
+        dispatch_uncore->read_mem(start_address, mem_address, num_entries);
+    }
+    if (copy_to_user(arg->buf_drv_to_usr, (void*)mem_address, mem_size)) {
+        SOCPERF_Free_Memory(mem_address);
+        return OS_FAULT;
+    }
+    SOCPERF_Free_Memory(mem_address);
+
+    return OS_SUCCESS;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn static VOID lwpmudrv_Stop_Mem(void)
+ *
+ * @param - none
+ *
+ * @return - none
+ *
+ * @brief Stop Mem
+ *
+ * <I>Special Notes</I>
+ */
+extern VOID
+lwpmudrv_Stop_Mem (
+    VOID
+)
+{
+    SOCPERF_PRINT_DEBUG("Entered lwpmudrv_Stop_Mem\n");
+
+    if (dispatch_uncore && dispatch_uncore->stop_mem) {
+        dispatch_uncore->stop_mem();
+    }
+
+    SOCPERF_PRINT_DEBUG("Exited lwpmudrv_Stop_Mem\n");
+
+    return;
+}
+
+
+/*******************************************************************************
+ *  External Driver functions - Open
+ *      This function is common to all drivers
+ *******************************************************************************/
+
+static int
+socperf_Open (
+    struct inode *inode,
+    struct file  *filp
+)
+{
+    SOCPERF_PRINT_DEBUG("lwpmu_Open called on maj:%d, min:%d\n",
+            imajor(inode), iminor(inode));
+    filp->private_data = container_of(inode->i_cdev, LWPMU_DEV_NODE, cdev);
+
+    return 0;
+}
+
+/*******************************************************************************
+ *  External Driver functions
+ *      These functions are registered into the file operations table that
+ *      controls this device.
+ *      Open, Close, Read, Write, Release
+ *******************************************************************************/
+
+static ssize_t
+socperf_Read (
+    struct file  *filp,
+    char         *buf,
+    size_t        count,
+    loff_t       *f_pos
+)
+{
+    unsigned long retval;
+
+    /* Transfering data to user space */
+    SOCPERF_PRINT_DEBUG("lwpmu_Read dispatched with count=%d\n", (S32)count);
+    if (copy_to_user(buf, &LWPMU_DEV_buffer(socperf_control), 1)) {
+        retval = OS_FAULT;
+        return retval;
+    }
+    /* Changing reading position as best suits */
+    if (*f_pos == 0) {
+        *f_pos+=1;
+        return 1;
+    }
+
+    return 0;
+}
+
+static ssize_t
+socperf_Write (
+    struct file  *filp,
+    const  char  *buf,
+    size_t        count,
+    loff_t       *f_pos
+)
+{
+    unsigned long retval;
+
+    SOCPERF_PRINT_DEBUG("lwpmu_Write dispatched with count=%d\n", (S32)count);
+    if (copy_from_user(&LWPMU_DEV_buffer(socperf_control), buf+count-1, 1)) {
+        retval = OS_FAULT;
+        return retval;
+    }
+
+    return 1;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn  extern IOCTL_OP_TYPE socperf_Service_IOCTL(IOCTL_USE_NODE, filp, cmd, arg)
+ *
+ * @param   IOCTL_USE_INODE       - Used for pre 2.6.32 kernels
+ * @param   struct   file   *filp - file pointer
+ * @param   unsigned int     cmd  - IOCTL command
+ * @param   unsigned long    arg  - args to the IOCTL command
+ *
+ * @return OS_STATUS
+ *
+ * @brief  Worker function that handles IOCTL requests from the user mode.
+ *
+ * <I>Special Notes</I>
+ */
+extern IOCTL_OP_TYPE
+socperf_Service_IOCTL (
+    IOCTL_USE_INODE
+    struct   file   *filp,
+    unsigned int     cmd,
+    IOCTL_ARGS_NODE  local_args
+)
+{
+    int status = OS_SUCCESS;
+
+    switch (cmd) {
+
+       /*
+        * Common IOCTL commands
+        */
+        case  DRV_OPERATION_VERSION:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_VERSION\n");
+            status = lwpmudrv_Version(&local_args);
+            break;
+
+        case  DRV_OPERATION_RESERVE:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_RESERVE\n");
+            break;
+
+        case  DRV_OPERATION_INIT_PMU:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_INIT_PMU\n");
+            status = lwpmudrv_Init_PMU();
+            break;
+
+        case  DRV_OPERATION_START:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_START\n");
+            status = socperf_Start();
+            break;
+
+        case  DRV_OPERATION_STOP:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_STOP\n");
+            status = socperf_Prepare_Stop();
+            break;
+
+        case  DRV_OPERATION_PAUSE:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_PAUSE\n");
+            status = lwpmudrv_Pause();
+            break;
+
+        case  DRV_OPERATION_RESUME:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_RESUME\n");
+            status = lwpmudrv_Resume();
+            break;
+
+        case  DRV_OPERATION_TERMINATE:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_TERMINATE\n");
+            status = socperf_Terminate();
+            break;
+
+        case  DRV_OPERATION_INIT_DRIVER:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_INIT_DRIVER\n");
+            status = lwpmudrv_Initialize_Driver(local_args.buf_usr_to_drv, local_args.len_usr_to_drv);
+            break;
+
+        case  DRV_OPERATION_INIT_UNCORE:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_INIT_UNCORE\n");
+            status = lwpmudrv_Initialize_Uncore(local_args.buf_usr_to_drv, local_args.len_usr_to_drv);
+            break;
+        case  DRV_OPERATION_EM_GROUPS_UNCORE:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_EM_GROUPS_UNC\n");
+            status = lwpmudrv_Set_EM_Config_Uncore(&local_args);
+            break;
+
+        case  DRV_OPERATION_EM_CONFIG_NEXT_UNCORE:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_EM_CONFIG_NEXT_UNC\n");
+            status = socperf_Configure_Events_Uncore(&local_args);
+            break;
+
+        case  DRV_OPERATION_TIMER_TRIGGER_READ:
+            lwpmudrv_Trigger_Read();
+            break;
+
+       case  DRV_OPERATION_READ_UNCORE_DATA:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_READ_UNCORE_DATA\n");
+            status = lwpmudrv_Read_Uncore_Counts(local_args.buf_drv_to_usr, local_args.len_drv_to_usr);
+            break;
+
+
+        case  DRV_OPERATION_CREATE_MEM:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_CREATE_MEM\n");
+            lwpmudrv_Create_Mem(&local_args);
+            break;
+
+        case  DRV_OPERATION_READ_MEM:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_READ_MEM\n");
+            lwpmudrv_Read_Mem(&local_args);
+            break;
+
+        case  DRV_OPERATION_CHECK_STATUS:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_CHECK_STATUS\n");
+            lwpmudrv_Check_Status(&local_args);
+            break;
+
+        case  DRV_OPERATION_STOP_MEM:
+            SOCPERF_PRINT_DEBUG(" DRV_OPERATION_STOP_MEM\n");
+            lwpmudrv_Stop_Mem();
+            break;
+
+       /*
+        * if none of the above, treat as unknown/illegal IOCTL command
+        */
+        default:
+            SOCPERF_PRINT_ERROR("Unknown IOCTL magic:%d number:%d\n",
+                    _IOC_TYPE(cmd), _IOC_NR(cmd));
+            status = OS_ILLEGAL_IOCTL;
+            break;
+    }
+
+    if (cmd ==  DRV_OPERATION_STOP &&
+        GLOBAL_STATE_current_phase(socperf_driver_state) == DRV_STATE_PREPARE_STOP) {
+        status = socperf_Finish_Stop();
+    }
+
+    return status;
+}
+
+extern long
+socperf_Device_Control (
+    IOCTL_USE_INODE
+    struct   file   *filp,
+    unsigned int     cmd,
+    unsigned long    arg
+)
+{
+    int              status = OS_SUCCESS;
+    IOCTL_ARGS_NODE  local_args;
+
+#if !defined(DRV_USE_UNLOCKED_IOCTL)
+    SOCPERF_PRINT_DEBUG("lwpmu_DeviceControl(0x%x) called on inode maj:%d, min:%d\n",
+            cmd, imajor(inode), iminor(inode));
+#endif
+    SOCPERF_PRINT_DEBUG("type: %d, subcommand: %d\n", _IOC_TYPE(cmd), _IOC_NR(cmd));
+
+    if (_IOC_TYPE(cmd) != LWPMU_IOC_MAGIC) {
+        SOCPERF_PRINT_ERROR("Unknown IOCTL magic:%d\n", _IOC_TYPE(cmd));
+        return OS_ILLEGAL_IOCTL;
+    }
+
+    MUTEX_LOCK(ioctl_lock);
+    if (arg) {
+        status = copy_from_user(&local_args, (IOCTL_ARGS)arg, sizeof(IOCTL_ARGS_NODE));
+    }
+
+    status = socperf_Service_IOCTL (IOCTL_USE_INODE filp, _IOC_NR(cmd), local_args);
+    MUTEX_UNLOCK(ioctl_lock);
+
+    return  status;
+}
+
+
+#if defined(CONFIG_COMPAT) && defined(DRV_EM64T)
+extern long
+socperf_Device_Control_Compat (
+    struct   file   *filp,
+    unsigned int     cmd,
+    unsigned long    arg
+)
+{
+    int                     status = OS_SUCCESS;
+    IOCTL_COMPAT_ARGS_NODE  local_args_compat;
+    IOCTL_ARGS_NODE         local_args;
+
+    memset(&local_args_compat, 0, sizeof(IOCTL_COMPAT_ARGS_NODE));
+    SOCPERF_PRINT_DEBUG("Compat: type: %d, subcommand: %d\n", _IOC_TYPE(cmd), _IOC_NR(cmd));
+
+    if (_IOC_TYPE(cmd) != LWPMU_IOC_MAGIC) {
+        SOCPERF_PRINT_ERROR("Unknown IOCTL magic:%d\n", _IOC_TYPE(cmd));
+        return OS_ILLEGAL_IOCTL;
+    }
+
+    MUTEX_LOCK(ioctl_lock);
+    if (arg) {
+        status = copy_from_user(&local_args_compat, (IOCTL_COMPAT_ARGS)arg, sizeof(IOCTL_COMPAT_ARGS_NODE));
+    }
+    local_args.len_drv_to_usr = local_args_compat.len_drv_to_usr;
+    local_args.len_usr_to_drv = local_args_compat.len_usr_to_drv;
+    local_args.buf_drv_to_usr = (char *) compat_ptr(local_args_compat.buf_drv_to_usr);
+    local_args.buf_usr_to_drv = (char *) compat_ptr(local_args_compat.buf_usr_to_drv);
+
+    status = socperf_Service_IOCTL (filp, _IOC_NR(cmd), local_args);
+    MUTEX_UNLOCK(ioctl_lock);
+
+    return status;
+}
+#endif
+
+/*
+ * @fn        SOCPERF_Abnormal_Terminate(void)
+ *
+ * @brief     This routine is called from linuxos_Exit_Task_Notify if the user process has
+ *            been killed by an uncatchable signal (example kill -9).  The state variable
+ *            abormal_terminate is set to 1 and the clean up routines are called.  In this
+ *            code path the OS notifier hooks should not be unloaded.
+ *
+ * @param     None
+ *
+ * @return    OS_STATUS
+ *
+ * <I>Special Notes:</I>
+ *     <none>
+ */
+extern int
+SOCPERF_Abnormal_Terminate (
+    void
+)
+{
+    int              status = OS_SUCCESS;
+
+    socperf_abnormal_terminate = 1;
+    SOCPERF_PRINT_DEBUG("Abnormal-Termination: Calling socperf_Prepare_Stop\n");
+    status = socperf_Prepare_Stop();
+    SOCPERF_PRINT_DEBUG("Abnormal-Termination: Calling socperf_Finish_Stop\n");
+    status = socperf_Finish_Stop();
+    SOCPERF_PRINT_DEBUG("Abnormal-Termination: Calling lwpmudrv_Terminate\n");
+    status = socperf_Terminate();
+
+    return status;
+}
+
+
+/*****************************************************************************************
+ *
+ *   Driver Entry / Exit functions that will be called on when the driver is loaded and
+ *   unloaded
+ *
+ ****************************************************************************************/
+
+/*
+ * Structure that declares the usual file access functions
+ * First one is for lwpmu_c, the control functions
+ */
+static struct file_operations socperf_Fops = {
+    .owner =   THIS_MODULE,
+    IOCTL_OP = socperf_Device_Control,
+#if defined(CONFIG_COMPAT) && defined(DRV_EM64T)
+    .compat_ioctl = socperf_Device_Control_Compat,
+#endif
+    .read =    socperf_Read,
+    .write =   socperf_Write,
+    .open =    socperf_Open,
+    .release = NULL,
+    .llseek =  NULL,
+};
+
+/*!
+ * @fn  static int lwpmudrv_setup_cdev(dev, fops, dev_number)
+ *
+ * @param LWPMU_DEV               dev  - pointer to the device object
+ * @param struct file_operations *fops - pointer to the file operations struct
+ * @param dev_t                   dev_number - major/monor device number
+ *
+ * @return OS_STATUS
+ *
+ * @brief  Set up the device object.
+ *
+ * <I>Special Notes</I>
+ */
+static int
+lwpmu_setup_cdev (
+    LWPMU_DEV               dev,
+    struct file_operations *fops,
+    dev_t                   dev_number
+)
+{
+    cdev_init(&LWPMU_DEV_cdev(dev), fops);
+    LWPMU_DEV_cdev(dev).owner = THIS_MODULE;
+    LWPMU_DEV_cdev(dev).ops   = fops;
+
+    return cdev_add(&LWPMU_DEV_cdev(dev), dev_number, 1);
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn  static int socperf_Load(void)
+ *
+ * @param none
+ *
+ * @return STATUS
+ *
+ * @brief  Load the driver module into the kernel.  Set up the driver object.
+ * @brief  Set up the initial state of the driver and allocate the memory
+ * @brief  needed to keep basic state information.
+ */
+static int
+socperf_Load (
+    VOID
+)
+{
+    int        num_cpus;
+    OS_STATUS  status      = OS_SUCCESS;
+
+    SOCPERF_Memory_Tracker_Init();
+
+    /* Get one major device number and one minor number. */
+    /*   The result is formatted as major+minor(0) */
+    /*   One minor number is for control (lwpmu_c), */
+    SOCPERF_PRINT("SocPerf Driver loading...\n");
+    SOCPERF_PRINT("SocPerf Driver about to register chrdev...\n");
+
+    lwpmu_DevNum = MKDEV(0, 0);
+    status = alloc_chrdev_region(&lwpmu_DevNum, 0, PMU_DEVICES, SOCPERF_DRIVER_NAME);
+    SOCPERF_PRINT("SocPerf Driver: result of alloc_chrdev_region is %d\n", status);
+    if (status<0) {
+        SOCPERF_PRINT_ERROR("SocPerf driver failed to alloc chrdev_region!\n");
+        return status;
+    }
+    SOCPERF_PRINT("SocPerf Driver: major number is %d\n", MAJOR(lwpmu_DevNum));
+    status = lwpmudrv_Initialize_State();
+    if (status<0) {
+        SOCPERF_PRINT_ERROR("SocPerf driver failed to initialize state!\n");
+        return status;
+    }
+    num_cpus = GLOBAL_STATE_num_cpus(socperf_driver_state);
+    SOCPERF_PRINT("SocPerf Driver: detected %d CPUs in lwpmudrv_Load\n", num_cpus);
+
+    /* Allocate memory for the control structures */
+    socperf_control = SOCPERF_Allocate_Memory(sizeof(LWPMU_DEV_NODE));
+
+    if (!socperf_control) {
+        SOCPERF_Free_Memory(socperf_control);
+        return OS_NO_MEM;
+    }
+
+    /* Register the file operations with the OS */
+
+    SOCPERF_PRINT("SocPerf Driver: creating device %s...\n", SOCPERF_DRIVER_NAME DRV_DEVICE_DELIMITER"c");
+    pmu_class = class_create(THIS_MODULE, SOCPERF_DRIVER_NAME);
+    if (IS_ERR(pmu_class)) {
+        SOCPERF_PRINT_ERROR("Error registering SocPerf control class\n");
+    }
+    device_create(pmu_class, NULL, lwpmu_DevNum, NULL, SOCPERF_DRIVER_NAME DRV_DEVICE_DELIMITER"c");
+
+    status = lwpmu_setup_cdev(socperf_control,&socperf_Fops,lwpmu_DevNum);
+    if (status) {
+        SOCPERF_PRINT_ERROR("Error %d adding lwpmu as char device\n", status);
+        return status;
+    }
+
+    MUTEX_INIT(ioctl_lock);
+
+    /*
+     *  Initialize the SocPerf driver version (done once at driver load time)
+     */
+    SOCPERF_VERSION_NODE_major(&socperf_drv_version) = SOCPERF_MAJOR_VERSION;
+    SOCPERF_VERSION_NODE_minor(&socperf_drv_version) = SOCPERF_MINOR_VERSION;
+    SOCPERF_VERSION_NODE_api(&socperf_drv_version)   = SOCPERF_API_VERSION;
+    //
+    // Display driver version information
+    //
+    SOCPERF_PRINT("SocPerf Driver v%d.%d.%d has been loaded.\n",
+              SOCPERF_VERSION_NODE_major(&socperf_drv_version),
+              SOCPERF_VERSION_NODE_minor(&socperf_drv_version),
+              SOCPERF_VERSION_NODE_api(&socperf_drv_version));
+
+    return status;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn  static int lwpmu_Unload(void)
+ *
+ * @param none
+ *
+ * @return none
+ *
+ * @brief  Remove the driver module from the kernel.
+ */
+static VOID
+socperf_Unload (
+    VOID
+)
+{
+    SOCPERF_PRINT("SocPerf Driver unloading...\n");
+
+    socperf_pcb                 = SOCPERF_Free_Memory(socperf_pcb);
+    socperf_pcb_size            = 0;
+
+    unregister_chrdev(MAJOR(lwpmu_DevNum), SOCPERF_DRIVER_NAME);
+    device_destroy(pmu_class, lwpmu_DevNum);
+    device_destroy(pmu_class, lwpmu_DevNum+1);
+
+    cdev_del(&LWPMU_DEV_cdev(socperf_control));
+    unregister_chrdev_region(lwpmu_DevNum, PMU_DEVICES);
+
+    class_destroy(pmu_class);
+
+    socperf_control  = SOCPERF_Free_Memory(socperf_control);
+
+    SOCPERF_Memory_Tracker_Free();
+
+    //
+    // Display driver version information
+    //
+    SOCPERF_PRINT("SocPerf Driver v%d.%d.%d has been unloaded.\n",
+              SOCPERF_VERSION_NODE_major(&socperf_drv_version),
+              SOCPERF_VERSION_NODE_minor(&socperf_drv_version),
+              SOCPERF_VERSION_NODE_api(&socperf_drv_version));
+
+    return;
+}
+
+/* Declaration of the init and exit functions */
+module_init(socperf_Load);
+module_exit(socperf_Unload);
diff --git a/drivers/misc/intel/sepdk/socperf/utility.c b/drivers/misc/intel/sepdk/socperf/utility.c
new file mode 100644
index 000000000000..ca9d27b60445
--- /dev/null
+++ b/drivers/misc/intel/sepdk/socperf/utility.c
@@ -0,0 +1,194 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#include "lwpmudrv_defines.h"
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <asm/msr.h>
+#include <linux/ptrace.h>
+
+#include "lwpmudrv_types.h"
+#include "rise_errors.h"
+#include "lwpmudrv_ecb.h"
+#include "socperfdrv.h"
+#include "utility.h"
+#if defined(DRV_SOFIA)
+#include "noc_uncore.h"
+#elif defined(DRV_BUTTER)
+#include "axi_uncore.h"
+#else
+#include "soc_uncore.h"
+#include "haswellunc_sa.h"
+#include "npk_uncore.h"
+#endif
+
+volatile int config_done;
+
+
+extern VOID
+SOCPERF_UTILITY_Read_TSC (
+    U64* pTsc
+)
+{
+    rdtscll(*(pTsc));
+
+    return;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn       VOID SOCPERF_UTILITY_Read_Cpuid
+ *
+ * @brief    executes the cpuid_function of cpuid and returns values
+ *
+ * @param  IN   cpuid_function
+ *         OUT  rax  - results of the cpuid instruction in the
+ *         OUT  rbx  - corresponding registers
+ *         OUT  rcx
+ *         OUT  rdx
+ *
+ * @return   none
+ *
+ * <I>Special Notes:</I>
+ *              <NONE>
+ *
+ */
+extern VOID
+SOCPERF_UTILITY_Read_Cpuid (
+    U64   cpuid_function,
+    U64  *rax_value,
+    U64  *rbx_value,
+    U64  *rcx_value,
+    U64  *rdx_value
+)
+{
+    U32 function = (U32) cpuid_function;
+    U32 *eax     = (U32 *) rax_value;
+    U32 *ebx     = (U32 *) rbx_value;
+    U32 *ecx     = (U32 *) rcx_value;
+    U32 *edx     = (U32 *) rdx_value;
+
+    *eax = function;
+
+    __asm__("cpuid"
+            : "=a" (*eax),
+              "=b" (*ebx),
+              "=c" (*ecx),
+              "=d" (*edx)
+            : "a"  (function),
+              "b"  (*ebx),
+              "c"  (*ecx),
+              "d"  (*edx));
+
+    return;
+}
+
+/* ------------------------------------------------------------------------- */
+/*!
+ * @fn       VOID SOCPERF_UTILITY_Configure_CPU
+ *
+ * @brief    Reads the CPU information from the hardware
+ *
+ * @param    param   dispatch_id -  The id of the dispatch table.
+ *
+ * @return   Pointer to the correct dispatch table for the CPU architecture
+ *
+ * <I>Special Notes:</I>
+ *              <NONE>
+ */
+extern  DISPATCH
+SOCPERF_UTILITY_Configure_CPU (
+    U32 dispatch_id
+)
+{
+    DISPATCH     dispatch = NULL;
+    switch (dispatch_id) {
+#if defined(DRV_SOFIA)
+        case 1000:
+            SOCPERF_PRINT_DEBUG("Set up the SoC Uncore NOC dispatch table\n");
+            dispatch = &noc_dispatch;
+            break;
+#elif defined(DRV_BUTTER)
+        case 1100:
+            SOCPERF_PRINT_DEBUG("Set up the SoC Uncore AXI dispatch table\n");
+            dispatch = &axi_dispatch;
+            break;
+#else
+        case 230:
+            SOCPERF_PRINT_DEBUG("Set up the Haswell SA dispatch table\n");
+            dispatch = &socperf_hswunc_sa_dispatch;
+            break;
+        case 700:
+            SOCPERF_PRINT_DEBUG("Set up the SOC Uncore dispatch table\n");
+            dispatch = &soc_uncore_dispatch;
+            break;
+        case 701:
+            SOCPERF_PRINT_DEBUG("Set up the SoC Uncore NPK dispatch table\n");
+            dispatch = &npk_dispatch;
+            break;
+#endif
+        default:
+            dispatch = NULL;
+            SOCPERF_PRINT_ERROR("Architecture not supported (dispatch_id=%d)\n", dispatch_id);
+            break;
+    }
+
+    return dispatch;
+}
+
+
-- 
2.18.0

