From 6492f1e9446eccd711a6cbc9815e95b7063a4e4e Mon Sep 17 00:00:00 2001
From: Miguel Bernal Marin <miguel.bernal.marin@linux.intel.com>
Date: Wed, 29 Aug 2018 06:23:14 -0500
Subject: [PATCH 8013/8021] misc: intel: soc_perf: add inc files

---
 drivers/misc/intel/soc_perf/inc/control.h     | 496 ++++++++++++++++++
 .../misc/intel/soc_perf/inc/ecb_iterators.h   | 119 +++++
 .../misc/intel/soc_perf/inc/haswellunc_sa.h   |  87 +++
 drivers/misc/intel/soc_perf/inc/npk_uncore.h  |  85 +++
 drivers/misc/intel/soc_perf/inc/pci.h         | 128 +++++
 drivers/misc/intel/soc_perf/inc/soc_uncore.h  |  93 ++++
 drivers/misc/intel/soc_perf/inc/socperfdrv.h  | 188 +++++++
 drivers/misc/intel/soc_perf/inc/utility.h     |  76 +++
 8 files changed, 1272 insertions(+)
 create mode 100644 drivers/misc/intel/soc_perf/inc/control.h
 create mode 100644 drivers/misc/intel/soc_perf/inc/ecb_iterators.h
 create mode 100644 drivers/misc/intel/soc_perf/inc/haswellunc_sa.h
 create mode 100644 drivers/misc/intel/soc_perf/inc/npk_uncore.h
 create mode 100644 drivers/misc/intel/soc_perf/inc/pci.h
 create mode 100644 drivers/misc/intel/soc_perf/inc/soc_uncore.h
 create mode 100644 drivers/misc/intel/soc_perf/inc/socperfdrv.h
 create mode 100644 drivers/misc/intel/soc_perf/inc/utility.h

diff --git a/drivers/misc/intel/soc_perf/inc/control.h b/drivers/misc/intel/soc_perf/inc/control.h
new file mode 100644
index 000000000000..3879d45b082b
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/inc/control.h
@@ -0,0 +1,496 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+#ifndef _CONTROL_H_
+#define _CONTROL_H_
+
+#include <linux/smp.h>
+#include <linux/timer.h>
+#if defined(DRV_IA32)
+#include <asm/apic.h>
+#endif
+#include <asm/io.h>
+#if defined(DRV_IA32)
+#include <asm/msr.h>
+#endif
+#include <asm/atomic.h>
+
+#include "lwpmudrv_defines.h"
+#include "socperfdrv.h"
+#include "lwpmudrv_types.h"
+
+// large memory allocation will be used if the requested size (in bytes) is
+// above this threshold
+#define  MAX_KMALLOC_SIZE ((1<<17)-1)
+
+// check whether Linux driver should use unlocked ioctls (not protected by BKL)
+#if defined(HAVE_UNLOCKED_IOCTL)
+#define DRV_USE_UNLOCKED_IOCTL
+#endif
+#if defined(DRV_USE_UNLOCKED_IOCTL)
+#define IOCTL_OP .unlocked_ioctl
+#define IOCTL_OP_TYPE long
+#define IOCTL_USE_INODE
+#else
+#define IOCTL_OP .ioctl
+#define IOCTL_OP_TYPE S32
+#define IOCTL_USE_INODE struct   inode  *inode,
+#endif
+
+// Information about the state of the driver
+typedef struct GLOBAL_STATE_NODE_S  GLOBAL_STATE_NODE;
+typedef        GLOBAL_STATE_NODE   *GLOBAL_STATE;
+struct GLOBAL_STATE_NODE_S {
+    volatile S32    cpu_count;
+    volatile S32    dpc_count;
+
+    S32             num_cpus;       // Number of CPUs in the system
+    S32             active_cpus;    // Number of active CPUs - some cores can be
+                                    // deactivated by the user / admin
+    S32             num_em_groups;
+    S32             num_descriptors;
+    volatile S32    current_phase;
+};
+
+// Access Macros
+#define  GLOBAL_STATE_num_cpus(x)          ((x).num_cpus)
+#define  GLOBAL_STATE_active_cpus(x)       ((x).active_cpus)
+#define  GLOBAL_STATE_cpu_count(x)         ((x).cpu_count)
+#define  GLOBAL_STATE_dpc_count(x)         ((x).dpc_count)
+#define  GLOBAL_STATE_num_em_groups(x)     ((x).num_em_groups)
+#define  GLOBAL_STATE_num_descriptors(x)   ((x).num_descriptors)
+#define  GLOBAL_STATE_current_phase(x)     ((x).current_phase)
+#define  GLOBAL_STATE_sampler_id(x)        ((x).sampler_id)
+
+/*
+ *
+ *
+ * CPU State data structure and access macros
+ *
+ */
+typedef struct CPU_STATE_NODE_S  CPU_STATE_NODE;
+typedef        CPU_STATE_NODE   *CPU_STATE;
+struct CPU_STATE_NODE_S {
+    S32         apic_id;             // Processor ID on the system bus
+    PVOID       apic_linear_addr;    // linear address of local apic
+    PVOID       apic_physical_addr;  // physical address of local apic
+
+    PVOID       idt_base;            // local IDT base address
+    atomic_t    in_interrupt;
+
+#if defined(DRV_IA32)
+    U64         saved_ih;            // saved perfvector to restore
+#endif
+#if defined(DRV_EM64T)
+    PVOID       saved_ih;            // saved perfvector to restore
+#endif
+
+    S64        *em_tables;           // holds the data that is saved/restored
+                                     // during event multiplexing
+
+    struct timer_list *em_timer;
+    U32         current_group;
+    S32         trigger_count;
+    S32         trigger_event_num;
+
+    DISPATCH    dispatch;
+    PVOID       lbr_area;
+    PVOID       old_dts_buffer;
+    PVOID       dts_buffer;
+    U32         initial_mask;
+    U32         accept_interrupt;
+
+#if defined(BUILD_CHIPSET)
+    // Chipset counter stuff
+    U32         chipset_count_init;  // flag to initialize the last MCH and ICH arrays below.
+    U64         last_mch_count[8];
+    U64         last_ich_count[8];
+    U64         last_gmch_count[MAX_CHIPSET_COUNTERS];
+    U64         last_mmio_count[32]; // it's only 9 now but the next generation may have 29.
+#endif
+
+    U64        *pmu_state;           // holds PMU state (e.g., MSRs) that will be
+                                     // saved before and restored after collection
+    S32         socket_master;
+    S32         core_master;
+    S32         thr_master;
+    U64         num_samples;
+    U64         reset_mask;
+    U64         group_swap;
+    U64         last_uncore_count[16];
+};
+
+#define CPU_STATE_apic_id(cpu)              (cpu)->apic_id
+#define CPU_STATE_apic_linear_addr(cpu)     (cpu)->apic_linear_addr
+#define CPU_STATE_apic_physical_addr(cpu)   (cpu)->apic_physical_addr
+#define CPU_STATE_idt_base(cpu)             (cpu)->idt_base
+#define CPU_STATE_in_interrupt(cpu)         (cpu)->in_interrupt
+#define CPU_STATE_saved_ih(cpu)             (cpu)->saved_ih
+#define CPU_STATE_saved_ih_hi(cpu)          (cpu)->saved_ih_hi
+#define CPU_STATE_dpc(cpu)                  (cpu)->dpc
+#define CPU_STATE_em_tables(cpu)            (cpu)->em_tables
+#define CPU_STATE_pmu_state(cpu)            (cpu)->pmu_state
+#define CPU_STATE_em_dpc(cpu)               (cpu)->em_dpc
+#define CPU_STATE_em_timer(cpu)             (cpu)->em_timer
+#define CPU_STATE_current_group(cpu)        (cpu)->current_group
+#define CPU_STATE_trigger_count(cpu)        (cpu)->trigger_count
+#define CPU_STATE_trigger_event_num(cpu)    (cpu)->trigger_event_num
+#define CPU_STATE_dispatch(cpu)             (cpu)->dispatch
+#define CPU_STATE_lbr(cpu)                  (cpu)->lbr
+#define CPU_STATE_old_dts_buffer(cpu)       (cpu)->old_dts_buffer
+#define CPU_STATE_dts_buffer(cpu)           (cpu)->dts_buffer
+#define CPU_STATE_initial_mask(cpu)         (cpu)->initial_mask
+#define CPU_STATE_accept_interrupt(cpu)     (cpu)->accept_interrupt
+#define CPU_STATE_msr_value(cpu)            (cpu)->msr_value
+#define CPU_STATE_msr_addr(cpu)             (cpu)->msr_addr
+#define CPU_STATE_socket_master(cpu)        (cpu)->socket_master
+#define CPU_STATE_core_master(cpu)          (cpu)->core_master
+#define CPU_STATE_thr_master(cpu)           (cpu)->thr_master
+#define CPU_STATE_num_samples(cpu)          (cpu)->num_samples
+#define CPU_STATE_reset_mask(cpu)           (cpu)->reset_mask
+#define CPU_STATE_group_swap(cpu)           (cpu)->group_swap
+
+/*
+ * For storing data for --read/--write-msr command line options
+ */
+typedef struct MSR_DATA_NODE_S MSR_DATA_NODE;
+typedef        MSR_DATA_NODE  *MSR_DATA;
+struct MSR_DATA_NODE_S {
+    U64         value;             // Used for emon, for read/write-msr value
+    U64         addr;
+};
+
+#define MSR_DATA_value(md)   (md)->value
+#define MSR_DATA_addr(md)    (md)->addr
+
+/*
+ * Memory Allocation tracker
+ *
+ * Currently used to track large memory allocations
+ */
+
+typedef struct MEM_EL_NODE_S  MEM_EL_NODE;
+typedef        MEM_EL_NODE   *MEM_EL;
+struct MEM_EL_NODE_S {
+    char     *address;         // pointer to piece of memory we're tracking
+    S32       size;            // size (bytes) of the piece of memory
+    DRV_BOOL  is_addr_vmalloc; // flag to check if the memory is allocated using vmalloc
+};
+
+// accessors for MEM_EL defined in terms of MEM_TRACKER below
+
+#define MEM_EL_MAX_ARRAY_SIZE  32   // minimum is 1, nominal is 64
+
+typedef struct MEM_TRACKER_NODE_S  MEM_TRACKER_NODE;
+typedef        MEM_TRACKER_NODE   *MEM_TRACKER;
+struct MEM_TRACKER_NODE_S {
+    S32         max_size;     // number of elements in the array (default: MEM_EL_MAX_ARRAY_SIZE)
+    MEM_EL      mem;          // array of large memory items we're tracking
+    MEM_TRACKER prev,next;    // enables bi-directional scanning of linked list
+};
+#define MEM_TRACKER_max_size(mt)         (mt)->max_size
+#define MEM_TRACKER_mem(mt)              (mt)->mem
+#define MEM_TRACKER_prev(mt)             (mt)->prev
+#define MEM_TRACKER_next(mt)             (mt)->next
+#define MEM_TRACKER_mem_address(mt, i)   (MEM_TRACKER_mem(mt)[(i)].address)
+#define MEM_TRACKER_mem_size(mt, i)      (MEM_TRACKER_mem(mt)[(i)].size)
+#define MEM_TRACKER_mem_vmalloc(mt, i)   (MEM_TRACKER_mem(mt)[(i)].is_addr_vmalloc)
+
+/****************************************************************************
+ ** Global State variables exported
+ ***************************************************************************/
+extern   CPU_STATE            socperf_pcb;
+extern   U64                 *tsc_info;
+extern   GLOBAL_STATE_NODE    socperf_driver_state;
+extern   MSR_DATA             msr_data;
+extern   U32                 *core_to_package_map;
+extern   U32                  num_packages;
+extern   U64                 *restore_bl_bypass;
+extern   U32                 **restore_ha_direct2core;
+extern   U32                 **restore_qpi_direct2core;
+/****************************************************************************
+ **  Handy Short cuts
+ ***************************************************************************/
+
+/*
+ * SOCPERF_THIS_CPU()
+ *     Parameters
+ *         None
+ *     Returns
+ *         CPU number of the processor being executed on
+ *
+ */
+#define SOCPERF_THIS_CPU()     smp_processor_id()
+
+/****************************************************************************
+ **  Interface definitions
+ ***************************************************************************/
+
+/*
+ *  Execution Control Functions
+ */
+
+extern VOID
+SOCPERF_Invoke_Cpu (
+    S32   cpuid,
+    VOID  (*func)(PVOID),
+    PVOID ctx
+);
+
+/*
+ * @fn VOID SOCPERF_Invoke_Parallel_Service(func, ctx, blocking, exclude)
+ *
+ * @param    func     - function to be invoked by each core in the system
+ * @param    ctx      - pointer to the parameter block for each function invocation
+ * @param    blocking - Wait for invoked function to complete
+ * @param    exclude  - exclude the current core from executing the code
+ *
+ * @returns  none
+ *
+ * @brief    Service routine to handle all kinds of parallel invoke on all CPU calls
+ *
+ * <I>Special Notes:</I>
+ *         Invoke the function provided in parallel in either a blocking/non-blocking mode.
+ *         The current core may be excluded if desired.
+ *         NOTE - Do not call this function directly from source code.  Use the aliases
+ *         SOCPERF_Invoke_Parallel(), SOCPERF_Invoke_Parallel_NB(), SOCPERF_Invoke_Parallel_XS().
+ *
+ */
+extern VOID
+SOCPERF_Invoke_Parallel_Service (
+        VOID   (*func)(PVOID),
+        PVOID  ctx,
+        S32    blocking,
+        S32    exclude
+);
+
+/*
+ * @fn VOID SOCPERF_Invoke_Parallel(func, ctx)
+ *
+ * @param    func     - function to be invoked by each core in the system
+ * @param    ctx      - pointer to the parameter block for each function invocation
+ *
+ * @returns  none
+ *
+ * @brief    Invoke the named function in parallel. Wait for all the functions to complete.
+ *
+ * <I>Special Notes:</I>
+ *        Invoke the function named in parallel, including the CPU that the control is
+ *        being invoked on
+ *        Macro built on the service routine
+ *
+ */
+#define SOCPERF_Invoke_Parallel(a,b)      SOCPERF_Invoke_Parallel_Service((a),(b),TRUE,FALSE)
+
+/*
+ * @fn VOID SOCPERF_Invoke_Parallel_NB(func, ctx)
+ *
+ * @param    func     - function to be invoked by each core in the system
+ * @param    ctx      - pointer to the parameter block for each function invocation
+ *
+ * @returns  none
+ *
+ * @brief    Invoke the named function in parallel. DO NOT Wait for all the functions to complete.
+ *
+ * <I>Special Notes:</I>
+ *        Invoke the function named in parallel, including the CPU that the control is
+ *        being invoked on
+ *        Macro built on the service routine
+ *
+ */
+#define SOCPERF_Invoke_Parallel_NB(a,b)   SOCPERF_Invoke_Parallel_Service((a),(b),FALSE,FALSE)
+
+/*
+ * @fn VOID SOCPERF_Invoke_Parallel_XS(func, ctx)
+ *
+ * @param    func     - function to be invoked by each core in the system
+ * @param    ctx      - pointer to the parameter block for each function invocation
+ *
+ * @returns  none
+ *
+ * @brief    Invoke the named function in parallel. Wait for all the functions to complete.
+ *
+ * <I>Special Notes:</I>
+ *        Invoke the function named in parallel, excluding the CPU that the control is
+ *        being invoked on
+ *        Macro built on the service routine
+ *
+ */
+#define SOCPERF_Invoke_Parallel_XS(a,b)   SOCPERF_Invoke_Parallel_Service((a),(b),TRUE,TRUE)
+
+
+/*
+ * @fn VOID SOCPERF_Memory_Tracker_Init(void)
+ *
+ * @param    None
+ *
+ * @returns  None
+ *
+ * @brief    Initializes Memory Tracker
+ *
+ * <I>Special Notes:</I>
+ *           This should only be called when the
+ *           the driver is being loaded.
+ */
+extern VOID
+SOCPERF_Memory_Tracker_Init (
+    VOID
+);
+
+/*
+ * @fn VOID SOCPERF_Memory_Tracker_Free(void)
+ *
+ * @param    None
+ *
+ * @returns  None
+ *
+ * @brief    Frees memory used by Memory Tracker
+ *
+ * <I>Special Notes:</I>
+ *           This should only be called when the
+ *           driver is being unloaded.
+ */
+extern VOID
+SOCPERF_Memory_Tracker_Free (
+    VOID
+);
+
+/*
+ * @fn VOID SOCPERF_Memory_Tracker_Compaction(void)
+ *
+ * @param    None
+ *
+ * @returns  None
+ *
+ * @brief    Compacts the memory allocator if holes are detected
+ *
+ * <I>Special Notes:</I>
+ *           At end of collection (or at other safe sync point), 
+ *           reclaim/compact space used by mem tracker
+ */
+extern VOID
+SOCPERF_Memory_Tracker_Compaction (
+    void
+);
+
+/*
+ * @fn PVOID SOCPERF_Allocate_Memory(size)
+ *
+ * @param    IN size     - size of the memory to allocate
+ *
+ * @returns  char*       - pointer to the allocated memory block
+ *
+ * @brief    Allocate and zero memory
+ *
+ * <I>Special Notes:</I>
+ *           Allocate memory in the GFP_KERNEL pool.
+ *
+ *           Use this if memory is to be allocated within a context where
+ *           the allocator can block the allocation (e.g., by putting
+ *           the caller to sleep) while it tries to free up memory to
+ *           satisfy the request.  Otherwise, if the allocation must
+ *           occur atomically (e.g., caller cannot sleep), then use
+ *           SOCPERF_Allocate_KMemory instead.
+ */
+extern PVOID
+SOCPERF_Allocate_Memory (
+    size_t    size
+);
+
+/*
+ * @fn PVOID SOCPERF_Allocate_KMemory(size)
+ *
+ * @param    IN size     - size of the memory to allocate
+ *
+ * @returns  char*       - pointer to the allocated memory block
+ *
+ * @brief    Allocate and zero memory
+ *
+ * <I>Special Notes:</I>
+ *           Allocate memory in the GFP_ATOMIC pool.
+ *
+ *           Use this if memory is to be allocated within a context where
+ *           the allocator cannot block the allocation (e.g., by putting
+ *           the caller to sleep) as it tries to free up memory to
+ *           satisfy the request.  Examples include interrupt handlers,
+ *           process context code holding locks, etc.
+ */
+extern PVOID
+SOCPERF_Allocate_KMemory (
+    size_t  size
+);
+
+/*
+ * @fn PVOID SOCPERF_Free_Memory(location)
+ *
+ * @param    IN location  - size of the memory to allocate
+ *
+ * @returns  pointer to the allocated memory block
+ *
+ * @brief    Frees the memory block
+ *
+ * <I>Special Notes:</I>
+ *           Does not try to free memory if fed with a NULL pointer
+ *           Expected usage:
+ *               ptr = SOCPERF_Free_Memory(ptr);
+ */
+extern PVOID
+SOCPERF_Free_Memory (
+    PVOID    location
+);
+
+#endif  
diff --git a/drivers/misc/intel/soc_perf/inc/ecb_iterators.h b/drivers/misc/intel/soc_perf/inc/ecb_iterators.h
new file mode 100644
index 000000000000..114591e073a7
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/inc/ecb_iterators.h
@@ -0,0 +1,119 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+#ifndef _ECB_ITERATORS_H_
+#define _ECB_ITERATORS_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+//
+// Loop macros to walk through the event control block
+// Use for access only in the kernel mode
+// To Do - Control access from kernel mode by a macro
+//
+
+
+#define FOR_EACH_PCI_DATA_REG_RAW(pecb,i, device_idx ) {                                                \
+    U32                 (i)       = 0;                                                                  \
+    U32                 (cur_grp) = LWPMU_DEVICE_cur_group(device_uncore);                              \
+    ECB                 (pecb)    = LWPMU_DEVICE_PMU_register_data(device_uncore)[(cur_grp)];           \
+    if ((pecb)) {                                                                                       \
+        for ((i) = ECB_operations_register_start(pecb, PMU_OPERATION_READ);                             \
+             (i) < ECB_operations_register_start(pecb, PMU_OPERATION_READ) +                            \
+                ECB_operations_register_len(pecb, PMU_OPERATION_READ);                                  \
+             (i)++) {                                                                                   \
+            if (ECB_entries_pci_id_offset((pecb),(i)) == 0) {                                           \
+                continue;                                                                               \
+            }
+
+#define END_FOR_EACH_PCI_DATA_REG_RAW    } } }
+
+
+#define FOR_EACH_PCI_REG_RAW(pecb, i, device_idx ) {                                                   \
+    U32                 (i)       = 0;                                                                 \
+    U32                 (cur_grp) = LWPMU_DEVICE_cur_group(device_uncore);                       \
+    ECB                 (pecb)    = LWPMU_DEVICE_PMU_register_data(device_uncore)[(cur_grp)]; \
+    if ((pecb)) {                                                                                      \
+        for ((i) = 0;                                                                                  \
+             (i) < ECB_num_entries(pecb);                                                              \
+             (i)++) {                                                                                  \
+            if (ECB_entries_pci_id_offset((pecb),(i)) == 0) {                                          \
+                continue;                                                                              \
+            }
+
+#define END_FOR_EACH_PCI_REG_RAW   } } }
+
+#define FOR_EACH_REG_ENTRY_UNC(pecb,device_idx,idx) {                                          \
+    U32        (idx);                                                                          \
+    U32        (cur_grp) = LWPMU_DEVICE_cur_group(device_uncore);                     \
+    ECB        (pecb)    = LWPMU_DEVICE_PMU_register_data(device_uncore)[(cur_grp)];  \
+    if ((pecb)) {                                                                              \
+        for ((idx) = 0; (idx) < ECB_num_entries(pecb); (idx)++) {                              \
+            if (ECB_entries_bus_no((pecb),(idx)) == 0 && ECB_entries_reg_id((pecb),(idx)) == 0) {    \
+                continue;                                                                      \
+            }
+
+#define END_FOR_EACH_REG_ENTRY_UNC  }}}
+
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff --git a/drivers/misc/intel/soc_perf/inc/haswellunc_sa.h b/drivers/misc/intel/soc_perf/inc/haswellunc_sa.h
new file mode 100644
index 000000000000..0720f63563f0
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/inc/haswellunc_sa.h
@@ -0,0 +1,87 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2011-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2011-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#ifndef _HSWUNC_SA_H_INC_
+#define _HSWUNC_SA_H_INC_
+
+/*
+ * Local to this architecture: Haswell uncore SA unit 
+ * 
+ */
+#define HSWUNC_SA_DESKTOP_DID                 0x000C04
+#define HSWUNC_SA_NEXT_ADDR_OFFSET            4
+#define HSWUNC_SA_BAR_ADDR_SHIFT              32
+#define HSWUNC_SA_BAR_ADDR_MASK               0x0007FFFFFF000LL
+#define HSWUNC_SA_MAX_PCI_DEVICES             16
+#define HSWUNC_SA_MAX_COUNT                   0x00000000FFFFFFFFLL
+#define HSWUNC_SA_MAX_COUNTERS                8
+
+#define HSWUNC_SA_MCHBAR_MMIO_PAGE_SIZE       8*4096
+#define HSWUNC_SA_PCIEXBAR_MMIO_PAGE_SIZE     57*4096
+#define HSWUNC_SA_OTHER_BAR_MMIO_PAGE_SIZE    4096
+#define HSWUNC_SA_GDXCBAR_OFFSET_LO           0x5420
+#define HSWUNC_SA_GDXCBAR_OFFSET_HI           0x5424
+#define HSWUNC_SA_GDXCBAR_MASK                0x7FFFFFF000LL
+#define HSWUNC_SA_CHAP_SAMPLE_DATA            0x00020000
+#define HSWUNC_SA_CHAP_STOP                   0x00040000
+#define HSWUNC_SA_CHAP_CTRL_REG_OFFSET        0x0
+
+
+extern DISPATCH_NODE  socperf_hswunc_sa_dispatch;
+
+#endif
diff --git a/drivers/misc/intel/soc_perf/inc/npk_uncore.h b/drivers/misc/intel/soc_perf/inc/npk_uncore.h
new file mode 100644
index 000000000000..c5a355992011
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/inc/npk_uncore.h
@@ -0,0 +1,85 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2013-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2013-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#ifndef _NPK_UNCORE_H_INC_
+#define _NPK_UNCORE_H_INC_
+
+/*
+ * Local to this architecture: uncore SA unit
+ *
+ */
+#define SOC_NPK_UNCORE_NEXT_ADDR_OFFSET              4
+#define SOC_NPK_UNCORE_BAR_ADDR_SHIFT                32
+#define SOC_NPK_UNCORE_BAR_ADDR_MASK                 0x00FFFFF00000LL
+#define SOC_NPK_UNCORE_MAX_PCI_DEVICES               16
+#define SOC_NPK_COUNTER_MAX_COUNTERS                 16
+#define SOC_NPK_COUNTER_MAX_COUNT                    0x00000000FFFFFFFFLL
+#define SOC_NPK_UNCORE_MCHBAR_ADDR_MASK              0x7FFFFF8000LL
+
+#define SOC_NPK_UNCORE_NPK_BAR_MMIO_PAGE_SIZE        0x100000
+#define SOC_NPK_UNCORE_MCHBAR_MMIO_PAGE_SIZE         8*4096
+#define SOC_NPK_UNCORE_SAMPLE_DATA                   0x00120000
+#define SOC_NPK_UNCORE_STOP                          0x00040000
+#define SOC_NPK_UNCORE_CHAP_START                    0x00110000
+#define SOC_NPK_UNCORE_CHAP_CTRL_REG_OFFSET          0x0
+
+
+extern DISPATCH_NODE  npk_dispatch;
+
+
+#endif
diff --git a/drivers/misc/intel/soc_perf/inc/pci.h b/drivers/misc/intel/soc_perf/inc/pci.h
new file mode 100644
index 000000000000..4d7de4bb89ec
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/inc/pci.h
@@ -0,0 +1,128 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2013-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2013-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+#ifndef _PCI_H_
+#define _PCI_H_
+
+#include "lwpmudrv_defines.h"
+
+/*
+ * PCI Config Address macros
+ */
+#define PCI_ENABLE                          0x80000000
+
+#define PCI_ADDR_IO                         0xCF8
+#define PCI_DATA_IO                         0xCFC
+
+#define BIT0                                0x1
+#define BIT1                                0x2
+
+/*
+ * Macro for forming a PCI configuration address
+ */
+#define FORM_PCI_ADDR(bus,dev,fun,off)     (((PCI_ENABLE))          |   \
+                                            ((bus & 0xFF) << 16)    |   \
+                                            ((dev & 0x1F) << 11)    |   \
+                                            ((fun & 0x07) <<  8)    |   \
+                                            ((off & 0xFF) <<  0))
+
+#define VENDOR_ID_MASK                        0x0000FFFF
+#define DEVICE_ID_MASK                        0xFFFF0000
+#define DEVICE_ID_BITSHIFT                    16
+#define LOWER_4_BYTES_MASK                    0x00000000FFFFFFFF
+#define MAX_BUSNO                             256
+#define NEXT_ADDR_OFFSET                      4
+#define NEXT_ADDR_SHIFT                       32
+#define DRV_IS_PCI_VENDOR_ID_INTEL            0x8086
+
+#define CHECK_IF_GENUINE_INTEL_DEVICE(value, vendor_id, device_id)    \
+    {                                                                 \
+        vendor_id = value & VENDOR_ID_MASK;                           \
+        device_id = (value & DEVICE_ID_MASK) >> DEVICE_ID_BITSHIFT;   \
+                                                                      \
+        if (vendor_id != DRV_IS_PCI_VENDOR_ID_INTEL) {                \
+            continue;                                                 \
+        }                                                             \
+                                                                      \
+    }
+
+#if defined(DRV_IA32) || defined(DRV_EM64T)
+extern int
+SOCPERF_PCI_Read_From_Memory_Address (
+    U32 addr,
+    U32* val
+);
+
+extern int
+SOCPERF_PCI_Write_To_Memory_Address (
+    U32 addr,
+    U32 val
+);
+
+extern int
+SOCPERF_PCI_Read_Ulong (
+    U32 pci_address
+);
+
+extern void
+SOCPERF_PCI_Write_Ulong (
+    U32 pci_address,
+    U32 value
+);
+#endif
+
+#endif  
diff --git a/drivers/misc/intel/soc_perf/inc/soc_uncore.h b/drivers/misc/intel/soc_perf/inc/soc_uncore.h
new file mode 100644
index 000000000000..cc224144ca98
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/inc/soc_uncore.h
@@ -0,0 +1,93 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2013-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2013-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#ifndef _SOC_UNCORE_H_INC_
+#define _SOC_UNCORE_H_INC_
+
+/*
+ * Local to this architecture: SoC uncore unit 
+ * 
+ */
+#define SOC_UNCORE_DESKTOP_DID                 0x000C04
+#define SOC_UNCORE_NEXT_ADDR_OFFSET            4
+#define SOC_UNCORE_BAR_ADDR_SHIFT              32
+#define SOC_UNCORE_BAR_ADDR_MASK               0x000FFFC00000LL
+#define SOC_UNCORE_MAX_PCI_DEVICES             16
+#define SOC_UNCORE_MCR_REG_OFFSET              0xD0
+#define SOC_UNCORE_MDR_REG_OFFSET              0xD4
+#define SOC_UNCORE_MCRX_REG_OFFSET             0xD8
+#define SOC_UNCORE_BYTE_ENABLES                0xF
+#define SOC_UNCORE_OP_CODE_SHIFT               24
+#define SOC_UNCORE_PORT_ID_SHIFT               16
+#define SOC_UNCORE_OFFSET_HI_MASK              0xFFFFFF00
+#define SOC_UNCORE_OFFSET_LO_MASK              0xFF
+#define SOC_COUNTER_PORT_ID                    23
+#define SOC_COUNTER_WRITE_OP_CODE              1
+#define SOC_COUNTER_READ_OP_CODE               0
+#define UNCORE_MAX_COUNTERS                    8
+#define UNCORE_MAX_COUNT                       0x00000000FFFFFFFFLL
+
+#define SOC_UNCORE_OTHER_BAR_MMIO_PAGE_SIZE    4096
+#define SOC_UNCORE_SAMPLE_DATA                 0x00020000
+#define SOC_UNCORE_STOP                        0x00040000
+#define SOC_UNCORE_CTRL_REG_OFFSET             0x0
+
+
+extern DISPATCH_NODE  soc_uncore_dispatch;
+
+#endif
diff --git a/drivers/misc/intel/soc_perf/inc/socperfdrv.h b/drivers/misc/intel/soc_perf/inc/socperfdrv.h
new file mode 100644
index 000000000000..c73d846b89da
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/inc/socperfdrv.h
@@ -0,0 +1,188 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#ifndef _SOCPERFDRV_H_
+#define _SOCPERFDRV_H_
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/compat.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0)
+#include <asm/uaccess.h>
+#else
+#include <linux/uaccess.h>
+#endif
+#include "lwpmudrv_defines.h"
+#include "lwpmudrv_ecb.h"
+#include "lwpmudrv_struct.h"
+#include "lwpmudrv_types.h"
+#include "lwpmudrv_version.h"
+
+
+/*
+ * Print macros for driver messages
+ */
+
+#if defined(MYDEBUG)
+#define SOCPERF_PRINT_DEBUG(fmt,args...) { printk(KERN_INFO SOCPERF_MSG_PREFIX" [DEBUG] " fmt,##args); }
+#else
+#define SOCPERF_PRINT_DEBUG(fmt,args...) {;}
+#endif
+
+#define SOCPERF_PRINT(fmt,args...) { printk(KERN_INFO SOCPERF_MSG_PREFIX" " fmt,##args); }
+
+#define SOCPERF_PRINT_WARNING(fmt,args...) { printk(KERN_ALERT SOCPERF_MSG_PREFIX" [Warning] " fmt,##args); }
+
+#define SOCPERF_PRINT_ERROR(fmt,args...) { printk(KERN_CRIT SOCPERF_MSG_PREFIX" [ERROR] " fmt,##args); }
+
+// Macro to return the thread group id
+#define GET_CURRENT_TGID() (current->tgid)
+
+#if defined(DRV_IA32) || defined(DRV_EM64T)
+#define OVERFLOW_ARGS  U64*, U64*
+#elif defined(DRV_IA64)
+#define OVERFLOW_ARGS  U64*, U64*, U64*, U64*, U64*, U64*
+#endif
+
+/*
+ *  Dispatch table for virtualized functions.
+ *  Used to enable common functionality for different
+ *  processor microarchitectures
+ */
+typedef struct DISPATCH_NODE_S  DISPATCH_NODE;
+typedef        DISPATCH_NODE   *DISPATCH;
+
+struct DISPATCH_NODE_S {
+    VOID (*init)(PVOID);
+    VOID (*fini)(PVOID);
+    VOID (*write)(PVOID);
+    VOID (*freeze)(PVOID);
+    VOID (*restart)(PVOID);
+    VOID (*read_data)(PVOID);
+    VOID (*check_overflow)(DRV_MASKS);
+    VOID (*swap_group)(DRV_BOOL);
+    VOID (*read_lbrs)(PVOID);
+    VOID (*clean_up)(PVOID);
+    VOID (*hw_errata)(VOID);
+    VOID (*read_power)(PVOID);
+    U64  (*check_overflow_errata)(ECB, U32, U64);
+    VOID (*read_counts)(PVOID, U32);
+    U64  (*check_overflow_gp_errata)(ECB,U64*);
+    VOID (*read_ro)(PVOID, U32, U32);
+    U64  (*platform_info)(VOID);
+    VOID (*trigger_read)(VOID);    // Counter reads triggered/initiated by User mode timer
+    VOID (*read_current_data)(PVOID);
+    VOID (*create_mem)(U32, U64*);
+    VOID (*check_status)(U64*, U32*);
+    VOID (*read_mem)(U64, U64*, U32);
+    VOID (*stop_mem)(VOID);
+};
+
+extern DISPATCH dispatch;
+
+extern VOID         **PMU_register_data;
+extern VOID         **desc_data;
+extern U64           *prev_counter_data;
+extern U64           *cur_counter_data;
+
+/*!
+ * @struct LWPMU_DEVICE_NODE_S
+ * @brief  Struct to hold fields per device
+ *           PMU_register_data_unc - MSR info
+ *           dispatch_unc          - dispatch table
+ *           em_groups_counts_unc  - # groups
+ *           pcfg_unc              - config struct
+ */
+typedef struct LWPMU_DEVICE_NODE_S  LWPMU_DEVICE_NODE;
+typedef        LWPMU_DEVICE_NODE   *LWPMU_DEVICE;
+
+struct LWPMU_DEVICE_NODE_S {
+    VOID       **PMU_register_data_unc;
+    DISPATCH   dispatch_unc;
+    S32        em_groups_count_unc;
+    VOID       *pcfg_unc;
+    U64        **acc_per_thread;
+    U64        **prev_val_per_thread;
+    U64        counter_mask;
+    U64        num_events;
+    U32        num_units;
+    VOID       *ec;
+    S32        cur_group;
+};
+
+#define LWPMU_DEVICE_PMU_register_data(dev)   (dev)->PMU_register_data_unc
+#define LWPMU_DEVICE_dispatch(dev)            (dev)->dispatch_unc
+#define LWPMU_DEVICE_em_groups_count(dev)     (dev)->em_groups_count_unc
+#define LWPMU_DEVICE_pcfg(dev)                (dev)->pcfg_unc
+#define LWPMU_DEVICE_acc_per_thread(dev)      (dev)->acc_per_thread
+#define LWPMU_DEVICE_prev_val_per_thread(dev) (dev)->prev_val_per_thread
+#define LWPMU_DEVICE_counter_mask(dev)        (dev)->counter_mask
+#define LWPMU_DEVICE_num_events(dev)          (dev)->num_events
+#define LWPMU_DEVICE_num_units(dev)           (dev)->num_units
+#define LWPMU_DEVICE_ec(dev)                  (dev)->ec
+#define LWPMU_DEVICE_cur_group(dev)           (dev)->cur_group
+
+extern U32            num_devices;
+extern U32            cur_devices;
+extern LWPMU_DEVICE   device_uncore;
+extern U64           *pmu_state;
+
+// Handy macro
+#define TSC_SKEW(this_cpu)     (tsc_info[this_cpu] - tsc_info[0])
+
+#endif  
diff --git a/drivers/misc/intel/soc_perf/inc/utility.h b/drivers/misc/intel/soc_perf/inc/utility.h
new file mode 100644
index 000000000000..abe1a7f84019
--- /dev/null
+++ b/drivers/misc/intel/soc_perf/inc/utility.h
@@ -0,0 +1,76 @@
+/* ***********************************************************************************************
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  BSD LICENSE 
+
+  Copyright(C) 2005-2018 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ***********************************************************************************************
+*/
+
+
+#ifndef _UTILITY_H_
+#define _UTILITY_H_
+
+extern void  SOCPERF_UTILITY_Read_TSC (U64* pTsc);
+
+extern void
+SOCPERF_UTILITY_Read_Cpuid(
+    U64  cpuid_function,
+    U64 *rax_value,
+    U64 *rbx_value,
+    U64 *rcx_value,
+    U64 *rdx_value
+);
+
+extern  DISPATCH
+SOCPERF_UTILITY_Configure_CPU (U32);
+
+#endif 
-- 
2.18.0

