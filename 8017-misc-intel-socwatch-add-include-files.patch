From be02c935544860d7dd7ce0735f43180109ee788e Mon Sep 17 00:00:00 2001
From: Miguel Bernal Marin <miguel.bernal.marin@linux.intel.com>
Date: Wed, 29 Aug 2018 06:33:25 -0500
Subject: [PATCH 8017/8021] misc: intel: socwatch: add include files

---
 .../misc/intel/socwatch/include/sw_defines.h  | 156 ++++++
 .../misc/intel/socwatch/include/sw_ioctl.h    | 249 +++++++++
 .../socwatch/include/sw_kernel_defines.h      | 170 +++++++
 .../misc/intel/socwatch/include/sw_structs.h  | 478 ++++++++++++++++++
 .../misc/intel/socwatch/include/sw_types.h    | 152 ++++++
 .../intel/socwatch/include/sw_user_defines.h  | 404 +++++++++++++++
 .../misc/intel/socwatch/include/sw_version.h  |  74 +++
 7 files changed, 1683 insertions(+)
 create mode 100644 drivers/misc/intel/socwatch/include/sw_defines.h
 create mode 100644 drivers/misc/intel/socwatch/include/sw_ioctl.h
 create mode 100644 drivers/misc/intel/socwatch/include/sw_kernel_defines.h
 create mode 100644 drivers/misc/intel/socwatch/include/sw_structs.h
 create mode 100644 drivers/misc/intel/socwatch/include/sw_types.h
 create mode 100644 drivers/misc/intel/socwatch/include/sw_user_defines.h
 create mode 100644 drivers/misc/intel/socwatch/include/sw_version.h

diff --git a/drivers/misc/intel/socwatch/include/sw_defines.h b/drivers/misc/intel/socwatch/include/sw_defines.h
new file mode 100644
index 000000000000..6851d840496c
--- /dev/null
+++ b/drivers/misc/intel/socwatch/include/sw_defines.h
@@ -0,0 +1,156 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 - 2017 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Contact Information:
+  SoC Watch Developer Team <socwatchdevelopers@intel.com>
+  Intel Corporation,
+  1906 Fox Drive,
+  Champaign, IL 61820
+
+  BSD LICENSE
+
+  Copyright(c) 2014 - 2017 Intel Corporation.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef _PW_DEFINES_H_
+#define _PW_DEFINES_H_ 1
+
+#include "sw_version.h"
+
+/* ***************************************************
+ * Common to kernel and userspace.
+ * ***************************************************
+ */
+#define PW_SUCCESS              0
+#define PW_ERROR                1
+#define PW_SUCCESS_NO_COLLECT   2
+
+/*
+ * Helper macro to convert 'u64' to 'unsigned long long' to avoid gcc warnings.
+ */
+#define TO_ULL(x) (unsigned long long)(x)
+/*
+* Convert an arg to 'long long'
+*/
+#define TO_LL(x) (long long)(x)
+/*
+ * Convert an arg to 'unsigned long'
+ */
+#define TO_UL(x) (unsigned long)(x)
+/*
+ * Helper macro for string representation of a boolean value.
+ */
+#define GET_BOOL_STRING(b) ( (b) ? "TRUE" : "FALSE" )
+
+/*
+ * Circularly increment 'i' MODULO 'l'.
+ * ONLY WORKS IF 'l' is (power of 2 - 1) ie.
+ * l == (2 ^ x) - 1
+ */
+#define CIRCULAR_INC(index, mask) ( ( (index) + 1) & (mask) )
+#define CIRCULAR_ADD(index, val, mask) ( ( (index) + (val) ) & (mask) )
+/*
+ * Circularly decrement 'i'.
+ */
+#define CIRCULAR_DEC(i,m) ({int __tmp1 = (i); if(--__tmp1 < 0) __tmp1 = (m); __tmp1;})
+/*
+ * Should the driver count number of dropped samples?
+ */
+#define DO_COUNT_DROPPED_SAMPLES 1
+/*
+ * Retrieve size of an array.
+ */
+#define SW_ARRAY_SIZE(array) ( sizeof(array) / sizeof((array)[0]) )
+/*
+ * Extract F/W major, minor versions.
+ * Assumes version numbers are 8b unsigned ints.
+ */
+#define SW_GET_SCU_FW_VERSION_MAJOR(ver) ( ( (ver) >> 8 ) & 0xff )
+#define SW_GET_SCU_FW_VERSION_MINOR(ver) ( (ver) & 0xff )
+/*
+ * Max size of process name retrieved from kernel.
+ */
+#define SW_MAX_PROC_NAME_SIZE 16
+
+/*
+ * Number of SOCPERF counters.
+ * Needed by both Ring-0 and Ring-3
+ */
+#define SW_NUM_SOCPERF_COUNTERS 9
+
+/*
+ * Max size of process name retrieved from kernel space.
+ */
+#define SW_MAX_PROC_NAME_SIZE 16
+/*
+ * Max size of kernel wakelock name.
+ */
+#define SW_MAX_KERNEL_WAKELOCK_NAME_SIZE 100
+
+/* Data value read when a telemetry data read fails. */
+#define SW_TELEM_READ_FAIL_VALUE 0xF00DF00DF00DF00D
+
+#ifdef __KERNEL__
+    #include "sw_kernel_defines.h"
+#else // __KERNEL__
+    #include "sw_user_defines.h"
+#endif // __KERNEL__
+
+#ifdef SWW_MERGE
+typedef enum {
+    SW_STOP_EVENT = 0,
+    SW_CS_EXIT_EVENT,
+    SW_COUNTER_RESET_EVENT,
+    SW_COUNTER_HOTKEY_EVENT,
+    SW_MAX_COLLECTION_EVENT
+} collector_stop_event_t;
+#endif // SWW_MERGE
+
+#define MAX_UNSIGNED_16_BIT_VALUE 0xFFFF
+#define MAX_UNSIGNED_24_BIT_VALUE 0xFFFFFF
+#define MAX_UNSIGNED_32_BIT_VALUE 0xFFFFFFFF
+#define MAX_UNSIGNED_64_BIT_VALUE 0xFFFFFFFFFFFFFFFF
+
+#endif // _PW_DEFINES_H_
diff --git a/drivers/misc/intel/socwatch/include/sw_ioctl.h b/drivers/misc/intel/socwatch/include/sw_ioctl.h
new file mode 100644
index 000000000000..3fd7fe5b4bed
--- /dev/null
+++ b/drivers/misc/intel/socwatch/include/sw_ioctl.h
@@ -0,0 +1,249 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 - 2018 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Contact Information:
+  SoC Watch Developer Team <socwatchdevelopers@intel.com>
+  Intel Corporation,
+  1906 Fox Drive,
+  Champaign, IL 61820
+
+  BSD LICENSE
+
+  Copyright(c) 2014 - 2018 Intel Corporation.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+#ifndef __SW_IOCTL_H__
+#define __SW_IOCTL_H__ 1
+
+#if defined (__linux__) || defined (__QNX__)
+    #if __KERNEL__
+        #include <linux/ioctl.h>
+        #if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
+            #include <asm/compat.h>
+            #include <linux/compat.h>
+        #endif // COMPAT && x64
+    #else // !__KERNEL__
+        #include <sys/ioctl.h>
+    #endif // __KERNEL__
+#endif // __linux__
+/*
+ * Ensure we pull in definition of 'DO_COUNT_DROPPED_SAMPLES'!
+ */
+#include "sw_defines.h"
+
+#ifdef ONECORE
+#ifndef __KERNEL__
+#include <winioctl.h>
+#endif //__KERNEL__
+#endif // ONECORE
+
+/*
+ * The APWR-specific IOCTL magic
+ * number -- used to ensure IOCTLs
+ * are delivered to the correct
+ * driver.
+ */
+// #define APWR_IOCTL_MAGIC_NUM 0xdead
+#define APWR_IOCTL_MAGIC_NUM 100
+
+/*
+ * The name of the device file
+ */
+// #define DEVICE_FILE_NAME "/dev/pw_driver_char_dev"
+#define PW_DEVICE_FILE_NAME "/dev/apwr_driver_char_dev"
+#define PW_DEVICE_NAME "apwr_driver_char_dev"
+
+enum sw_ioctl_cmd {
+    sw_ioctl_cmd_none=0,
+    sw_ioctl_cmd_config,
+    sw_ioctl_cmd_cmd,
+    sw_ioctl_cmd_poll,
+    sw_ioctl_cmd_immediate_io,
+    sw_ioctl_cmd_scu_version,
+    sw_ioctl_cmd_read_immediate,
+    sw_ioctl_cmd_driver_version,
+    sw_ioctl_cmd_avail_trace,
+    sw_ioctl_cmd_avail_notify,
+    sw_ioctl_cmd_avail_collect,
+    sw_ioctl_cmd_topology_changes,
+};
+/*
+ * The actual IOCTL commands.
+ *
+ * From the kernel documentation:
+ * "_IOR" ==> Read IOCTL
+ * "_IOW" ==> Write IOCTL
+ * "_IOWR" ==> Read/Write IOCTL
+ *
+ * Where "Read" and "Write" are from the user's perspective
+ * (similar to the file "read" and "write" calls).
+ */
+#ifdef SWW_MERGE // Windows
+     //
+     // Device type           -- in the "User Defined" range."
+     //
+    #define POWER_I_CONF_TYPE 40000
+
+    // List assigned tracepoint id
+    #define CSIR_TRACEPOINT_ID_MASK            1
+    #define DEVICE_STATE_TRACEPOINT_ID_MASK    2
+    #define CSIR_SEPARATE_TRACEPOINT_ID_MASK   3
+    #define RESET_TRACEPOINT_ID_MASK           4
+    #define DISPLAY_ON_TRACEPOINT_ID_MASK      5
+
+#ifdef SWW_MERGE
+    //
+    // TELEM BAR CONFIG
+    //
+    #define MAX_TELEM_BAR_CFG 3
+    #define TELEM_MCHBAR_CFG 0
+    #define TELEM_IPC1BAR_CFG 1
+    #define TELEM_SSRAMBAR_CFG 2
+#endif
+
+    //
+    // The IOCTL function codes from 0x800 to 0xFFF are for customer use.
+    //
+    #define PW_IOCTL_CONFIG \
+        CTL_CODE( POWER_I_CONF_TYPE, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS  )
+    #define PW_IOCTL_START_COLLECTION \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_STOP_COLLECTION \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+    // TODO: pause, resume, cancel not supported yet
+    #define PW_IOCTL_PAUSE_COLLECTION \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x903, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_RESUME_COLLECTION \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x904, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_CANCEL_COLLECTION \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x905, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+    #define PW_IOCTL_GET_PROCESSOR_GROUP_TOPOLOGY \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x906, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_TOPOLOGY \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x907, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_GET_AVAILABLE_COLLECTORS \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x908, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_IMMEDIATE_IO \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x909, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_DRV_CLEANUP \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x90A, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_SET_COLLECTION_EVENT \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x90B, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_TRY_STOP_EVENT \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x90C, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_SET_PCH_ACTIVE_INTERVAL \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x90D, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_SET_TELEM_BAR \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x90E, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_METADATA \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x90F, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_SET_GBE_INTERVAL \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x910, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_ENABLE_COLLECTION \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x911, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_DISABLE_COLLECTION \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x912, METHOD_BUFFERED, FILE_ANY_ACCESS)
+    #define PW_IOCTL_DRIVER_BUILD_DATE \
+        CTL_CODE(POWER_I_CONF_TYPE, 0x913, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#elif !defined (__APPLE__)
+    #define PW_IOCTL_CONFIG _IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, struct sw_driver_ioctl_arg *)
+    #if DO_COUNT_DROPPED_SAMPLES
+        #define PW_IOCTL_CMD _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg *)
+    #else
+        #define PW_IOCTL_CMD _IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg *)
+    #endif // DO_COUNT_DROPPED_SAMPLES
+    #define PW_IOCTL_POLL _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
+    #define PW_IOCTL_IMMEDIATE_IO _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, struct sw_driver_ioctl_arg *)
+    #define PW_IOCTL_GET_SCU_FW_VERSION _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, struct sw_driver_ioctl_arg *)
+    #define PW_IOCTL_READ_IMMEDIATE _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, struct sw_driver_ioctl_arg *)
+    #define PW_IOCTL_GET_DRIVER_VERSION _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, struct sw_driver_ioctl_arg *)
+    #define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, struct sw_driver_ioctl_arg *)
+    #define PW_IOCTL_GET_AVAILABLE_NOTIFIERS _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, struct sw_driver_ioctl_arg *)
+    #define PW_IOCTL_GET_AVAILABLE_COLLECTORS _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, struct sw_driver_ioctl_arg *)
+    #define PW_IOCTL_GET_TOPOLOGY_CHANGES _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, struct sw_driver_ioctl_arg *)
+#else // __APPLE__
+    #define PW_IOCTL_CONFIG _IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, struct sw_driver_ioctl_arg)
+    #if DO_COUNT_DROPPED_SAMPLES
+        #define PW_IOCTL_CMD _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg)
+    #else
+        #define PW_IOCTL_CMD _IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, struct sw_driver_ioctl_arg)
+    #endif // DO_COUNT_DROPPED_SAMPLES
+    #define PW_IOCTL_POLL _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
+    #define PW_IOCTL_IMMEDIATE_IO _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, struct sw_driver_ioctl_arg)
+    #define PW_IOCTL_GET_SCU_FW_VERSION _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, struct sw_driver_ioctl_arg)
+    #define PW_IOCTL_READ_IMMEDIATE _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, struct sw_driver_ioctl_arg)
+    #define PW_IOCTL_GET_DRIVER_VERSION _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, struct sw_driver_ioctl_arg)
+    #define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, struct sw_driver_ioctl_arg)
+    #define PW_IOCTL_GET_AVAILABLE_NOTIFIERS _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, struct sw_driver_ioctl_arg)
+    #define PW_IOCTL_GET_AVAILABLE_COLLECTORS _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, struct sw_driver_ioctl_arg)
+    #define PW_IOCTL_GET_TOPOLOGY_CHANGES _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, struct sw_driver_ioctl_arg)
+#endif // __APPLE__
+
+/*
+ * 32b-compatible version of the above
+ * IOCTL numbers. Required ONLY for
+ * 32b compatibility on 64b systems,
+ * and ONLY by the driver.
+ */
+#if defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
+    #define PW_IOCTL_CONFIG32 _IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_config, compat_uptr_t)
+#if DO_COUNT_DROPPED_SAMPLES
+        #define PW_IOCTL_CMD32 _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, compat_uptr_t)
+#else
+        #define PW_IOCTL_CMD32 _IOW(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_cmd, compat_uptr_t)
+#endif // DO_COUNT_DROPPED_SAMPLES
+    #define PW_IOCTL_POLL32 _IO(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_poll)
+    #define PW_IOCTL_IMMEDIATE_IO32 _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_immediate_io, compat_uptr_t)
+    #define PW_IOCTL_GET_SCU_FW_VERSION32 _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_scu_version, compat_uptr_t)
+    #define PW_IOCTL_READ_IMMEDIATE32 _IOWR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_read_immediate, compat_uptr_t)
+    #define PW_IOCTL_GET_DRIVER_VERSION32 _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_driver_version, compat_uptr_t)
+    #define PW_IOCTL_GET_AVAILABLE_TRACEPOINTS32 _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_trace, compat_uptr_t)
+    #define PW_IOCTL_GET_AVAILABLE_NOTIFIERS32 _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_notify, compat_uptr_t)
+    #define PW_IOCTL_GET_AVAILABLE_COLLECTORS32 _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_avail_collect, compat_uptr_t)
+    #define PW_IOCTL_GET_TOPOLOGY_CHANGES32 _IOR(APWR_IOCTL_MAGIC_NUM, sw_ioctl_cmd_topology_changes, compat_uptr_t)
+#endif // defined(CONFIG_COMPAT) && defined(CONFIG_X86_64)
+#endif // __SW_IOCTL_H__
diff --git a/drivers/misc/intel/socwatch/include/sw_kernel_defines.h b/drivers/misc/intel/socwatch/include/sw_kernel_defines.h
new file mode 100644
index 000000000000..69b22d17cfab
--- /dev/null
+++ b/drivers/misc/intel/socwatch/include/sw_kernel_defines.h
@@ -0,0 +1,170 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 - 2017 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Contact Information:
+  SoC Watch Developer Team <socwatchdevelopers@intel.com>
+  Intel Corporation,
+  1906 Fox Drive,
+  Champaign, IL 61820
+
+  BSD LICENSE
+
+  Copyright(c) 2014 - 2017 Intel Corporation.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+#ifndef _PW_KERNEL_DEFINES_H_
+#define _PW_KERNEL_DEFINES_H_ 1
+
+#ifdef __KERNEL__
+
+/* ***************************************************
+ * The following is only valid for kernel code.
+ * ***************************************************
+ */
+
+#if defined (__APPLE__)
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+#endif // __APPLE__
+
+#if !defined(__APPLE__)
+    #define CPU() (raw_smp_processor_id())
+    #define RAW_CPU() (raw_smp_processor_id())
+#else
+    #define CPU() (cpu_number())
+    #define RAW_CPU() (cpu_number())
+#endif // __APPLE__
+
+#define TID() (current->pid)
+#define PID() (current->tgid)
+#define NAME() (current->comm)
+#define PKG(c) ( cpu_data(c).phys_proc_id )
+#define IT_REAL_INCR() (current->signal->it_real_incr.tv64)
+
+#define ATOMIC_CAS(ptr, old_val, new_val) ( cmpxchg( (ptr), (old_val), (new_val) ) == (old_val) )
+
+/*
+ * Should we measure overheads?
+ * '1' ==> YES
+ * '0' ==> NO
+ */
+#define DO_OVERHEAD_MEASUREMENTS 0
+/*
+ * Should we track memory usage?
+ * '1' ==> YES
+ * '0' ==> NO
+ */
+#define DO_TRACK_MEMORY_USAGE 0
+/*
+ * Are we compiling with driver profiling support
+ * turned ON? If YES then force 'DO_OVERHEAD_MEASUREMENTS'
+ * and 'DO_TRACK_MEMORY_USAGE' to be TRUE.
+ */
+#if DO_DRIVER_PROFILING
+    #if !DO_OVERHEAD_MEASUREMENTS
+        #undef DO_OVERHEAD_MEASUREMENTS
+        #define DO_OVERHEAD_MEASUREMENTS 1
+    #endif // DO_OVERHEAD_MEASUREMENTS
+    #if !DO_TRACK_MEMORY_USAGE
+        #undef DO_TRACK_MEMORY_USAGE
+        #define DO_TRACK_MEMORY_USAGE 1
+    #endif // DO_TRACK_MEMORY_USAGE
+#endif // DO_DRIVER_PROFILING
+/*
+ * Should we allow debug output.
+ * Set to: "1" ==> 'OUTPUT' is enabled.
+ *         "0" ==> 'OUTPUT' is disabled.
+ */
+#define DO_DEBUG_OUTPUT 0
+/*
+ * Control whether to output driver ERROR messages.
+ * These are independent of the 'OUTPUT' macro
+ * (which controls debug messages).
+ * Set to '1' ==> Print driver error messages (to '/var/log/messages')
+ *        '0' ==> Do NOT print driver error messages
+ */
+#define DO_PRINT_DRIVER_ERROR_MESSAGES 1
+/*
+ * Macros to control output printing.
+ */
+#if !defined(__APPLE__)
+    #if DO_DEBUG_OUTPUT
+        #define pw_pr_debug(...) printk(KERN_INFO __VA_ARGS__)
+        #define pw_pr_warn(...) printk(KERN_WARNING __VA_ARGS__)
+    #else
+        #define pw_pr_debug(...)
+        #define pw_pr_warn(...)
+    #endif
+    #define pw_pr_force(...) printk(KERN_INFO __VA_ARGS__)
+#else
+    #if DO_DEBUG_OUTPUT
+        #define pw_pr_debug(...) IOLog(__VA_ARGS__)
+        #define pw_pr_warn(...) IOLog(__VA_ARGS__)
+    #else
+        #define pw_pr_debug(...)
+        #define pw_pr_warn(...)
+    #endif
+    #define pw_pr_force(...) IOLog(__VA_ARGS__)
+#endif // __APPLE__
+
+/*
+ * Macro for driver error messages.
+ */
+#if !defined(__APPLE__)
+    #if (DO_PRINT_DRIVER_ERROR_MESSAGES || DO_DEBUG_OUTPUT)
+        #define pw_pr_error(...) printk(KERN_ERR __VA_ARGS__)
+    #else
+        #define pw_pr_error(...)
+    #endif
+#else
+    #if (DO_PRINT_DRIVER_ERROR_MESSAGES || DO_DEBUG_OUTPUT)
+        #define pw_pr_error(...) IOLog(__VA_ARGS__)
+    #else
+        #define pw_pr_error(...)
+    #endif
+#endif // __APPLE__
+
+#endif // __KERNEL__
+
+#endif // _PW_KERNEL_DEFINES_H_
diff --git a/drivers/misc/intel/socwatch/include/sw_structs.h b/drivers/misc/intel/socwatch/include/sw_structs.h
new file mode 100644
index 000000000000..844fc98ecb9b
--- /dev/null
+++ b/drivers/misc/intel/socwatch/include/sw_structs.h
@@ -0,0 +1,478 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 - 2017 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Contact Information:
+  SoC Watch Developer Team <socwatchdevelopers@intel.com>
+  Intel Corporation,
+  1906 Fox Drive,
+  Champaign, IL 61820
+
+  BSD LICENSE
+
+  Copyright(c) 2014 - 2017 Intel Corporation.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+#ifndef __SW_STRUCTS_H__
+#define __SW_STRUCTS_H__ 1
+
+#include "sw_types.h"
+
+/*
+ * An enumeration of MSR types.
+ * Required if we want to differentiate
+ * between different types of MSRs.
+ */
+enum sw_msr_type {
+    SW_MSR_TYPE_THREAD,
+    SW_MSR_TYPE_CORE,
+    SW_MSR_TYPE_MODULE,
+    SW_MSR_TYPE_PACKAGE,
+    SW_MSR_TYPE_SOC,
+    SW_MSR_TYPE_MAX,
+};
+
+/*
+ * Convenience for a 'string' data type.
+ * Not strictly required.
+ */
+#pragma pack(push, 1)
+typedef struct sw_string_type {
+    pw_u16_t len;
+    char data[1];
+} sw_string_type_t;
+#pragma pack(pop)
+#define SW_STRING_TYPE_HEADER_SIZE() (sizeof(struct sw_string_type) - sizeof(char[1]))
+
+#pragma pack(push, 1)
+struct sw_key_value_payload {
+    pw_u16_t m_numKeyValuePairs;
+    char data[1];
+};
+#pragma pack(pop)
+#define SW_KEY_VALUE_PAYLOAD_HEADER_SIZE() (sizeof(struct sw_key_value_payload) - sizeof(char[1]))
+
+typedef enum sw_kernel_wakelock_type {
+    SW_WAKE_LOCK        =0, // A kernel wakelock was acquired
+    SW_WAKE_UNLOCK      =1, // A kernel wakelock was released
+    SW_WAKE_LOCK_TIMEOUT=2, // A kernel wakelock was acquired with a timeout
+    SW_WAKE_LOCK_INITIAL=3, // A kernel wakelock was acquired before the
+                            //   collection started
+    SW_WAKE_UNLOCK_ALL  =4, // All previously held kernel wakelocks were
+                            //   released -- used in ACPI S3 notifications
+} sw_kernel_wakelock_type_t;
+
+typedef enum sw_when_type {
+    SW_WHEN_TYPE_BEGIN=0, /* Start snapshot */
+    SW_WHEN_TYPE_POLL,
+    SW_WHEN_TYPE_NOTIFIER,
+    SW_WHEN_TYPE_TRACEPOINT,
+    SW_WHEN_TYPE_END, /* Stop snapshot */
+    SW_WHEN_TYPE_NONE
+} sw_when_type_t;
+
+/**
+ * trigger_bits is defined to use type pw_u8_t that makes only upto 8 types possible 
+ */
+#define SW_TRIGGER_BEGIN_MASK()      (1U << SW_WHEN_TYPE_BEGIN)
+#define SW_TRIGGER_END_MASK()        (1U << SW_WHEN_TYPE_END)
+#define SW_TRIGGER_POLL_MASK()       (1U << SW_WHEN_TYPE_POLL)
+#define SW_TRIGGER_TRACEPOINT_MASK() (1U << SW_WHEN_TYPE_TRACEPOINT)
+#define SW_TRIGGER_NOTIFIER_MASK()   (1U << SW_WHEN_TYPE_NOTIFIER)
+#define SW_GET_TRIGGER_MASK_VALUE(m) (1U << (m))
+#define SW_TRIGGER_MASK_ALL()        (0xFF)
+
+enum sw_io_cmd {
+    SW_IO_CMD_READ=0,
+    SW_IO_CMD_WRITE,
+    SW_IO_CMD_MAX
+};
+
+
+#pragma pack(push, 1)
+struct sw_driver_msr_io_descriptor {
+    pw_u64_t address;
+    enum sw_msr_type type;
+};
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+struct sw_driver_ipc_mmio_io_descriptor {
+    union {
+        struct {
+            pw_u16_t command;
+            pw_u16_t sub_command;
+        };
+        union {
+            pw_u32_t ipc_command; // (sub_command << 12) | (command)
+            pw_u8_t is_gbe; // Used only for GBE MMIO
+        };
+    };
+    // TODO: add a section for 'ctrl_address' and 'ctrl_remapped_address'
+    union {
+        pw_u64_t data_address; // Will be "io_remapped"
+        pw_u64_t data_remapped_address;
+    };
+};
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+struct sw_driver_pci_io_descriptor {
+    pw_u32_t bus;
+    pw_u32_t device;
+    pw_u32_t function;
+#ifdef __QNX__
+    union {
+        pw_u32_t offset;
+        pw_u32_t index;
+    };
+#else /* __QNX__ */
+    pw_u32_t offset;
+#endif /* __QNX__ */
+};
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+struct sw_driver_configdb_io_descriptor {
+    // pw_u32_t port;
+    // pw_u32_t offset;
+    pw_u32_t address;
+};
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+struct sw_driver_trace_args_io_descriptor {
+    pw_u8_t num_args; // Number of valid entries in the 'args' array, below; 1 <= num_args <= 7
+    pw_u8_t args[7]; // Max of 7 args can be recorded
+};
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+/**
+ * struct - sw_driver_telem_io_descriptor - Telemetry Metric descriptor
+ *
+ * @id:    (Client & Driver) Telemetry ID of the counter to read.
+ * @idx:   (Driver only) index into telem array to read, or the row
+ *            of the telem_indirect table to lookup the telem array index.
+ * @unit:  Unit from which to collect:  0 = PMC, 1 = PUNIT
+ *              Values come from the telemetry_unit enum.
+ * @scale_op:  When there are multiple instances of a telem value (e.g.
+ *              module C-states) the operation to use when scaling the CPU ID
+ *              and adding it to the telemetry data ID.
+ * @scale_val: Amount to scale an ID (when scaling one.)
+ *
+ * Like all hardware mechanism descriptors, the client uses this to pass
+ * metric hardware properties (unit and ID) to the driver.  The driver
+ * uses it to program the telemetry unit.
+ *
+ * Users can specify that IDs should be scaled based on the CPU id, using
+ * the equation: ID = ID_value + (cpuid <scaling_op> <scaling_val>)
+ * where <scaling_op> is one of +, *, /, or %, and scaling_val is an integer
+ * value.  This gives you:
+ *            Operation             scale_op     scale_val
+ *       Single instance of an ID       *            0
+ *       Sequentially increasing
+ *          CPU-specific values         *            1
+ *       Per module cpu-specific
+ *          values (2 cores/module)     /            2
+ *       Round Robin assignment         %         cpu_count
+ *
+ * Note that scaling_value of 0 implies that no scaling should be
+ * applied.  While (*, 1) is equivalent to (+, 0), the scaling value of 0
+ * is reserved/defined to mean "no scaling", and is disallowed.
+ *
+ * If you're really tight on space, you could always fold unit and
+ * scale_op into a single byte without a lot of pain or even effort.
+ */
+struct sw_driver_telem_io_descriptor {
+    union {
+        pw_u16_t id;
+        pw_u8_t  idx;
+    };
+    pw_u8_t   unit;
+    pw_u8_t   scale_op;
+    pw_u16_t  scale_val;
+};
+#pragma pack(pop)
+enum telemetry_unit { TELEM_PUNIT = 0, TELEM_PMC, TELEM_UNIT_NONE };
+#define TELEM_MAX_ID    0xFFFF  /* Maximum value of a Telemtry event ID. */
+#define TELEM_MAX_SCALE 0xFFFF  /* Maximum ID scaling value. */
+#define TELEM_OP_ADD    '+'     /* Addition operator */
+#define TELEM_OP_MULT   '*'     /* Multiplication operator */
+#define TELEM_OP_DIV    '/'     /* Division operator */
+#define TELEM_OP_MOD    '%'     /* Modulus operator */
+#define TELEM_OP_NONE   'X'     /* No operator--Not a scaled ID */
+
+#pragma pack(push, 1)
+struct sw_driver_mailbox_io_descriptor {
+    union {
+        /*
+         * Will be "io_remapped"
+         */
+        pw_u64_t interface_address;
+        pw_u64_t interface_remapped_address;
+    };
+    union {
+        /*
+         * Will be "io_remapped"
+         */
+        pw_u64_t data_address;
+        pw_u64_t data_remapped_address;
+    };
+    pw_u64_t command;
+    pw_u64_t command_mask;
+    pw_u16_t run_busy_bit;
+    pw_u16_t is_msr_type;
+};
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+struct sw_driver_pch_mailbox_io_descriptor {
+    union {
+        /*
+         * Will be "io_remapped"
+         */
+        pw_u64_t mtpmc_address;
+        pw_u64_t mtpmc_remapped_address;
+    };
+    union {
+        /*
+         * Will be "io_remapped"
+         */
+        pw_u64_t msg_full_sts_address;
+        pw_u64_t msg_full_sts_remapped_address;
+    };
+    union {
+        /*
+         * Will be "io_remapped"
+         */
+        pw_u64_t mfpmc_address;
+        pw_u64_t mfpmc_remapped_address;
+    };
+    pw_u32_t data_address;
+};
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+typedef struct sw_driver_io_descriptor {
+    pw_u16_t collection_type;
+    // TODO: specify READ/WRITE
+    pw_s16_t collection_command; // One of 'enum sw_io_cmd'
+    pw_u16_t counter_size_in_bytes; // The number of bytes to READ or WRITE
+    union {
+        struct sw_driver_msr_io_descriptor        msr_descriptor;
+        struct sw_driver_ipc_mmio_io_descriptor   ipc_descriptor;
+        struct sw_driver_ipc_mmio_io_descriptor   mmio_descriptor;
+        struct sw_driver_pci_io_descriptor        pci_descriptor;
+        struct sw_driver_configdb_io_descriptor   configdb_descriptor;
+        struct sw_driver_trace_args_io_descriptor trace_args_descriptor;
+        struct sw_driver_telem_io_descriptor      telem_descriptor;
+        struct sw_driver_pch_mailbox_io_descriptor pch_mailbox_descriptor;
+        struct sw_driver_mailbox_io_descriptor    mailbox_descriptor;
+    };
+    pw_u64_t write_value; // The value to WRITE
+} sw_driver_io_descriptor_t;
+#pragma pack(pop)
+
+/**
+ * sw_driver_interface_info is used to map data collected by kernel-level
+ * collectors to metrics.  The client passes one of these structs to the
+ * driver for each metric the driver should collect.  The driver tags the
+ * collected data (messages) using info from this struct. When processing
+ * data from the driver, the client uses its copy of this data to
+ * identify the plugin, metric, and message IDs of each message.
+ */
+#pragma pack(push, 1)
+struct sw_driver_interface_info {
+    pw_u64_t tracepoint_id_mask;
+    pw_u64_t notifier_id_mask;
+    pw_s16_t cpu_mask;  // On which CPU(s) should the driver read the data?
+                        // Currently:  -2 ==> read on ALL CPUs,
+                        //             -1 ==> read on ANY CPU,
+                        //           >= 0 ==> the specific CPU to read on
+    pw_s16_t plugin_id; // Metric Plugin SID
+    pw_s16_t metric_id; // Domain-specific ID assigned by each Metric Plugin
+    pw_s16_t msg_id;    // Msg ID retrieved from the SoC Watch config file
+    pw_u16_t num_io_descriptors; // Number of descriptors in the array, below.
+    pw_u8_t  trigger_bits;  // Mask of 'when bits' to fire this collector.
+    pw_u16_t sampling_interval_msec; // Sampling interval, in msecs
+    pw_u8_t  descriptors[1];     // Array of sw_driver_io_descriptor structs.
+};
+#pragma pack(pop)
+
+#define SW_DRIVER_INTERFACE_INFO_HEADER_SIZE() (sizeof(struct sw_driver_interface_info) - sizeof(pw_u8_t[1]))
+
+#pragma pack(push, 1)
+struct sw_driver_interface_msg {
+    pw_u16_t num_infos; // Number of 'sw_driver_interface_info' structs contained within the 'infos' variable, below
+    pw_u16_t min_polling_interval_msecs; // Min time to wait before polling; used exclusively
+                                         // with the low overhead, context-switch based
+                                         // polling mode
+    // pw_u16_t infos_size_bytes; // Size of data inlined within the 'infos' variable, below
+    pw_u8_t infos[1];
+};
+#pragma pack(pop)
+#define SW_DRIVER_INTERFACE_MSG_HEADER_SIZE() (sizeof(struct sw_driver_interface_msg) - sizeof(pw_u8_t[1]))
+
+typedef enum sw_name_id_type {
+    SW_NAME_TYPE_TRACEPOINT,
+    SW_NAME_TYPE_NOTIFIER,
+    SW_NAME_TYPE_COLLECTOR,
+    SW_NAME_TYPE_MAX,
+} sw_name_id_type_t;
+
+#pragma pack(push, 1)
+struct sw_name_id_pair {
+    pw_u16_t id;
+    pw_u16_t type; // One of 'sw_name_id_type'
+    struct sw_string_type name;
+};
+#pragma pack(pop)
+#define SW_NAME_ID_HEADER_SIZE() (sizeof(struct sw_name_id_pair) - sizeof(struct sw_string_type))
+
+#pragma pack(push, 1)
+struct sw_name_info_msg {
+    pw_u16_t num_name_id_pairs;
+    pw_u16_t payload_len;
+    pw_u8_t pairs[1];
+};
+#pragma pack(pop)
+
+/**
+ * This is the basic data structure for passing data collected by the
+ * kernel-level collectors up to the client.  In addition to the data
+ * (payload), it contains the minimum metadata required for the client
+ * to identify the source of that data.
+ */
+#pragma pack(push, 1)
+typedef struct sw_driver_msg {
+    pw_u64_t tsc;
+    pw_u16_t cpuidx;
+    pw_u8_t  plugin_id;     // Cannot have more than 256 plugins
+    pw_u8_t  metric_id;     // Each plugin cannot handle more than 256 metrics
+    pw_u8_t  msg_id;        // Each metric cannot have more than 256 components
+    pw_u16_t payload_len;
+    // pw_u64_t p_payload;  // Ptr to payload
+    union {
+        pw_u64_t __dummy;   // Ensure size of struct is consistent on x86, x64
+        char    *p_payload; // Ptr to payload (collected data values).
+    };
+} sw_driver_msg_t;
+#pragma pack(pop)
+#define SW_DRIVER_MSG_HEADER_SIZE() (sizeof(struct sw_driver_msg) - sizeof(pw_u64_t))
+
+typedef enum sw_driver_collection_cmd {
+    SW_DRIVER_START_COLLECTION=1,
+    SW_DRIVER_STOP_COLLECTION=2,
+    SW_DRIVER_PAUSE_COLLECTION=3,
+    SW_DRIVER_RESUME_COLLECTION=4,
+    SW_DRIVER_CANCEL_COLLECTION=5,
+} sw_driver_collection_cmd_t;
+
+#pragma pack(push, 1)
+struct sw_driver_version_info {
+    pw_u16_t major;
+    pw_u16_t minor;
+    pw_u16_t other;
+};
+#pragma pack(pop)
+
+enum cpu_action {
+    SW_CPU_ACTION_NONE,
+    SW_CPU_ACTION_OFFLINE,
+    SW_CPU_ACTION_ONLINE_PREPARE,
+    SW_CPU_ACTION_ONLINE,
+    SW_CPU_ACTION_MAX,
+};
+#pragma pack(push, 1)
+struct sw_driver_topology_change {
+    pw_u64_t timestamp; // timestamp
+    enum cpu_action type; // One of 'enum cpu_action'
+    pw_u16_t cpu; // logical cpu
+    pw_u16_t core; // core id
+    pw_u16_t pkg; // pkg/physical id
+};
+struct sw_driver_topology_msg {
+    pw_u16_t num_entries;
+    pw_u8_t topology_entries[1];
+};
+#pragma pack(pop)
+
+/**
+ * An enumeration of possible pm states that
+ * SoC Watch is interested in
+ */
+enum sw_pm_action {
+    SW_PM_ACTION_NONE,
+    SW_PM_ACTION_SUSPEND_ENTER,
+    SW_PM_ACTION_SUSPEND_EXIT,
+    SW_PM_ACTION_HIBERNATE_ENTER,
+    SW_PM_ACTION_HIBERNATE_EXIT,
+    SW_PM_ACTION_MAX,
+};
+
+/*
+ * Wrapper for ioctl arguments.
+ * EVERY ioctl MUST use this struct!
+ */
+#pragma pack(push, 1)
+struct sw_driver_ioctl_arg {
+    pw_s32_t in_len;
+    pw_s32_t out_len;
+    // pw_u64_t p_in_arg; // Pointer to input arg
+    // pw_u64_t p_out_arg; // Pointer to output arg
+    char *in_arg;
+    char *out_arg;
+};
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+typedef struct sw_driver_msg_interval {
+    pw_u8_t  plugin_id;     // Cannot have more than 256 plugins
+    pw_u8_t  metric_id;     // Each plugin cannot handle more than 256 metrics
+    pw_u8_t  msg_id;        // Each metric cannot have more than 256 components
+    pw_u16_t interval;      // collection interval
+} sw_driver_msg_interval_t;
+#pragma pack(pop)
+
+#endif // __SW_STRUCTS_H__
diff --git a/drivers/misc/intel/socwatch/include/sw_types.h b/drivers/misc/intel/socwatch/include/sw_types.h
new file mode 100644
index 000000000000..f7201754b350
--- /dev/null
+++ b/drivers/misc/intel/socwatch/include/sw_types.h
@@ -0,0 +1,152 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 - 2017 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Contact Information:
+  SoC Watch Developer Team <socwatchdevelopers@intel.com>
+  Intel Corporation,
+  1906 Fox Drive,
+  Champaign, IL 61820
+
+  BSD LICENSE
+
+  Copyright(c) 2014 - 2017 Intel Corporation.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef _PW_TYPES_H_
+#define _PW_TYPES_H_
+
+#if defined (__linux__) || defined (__APPLE__) || defined (__QNX__)
+
+#ifndef __KERNEL__
+/*
+ * Called from Ring-3.
+ */
+#include <stdint.h> // Grab 'uint64_t' etc.
+#include <unistd.h> // Grab 'pid_t'
+/*
+ * UNSIGNED types...
+ */
+typedef uint8_t  u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint64_t u64;
+/*
+ * SIGNED types...
+ */
+typedef int8_t s8;
+typedef int16_t s16;
+typedef int32_t s32;
+typedef int64_t s64;
+
+#else // __KERNEL__
+#if !defined (__APPLE__)
+#include <linux/types.h>
+#else // __APPLE__
+#include <sys/types.h>
+#include <stdint.h> // Grab 'uint64_t' etc.
+
+typedef uint8_t  u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint64_t u64;
+/*
+* SIGNED types...
+*/
+typedef int8_t s8;
+typedef int16_t s16;
+typedef int32_t s32;
+typedef int64_t s64;
+#endif // __APPLE__
+#endif // __KERNEL__
+
+#elif defined (_WIN32)
+typedef __int32 int32_t;
+typedef unsigned __int32 uint32_t;
+typedef __int64 int64_t;
+typedef unsigned __int64 uint64_t;
+
+/*
+ * UNSIGNED types...
+ */
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef unsigned long long u64;
+
+/*
+ * SIGNED types...
+ */
+typedef signed char s8;
+typedef signed short s16;
+typedef signed int s32;
+typedef signed long long s64;
+typedef s32 pid_t;
+typedef s32 ssize_t;
+
+#endif // _WIN32
+
+/* ************************************
+ * Common to both operating systems.
+ * ************************************
+ */
+/*
+ * UNSIGNED types...
+ */
+typedef u8 pw_u8_t;
+typedef u16 pw_u16_t;
+typedef u32 pw_u32_t;
+typedef u64 pw_u64_t;
+
+/*
+ * SIGNED types...
+ */
+typedef s8 pw_s8_t;
+typedef s16 pw_s16_t;
+typedef s32 pw_s32_t;
+typedef s64 pw_s64_t;
+
+typedef pid_t pw_pid_t;
+
+#endif // _PW_TYPES_H_
diff --git a/drivers/misc/intel/socwatch/include/sw_user_defines.h b/drivers/misc/intel/socwatch/include/sw_user_defines.h
new file mode 100644
index 000000000000..531a538dbc23
--- /dev/null
+++ b/drivers/misc/intel/socwatch/include/sw_user_defines.h
@@ -0,0 +1,404 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2017 - 2018 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Contact Information:
+  SoC Watch Developer Team <socwatchdevelopers@intel.com>
+  Intel Corporation,
+  1906 Fox Drive,
+  Champaign, IL 61820
+
+  BSD LICENSE
+
+  Copyright(c) 2017 - 2018 Intel Corporation.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef _PW_USER_DEFINES_H_
+#define _PW_USER_DEFINES_H_ 1
+#ifndef __KERNEL__
+
+#include <stdio.h> // for "FILE *"
+#include <errno.h> // for "PW_PERROR"
+#include <string.h> // for "PW_PERROR"
+#include <fstream> // for "std::ofstream"
+#ifndef _WIN32
+    #include <sys/time.h> // for "gettimeofday"
+#endif // windows
+#if defined (__APPLE__)
+    #include <mach/clock.h>
+    #include <mach/mach.h>
+#endif // __APPLE__
+#include "sw_types.h"
+#include "plugin_environment.h"
+
+
+/* ***************************************************
+ * The following is valid only for userspace code.
+ * ***************************************************
+ */
+/*
+ * Default output file name -- the extensions depend on
+ * which program is executing: wuwatch output files have
+ * a ".sw1" extension, while wudump output files have a
+ * ".txt" extension. The extensions are added in by the
+ * respective programs i.e. wuwatch/wudump.
+ */
+#define DEFAULT_WUWATCH_OUTPUT_FILE_NAME "wuwatch_output"
+/*
+ * Default wuwatch config file name.
+ */
+#define DEFAULT_WUWATCH_CONFIG_FILE_NAME "wuwatch_config.txt"
+/*
+ * Default SWA 2.0 output file prefix. Actual file will
+ * be called 'SoCWatchOutput.sw2'
+ */
+#define DEFAULT_SWA_OUTPUT_FILE_PREFIX "SoCWatchOutput"
+/*
+ * Default SWA 2.0 config file name.
+ */
+#define DEFAULT_SWA_CONFIG_FILE_NAME "SOCWatchConfig.txt"
+/*
+ * Default SWA 2.0 config file directory.
+ */
+#ifdef SWW_MERGE
+#define DEFAULT_SWA_CONFIG_FILE_DIRECTORY "configs\\"
+#define DEFAULT_OUTPUT_CONFIG_FILE_DIRECTORY "output_configs\\"
+#define SW_COLLECTION_FILE_EXTENSION ".etl" // sww
+#define SWW_COLLECTION_FILE_PREFIX "_infoSession"
+#else
+#define DEFAULT_SWA_CONFIG_FILE_DIRECTORY "configs/"
+#define DEFAULT_OUTPUT_CONFIG_FILE_DIRECTORY "output_configs/"
+#define SW_COLLECTION_FILE_EXTENSION ".sw2" // swa
+#endif
+
+/*
+ * Default SWA 2.0 polling interval.
+ */
+#define DEFAULT_SWA_POLLING_INTERVAL_MSECS 100
+
+
+
+/*
+ * Macro to convert a {major.minor.other} version into a
+ * single 32-bit unsigned version number.
+ * This is useful when comparing versions, for example.
+ * Pretty much identical to the 'KERNEL_VERSION(...)' macro.
+ */
+//#define WUWATCH_VERSION(major, minor, other) ( (2^16) * (major) + (2^8) * (minor) + (other) )
+// #define COLLECTOR_VERSION(major, minor, other) ( (2^16) * (major) + (2^8) * (minor) + (other) )
+#define COLLECTOR_VERSION(major, minor, other) ( ((pw_u32_t)(major) << 16) + ((pw_u32_t)(minor) << 8) + (pw_u32_t)(other) )
+
+#define PW_SWA_RESULT_FILE_MAGIC_HEADER (0x8000000000000000ULL)
+#define PW_EXTRACT_SWA_MAGIC_HEADER(m) ( (m) & PW_SWA_RESULT_FILE_MAGIC_HEADER )
+#define PW_EXTRACT_SWA_VERSION_NUMBER(m) (pw_u32_t)( (m) & ~PW_SWA_RESULT_FILE_MAGIC_HEADER )
+#define PW_GET_MAJOR_FROM_COLLECTOR(v) (pw_u8_t) ( (v) >> 16 & 0xff )
+#define PW_GET_MINOR_FROM_COLLECTOR(v) (pw_u8_t) ( (v) >> 8 & 0xff )
+#define PW_GET_OTHER_FROM_COLLECTOR(v) (pw_u8_t) ( (v) & 0xff )
+#define PW_CONVERT_COLLECTOR_VERSION_TO_STRING(v) ([&]{std::stringstream __stream; \
+        __stream << (int)PW_GET_MAJOR_FROM_COLLECTOR(v) << "." << (int)PW_GET_MINOR_FROM_COLLECTOR(v) \
+        << "." << (int)PW_GET_OTHER_FROM_COLLECTOR(v); return __stream.str();}())
+/*
+ * Stringify.
+ */
+#define __STRING(x) #x
+#define TO_STRING(x) __STRING(x)
+/*
+ * Iterate over vectors, deques and ranges.
+ */
+#define for_each_ptr_in_vector(ptr, vector) for (size_t __curr=0, __end=(vector).size(); __curr!=__end && (ptr=(vector)[__curr]); ++__curr)
+/*
+ * Find a string 'str' in an array of 'std::string' instances
+ */
+#define FIND_STRING_IN_ARRAY(ptr, str, array) \
+    ([&]() { \
+        int s = SW_ARRAY_SIZE(array); \
+        bool found = (ptr = std::find((array), (array)+s, (str))) != &((array)[s]); \
+        return found; }())
+
+/* **************************************
+ * Debugging tools.
+ * **************************************
+ */
+enum pw_log_level_t {
+    PW_LOG_LEVEL_FATAL=0, /* Print FATALs */
+    PW_LOG_LEVEL_ERROR=1, /* Print ERRORs */
+    PW_LOG_LEVEL_WARNING=2, /* Print ERRORs + WARNINGs */
+    PW_LOG_LEVEL_DEBUG=3, /* Print ERRORs + WARNINGs + DEBUGs */
+    PW_LOG_LEVEL_INFO=4, /* Print ERRORs + WARNINGs + DEBUGs + INFORMATIONALs */
+#ifdef SWW_MERGE
+    // Windows cannot stringize a macro and then use the result to stringize
+    // another macro like g++ can.
+    PW_LOG_LEVEL_0 = PW_LOG_LEVEL_FATAL,
+    PW_LOG_LEVEL_1 = PW_LOG_LEVEL_ERROR,
+    PW_LOG_LEVEL_2 = PW_LOG_LEVEL_WARNING,
+    PW_LOG_LEVEL_3 = PW_LOG_LEVEL_DEBUG,
+    PW_LOG_LEVEL_4 = PW_LOG_LEVEL_INFO
+#endif // SWW_MERGE
+};
+
+//Defines to make the macros below work
+// #define PW_LOG_LEVEL_FATAL PW_LOG_LEVEL_ERROR
+#define s_FATALLogFP g_pluginEnvironment->getErrorLogFP()
+#define s_ERRORLogFP g_pluginEnvironment->getErrorLogFP()
+#define s_INFOLogFP g_pluginEnvironment->getDebugLogFP()
+#define s_WARNINGLogFP g_pluginEnvironment->getDebugLogFP()
+#define s_DEBUGLogFP g_pluginEnvironment->getDebugLogFP()
+#define PW_FATAL_STREAM std::cerr
+#define PW_ERROR_STREAM std::cerr
+#define PW_WARNING_STREAM std::cerr
+#define PW_INFO_STREAM std::cout
+#define PW_DEBUG_STREAM std::cout
+
+#ifdef SWW_MERGE
+    // Windows cannot stringize a macro and then use the result to stringize
+    // another macro like g++ can. NOTE: The numbers must match the pw_log_level_t enum!
+    #define PW_0_STREAM PW_FATAL_STREAM
+    #define PW_1_STREAM PW_ERROR_STREAM
+    #define PW_2_STREAM PW_WARNING_STREAM
+    #define PW_3_STREAM PW_INFO_STREAM
+    #define PW_4_STREAM PW_DEBUG_STREAM
+#endif // SWW_MERGE
+
+#define PW_LOG_OUTPUT(level, fp, format, ...) do { if (unlikely((level) <= g_pluginEnvironment->getVerbosity())){ fprintf(fp, format, ##__VA_ARGS__); fflush(fp);}} while(0);
+#define PW_GET_STREAM_HELPER(level, stream) ( (g_pluginEnvironment->getVerbosity() && (level) <= g_pluginEnvironment->getVerbosity()) ? (stream) : g_pluginEnvironment->getNullStream())
+/*
+ * Helper macros to print information
+ */
+#define PW_LOG_FATAL(format, ...) PW_LOG_OUTPUT(PW_LOG_LEVEL_FATAL, g_pluginEnvironment->getErrorLogFP(), "FATAL: " format, ##__VA_ARGS__);
+#define PW_LOG_ERROR(format, ...) PW_LOG_OUTPUT(PW_LOG_LEVEL_ERROR, g_pluginEnvironment->getErrorLogFP(), "ERROR: " format, ##__VA_ARGS__);
+#define PW_LOG_FATAL_LINE(format, ...) \
+    do { \
+        PW_LOG_OUTPUT(PW_LOG_LEVEL_FATAL, g_pluginEnvironment->getErrorLogFP(), "FATAL: " format, ##__VA_ARGS__); \
+        PW_LOG_OUTPUT(PW_LOG_LEVEL_DEBUG, g_pluginEnvironment->getErrorLogFP(), "         at %s:%d\n", __FILE__, __LINE__);\
+    } while (0);
+#define PW_LOG_ERROR_LINE(format, ...) \
+    do { \
+        PW_LOG_OUTPUT(PW_LOG_LEVEL_ERROR, g_pluginEnvironment->getErrorLogFP(), "ERROR: " format, ##__VA_ARGS__); \
+        PW_LOG_OUTPUT(PW_LOG_LEVEL_DEBUG, g_pluginEnvironment->getErrorLogFP(), "         at %s:%d\n", __FILE__, __LINE__);\
+    } while (0);
+#define PW_LOG_WARNING(format, ...) PW_LOG_OUTPUT(PW_LOG_LEVEL_WARNING, g_pluginEnvironment->getDebugLogFP(), "WARNING: " format, ##__VA_ARGS__)
+#define PW_LOG_DEBUG(format, ...) PW_LOG_OUTPUT(PW_LOG_LEVEL_DEBUG, g_pluginEnvironment->getDebugLogFP(),     "DEBUG: " format, ##__VA_ARGS__)
+#define PW_LOG_INFO(format, ...) PW_LOG_OUTPUT(PW_LOG_LEVEL_INFO, g_pluginEnvironment->getDebugLogFP(),       "INFO: " format, ##__VA_ARGS__)
+#define PW_LOG(type, ...) PW_LOG_OUTPUT(PW_LOG_LEVEL_##type, s_##type##LogFP, __VA_ARGS__)
+#define PW_LOG_FORCE(format, ...) fprintf(g_pluginEnvironment->getDebugLogFP(), format, ##__VA_ARGS__) /* Force a debug printf */
+
+/*
+ * For "conditional" logging i.e. logging if the log prefix
+ * matches one of the strings passed in by the user
+ */
+#define PW_COND_LOG(type, prefix, ...) do { \
+    FILE *_fp = s_##type##LogFP; \
+    if ((PW_LOG_LEVEL_##type) <= g_pluginEnvironment->getVerbosity() || g_pluginEnvironment->isDebugLoggingEnabledFor(prefix)) { \
+        fprintf(_fp, ##__VA_ARGS__); fflush(_fp); \
+    } \
+} while (0);
+
+#define PW_COND_LOG_ERROR(prefix, format, ...) PW_COND_LOG(ERROR, prefix, "ERROR: " format, ##__VA_ARGS__)
+#define PW_COND_LOG_WARNING(prefix, format, ...) PW_COND_LOG(WARNING, prefix, "WARNING: " format, ##__VA_ARGS__)
+#define PW_COND_LOG_DEBUG(prefix, format, ...) PW_COND_LOG(DEBUG, prefix, "DEBUG: " format, ##__VA_ARGS__)
+#define PW_COND_LOG_INFO(prefix, format, ...) PW_COND_LOG(INFO, prefix, "INFO: " format, ##__VA_ARGS__)
+#define PW_COND_LOG_FATAL(prefix, format, ...) PW_COND_LOG(FATAL, prefix, "FATAL: " format, ##__VA_ARGS__)
+#define PW_COND_LOG_FORCE(prefix, format, ...) PW_COND_LOG(FATAL, prefix, format, ##__VA_ARGS__)
+
+/*
+ * Macro to queue a text message to be sent to writer plugins once
+ * they are initialized.
+ * TODO: Find a way for the "PW_LOG_TEXT_MESSAGE" macro to either queue the input string, or create
+ * a 'TextMessage' instance depending on whether or not writer plugins have been initialized.
+ */
+#define PW_LOG_TEXT_MESSAGE(str) g_pluginEnvironment->queueMessage(str)
+/*
+ * Macro to display a text message to the console as well as queue the
+ * text message to be sent to writer plugins once they are initialized.
+ */
+#define PW_LOG_MESSAGE(str) do { \
+    PW_LOG_FORCE("%s\n", (str)); \
+    PW_LOG_TEXT_MESSAGE(str); \
+} while (0)
+
+#define PW_GET_FATAL_STREAM() PW_GET_STREAM_HELPER(PW_LOG_LEVEL_FATAL, std::cerr << "FATAL: ")
+#define PW_GET_ERROR_STREAM() PW_GET_STREAM_HELPER(PW_LOG_LEVEL_ERROR, std::cerr << "ERROR: ")
+#define PW_GET_WARNING_STREAM() PW_GET_STREAM_HELPER(PW_LOG_LEVEL_WARNING, std::cerr << "WARNING: ")
+#define PW_GET_DEBUG_STREAM() PW_GET_STREAM_HELPER(PW_LOG_LEVEL_DEBUG, std::cout << "DEBUG: ")
+#define PW_GET_INFO_STREAM() PW_GET_STREAM_HELPER(PW_LOG_LEVEL_INFO, std::cout << "INFO: ")
+#define PW_GET_STREAM(type) PW_GET_STREAM_HELPER(PW_LOG_LEVEL_##type, PW_##type##_STREAM)
+#define PW_GET_FORCE_STREAM() (std::cerr)
+
+/*
+ * Macros to copy and or assert.
+ */
+#define PW_DEBUG_COPY(level, ...) do { \
+    if (unlikely(g_pluginEnvironment->getVerbosity() && (PW_LOG_LEVEL_##level) <= g_pluginEnvironment->getVerbosity())) { \
+        std::copy(__VA_ARGS__); \
+    } \
+} while (0)
+#define PW_DEBUG_ASSERT(level, cond, ...) do { \
+    if (unlikely(g_pluginEnvironment->getVerbosity() && (PW_LOG_LEVEL_##level) <= g_pluginEnvironment->getVerbosity() && !(cond))) { \
+        PW_LOG_ERROR(__VA_ARGS__); \
+        PW_ASSERT(false); \
+    } \
+} while (0)
+
+/*
+ * Helper macro to calculate the diff between current and previous value and handle counter wrap around
+ */
+#define COUNTER_DELTA(next, prev, mask) (((next) >= (prev)) ? ((next)-(prev)) : ((mask)-(prev)+(next)+1))
+
+/*
+ * Check if a TSC indicates a counter reset.
+ */
+#define IS_RESET_TSC(msg)       (g_pluginEnvironment->isSystemReset((msg)->plugin_id, (msg)->metric_id, (msg)->msg_id, (msg)->tsc))
+
+/*
+ * Macros to trace function enters and exits.
+ */
+#if DEVELOPMENT_MODE // Development code; NOT meant for production
+    #define PW_TRACE_FUNCTION_ENTER() do { \
+        PW_LOG_INFO("Entering function %s\n", __FUNCTION__); \
+    } while(0)
+
+    #define PW_TRACE_FUNCTION_EXIT() do { \
+        PW_LOG_INFO("Exiting function %s\n", __FUNCTION__); \
+    } while(0)
+
+    #define PW_TRACE_FUNCTION_ENTER_VERBOSE() do { \
+        PW_LOG_INFO("Entering function %s\n", __PRETTY_FUNCTION__); \
+    } while(0)
+
+    #define PW_TRACE_FUNCTION_EXIT_VERBOSE() do { \
+        PW_LOG_INFO("Exiting function %s\n", __PRETTY_FUNCTION__); \
+    } while(0)
+    /*
+     * Basic timer-based profiling functions.
+     * Every 'ENTER' MUST be accompanied by
+     * a corresponding 'EXIT'!
+     */
+    #define PW_TIME_FUNCTION_ENTER() { \
+        PW_LOG_INFO("Entering function %s\n", __PRETTY_FUNCTION__); \
+        pwr::Timer __timer(__FUNCTION__);
+
+    #define PW_TIME_FUNCTION_EXIT() \
+        PW_LOG_INFO("Exiting function %s\n", __PRETTY_FUNCTION__); \
+    }
+#else // Production code
+    #define PW_TRACE_FUNCTION_ENTER() /* NOP */
+
+    #define PW_TRACE_FUNCTION_EXIT() /* NOP */
+
+    #define PW_TRACE_FUNCTION_ENTER_VERBOSE() /* NOP */
+
+    #define PW_TRACE_FUNCTION_EXIT_VERBOSE() /* NOP */
+
+    #define PW_TIME_FUNCTION_ENTER() { /* NOP */
+
+    #define PW_TIME_FUNCTION_EXIT() } /* NOP */
+#endif // DEVELOPMENT_MODE
+
+#define PW_DO_REPORT_FILE_ERROR(msg, path) do { \
+    PW_LOG_WARNING(msg, (path).c_str(), strerror(errno)); \
+} while(0)
+
+#define PW_TODO_MSG(msg) do { \
+    PW_LOG_WARNING("%s functionality is TODO!\n", (msg)); \
+} while(0)
+
+#ifdef SWW_MERGE
+#define __PRETTY_FUNCTION__ __FUNCTION__
+#endif // SWW_MERGE
+
+#define PW_TODO() do { \
+    PW_TODO_MSG(__PRETTY_FUNCTION__); \
+} while(0)
+
+#define PW_PERROR_LEVEL(msg, level) do { \
+    PW_GET_STREAM(level) << msg << ": " << strerror(errno) << std::endl; \
+} while(0)
+
+#define PW_PERROR(msg) PW_PERROR_LEVEL(msg, WARNING)
+
+/*
+ * A convenience macro to return the number
+ * of micro seconds elapsed since the epoch.
+ */
+#define PW_GET_CURR_TIME_USECS() ((double)pwr::getTimevalNano() / 1000.0)
+
+/*
+ * Macros corresponding to the kernel versions of 'likely()'
+ * and 'unlikely()' -- GCC SPECIFIC ONLY!
+ */
+#if defined (__linux__) || defined (__QNX__)
+    #define likely(x) __builtin_expect(!!(x), 1)
+    #define unlikely(x) __builtin_expect(!!(x), 0)
+#elif defined (__APPLE__)
+    #define likely(x)   (x)
+    #define unlikely(x) (x)
+#else // windows
+    #define likely(x) (!!(x))
+    #define unlikely(x) (!!(x))
+
+    #define __attribute__(a) // ignore __attribute__ macros on Windows
+#endif // linux
+
+/* Nanoseconds in a second */
+#define NANOSEC_PER_SEC (1000000000ULL)
+#define MILLISEC_PER_SEC (1000ULL)
+#define SEC_PER_MILLISEC ((double)1.0/MILLISEC_PER_SEC)
+#ifndef USEC_PER_SEC /* avoid redefinition in driver build */
+#define USEC_PER_SEC (1000000ULL)
+#endif
+#define SEC_PER_USEC ((double)1.0/USEC_PER_SEC)
+
+#endif // __KERNEL__
+
+#ifdef SWW_MERGE
+#define DOS_DIR_SEPARATOR_CHAR '\\'
+#define DOS_DIR_SEPARATOR_STR "\\"
+#define DOS_CUR_DIR ".\\"
+#endif
+
+#define DIR_SEPARATOR_CHAR '/'
+#define DIR_SEPARATOR_STR "/"
+#define CUR_DIR "./"
+
+#endif // _PW_USER_DEFINES_H_
diff --git a/drivers/misc/intel/socwatch/include/sw_version.h b/drivers/misc/intel/socwatch/include/sw_version.h
new file mode 100644
index 000000000000..d522f059357c
--- /dev/null
+++ b/drivers/misc/intel/socwatch/include/sw_version.h
@@ -0,0 +1,74 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 - 2018 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Contact Information:
+  SoC Watch Developer Team <socwatchdevelopers@intel.com>
+  Intel Corporation,
+  1906 Fox Drive,
+  Champaign, IL 61820
+
+  BSD LICENSE
+
+  Copyright(c) 2014 - 2018 Intel Corporation.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef __SW_VERSION_H__
+#define __SW_VERSION_H__ 1
+
+/*
+ * SOCWatch driver version
+ */
+#define SW_DRIVER_VERSION_MAJOR 2
+#define SW_DRIVER_VERSION_MINOR 6
+#define SW_DRIVER_VERSION_OTHER 1
+
+/*
+ * Every SOC Watch userspace component shares the same version number.
+ */
+#define SOCWATCH_VERSION_MAJOR 2
+#define SOCWATCH_VERSION_MINOR 6
+#define SOCWATCH_VERSION_OTHER 2
+
+#endif // __SW_VERSION_H__
-- 
2.18.0

